{"ast":null,"code":"import _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nvar isOrthographicCamera = function isOrthographicCamera(def) {\n  return def && def.isOrthographicCamera;\n};\nvar col = new THREE.Color();\n/**\n * In `@react-three/fiber` after `v8.0.0` but prior to `v8.1.0`, `state.size` contained only dimension\n * information. After `v8.1.0`, position information (`top`, `left`) was added\n *\n * @todo remove this when drei supports v9 and up\n */\n\nfunction isNonLegacyCanvasSize(size) {\n  return 'top' in size;\n}\nfunction computeContainerPosition(canvasSize, trackRect) {\n  var right = trackRect.right,\n    top = trackRect.top,\n    trackLeft = trackRect.left,\n    trackBottom = trackRect.bottom,\n    width = trackRect.width,\n    height = trackRect.height;\n  var isOffscreen = trackRect.bottom < 0 || top > canvasSize.height || right < 0 || trackRect.left > canvasSize.width;\n  if (isNonLegacyCanvasSize(canvasSize)) {\n    var canvasBottom = canvasSize.top + canvasSize.height;\n    var _bottom = canvasBottom - trackBottom;\n    var left = trackLeft - canvasSize.left;\n    return {\n      position: {\n        width: width,\n        height: height,\n        left: left,\n        top: top,\n        bottom: _bottom,\n        right: right\n      },\n      isOffscreen: isOffscreen\n    };\n  } // Fall back on old behavior if r3f < 8.1.0\n\n  var bottom = canvasSize.height - trackBottom;\n  return {\n    position: {\n      width: width,\n      height: height,\n      top: top,\n      left: trackLeft,\n      bottom: bottom,\n      right: right\n    },\n    isOffscreen: isOffscreen\n  };\n}\nfunction Container(_ref) {\n  var canvasSize = _ref.canvasSize,\n    scene = _ref.scene,\n    index = _ref.index,\n    children = _ref.children,\n    frames = _ref.frames,\n    rect = _ref.rect,\n    track = _ref.track;\n  var get = useThree(function (state) {\n    return state.get;\n  });\n  var camera = useThree(function (state) {\n    return state.camera;\n  });\n  var virtualScene = useThree(function (state) {\n    return state.scene;\n  });\n  var setEvents = useThree(function (state) {\n    return state.setEvents;\n  });\n  var frameCount = 0;\n  useFrame(function (state) {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n    if (rect.current) {\n      var _computeContainerPosi = computeContainerPosition(canvasSize, rect.current),\n        _computeContainerPosi2 = _computeContainerPosi.position,\n        left = _computeContainerPosi2.left,\n        bottom = _computeContainerPosi2.bottom,\n        width = _computeContainerPosi2.width,\n        height = _computeContainerPosi2.height,\n        isOffscreen = _computeContainerPosi.isOffscreen;\n      var aspect = width / height;\n      if (isOrthographicCamera(camera)) {\n        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {\n          Object.assign(camera, {\n            left: width / -2,\n            right: width / 2,\n            top: height / 2,\n            bottom: height / -2\n          });\n          camera.updateProjectionMatrix();\n        }\n      } else if (camera.aspect !== aspect) {\n        camera.aspect = aspect;\n        camera.updateProjectionMatrix();\n      }\n      state.gl.setViewport(left, bottom, width, height);\n      state.gl.setScissor(left, bottom, width, height);\n      state.gl.setScissorTest(true);\n      if (isOffscreen) {\n        state.gl.getClearColor(col);\n        state.gl.setClearColor(col, state.gl.getClearAlpha());\n        state.gl.clear(true, true);\n        return;\n      } // When children are present render the portalled scene, otherwise the default scene\n\n      state.gl.render(children ? virtualScene : scene, camera);\n    }\n  }, index);\n  React.useEffect(function () {\n    // Connect the event layer to the tracking element\n    var old = get().events.connected;\n    setEvents({\n      connected: track.current\n    });\n    return function () {\n      return setEvents({\n        connected: old\n      });\n    };\n  }, []);\n  React.useEffect(function () {\n    if (isNonLegacyCanvasSize(canvasSize)) {\n      return;\n    }\n    console.warn('Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. ' + 'Upgrade to @react-three/fiber ^8.1.0 for support.\\n See https://github.com/pmndrs/drei/issues/944');\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nvar View = function View(_ref2) {\n  var track = _ref2.track,\n    _ref2$index = _ref2.index,\n    index = _ref2$index === void 0 ? 1 : _ref2$index,\n    _ref2$frames = _ref2.frames,\n    frames = _ref2$frames === void 0 ? Infinity : _ref2$frames,\n    children = _ref2.children;\n  var rect = React.useRef(null);\n  var _useThree = useThree(),\n    size = _useThree.size,\n    scene = _useThree.scene;\n  var _React$useState = React.useState(function () {\n      return new THREE.Scene();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    virtualScene = _React$useState2[0];\n  var compute = React.useCallback(function (event, state) {\n    if (track.current && event.target === track.current) {\n      var _rect$current = rect.current,\n        width = _rect$current.width,\n        height = _rect$current.height,\n        left = _rect$current.left,\n        top = _rect$current.top;\n      var x = event.clientX - left;\n      var y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect]);\n  var _React$useReducer = React.useReducer(function () {\n      return true;\n    }, false),\n    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n    ready = _React$useReducer2[0],\n    toggle = _React$useReducer2[1];\n  React.useEffect(function () {\n    var _track$current2;\n\n    // We need the tracking elements bounds beforehand in order to inject it into the portal\n    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect(); // And now we can proceed\n\n    toggle();\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, ready && createPortal( /*#__PURE__*/React.createElement(Container, {\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute: compute,\n      priority: index\n    },\n    size: {\n      width: rect.current.width,\n      height: rect.current.height\n    }\n  }));\n};\nexport { View };","map":null,"metadata":{},"sourceType":"module"}