{"ast":null,"code":"import _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport { useState, useContext, useRef, useLayoutEffect, createContext } from 'react';\nimport { useFrame } from '@react-three/fiber';\nvar context = /*#__PURE__*/createContext(null);\nfunction PerformanceMonitor(_ref) {\n  var _ref$iterations = _ref.iterations,\n    iterations = _ref$iterations === void 0 ? 10 : _ref$iterations,\n    _ref$ms = _ref.ms,\n    ms = _ref$ms === void 0 ? 250 : _ref$ms,\n    _ref$threshold = _ref.threshold,\n    threshold = _ref$threshold === void 0 ? 0.75 : _ref$threshold,\n    _ref$step = _ref.step,\n    step = _ref$step === void 0 ? 0.1 : _ref$step,\n    _ref$factor = _ref.factor,\n    _factor = _ref$factor === void 0 ? 0.5 : _ref$factor,\n    _ref$flipflops = _ref.flipflops,\n    flipflops = _ref$flipflops === void 0 ? Infinity : _ref$flipflops,\n    _ref$bounds = _ref.bounds,\n    bounds = _ref$bounds === void 0 ? function (refreshrate) {\n      return refreshrate > 100 ? [60, 100] : [40, 60];\n    } : _ref$bounds,\n    onIncline = _ref.onIncline,\n    onDecline = _ref.onDecline,\n    onChange = _ref.onChange,\n    onFallback = _ref.onFallback,\n    children = _ref.children;\n  var decimalPlacesRatio = Math.pow(10, 0);\n  var _useState = useState(function () {\n      return {\n        fps: 0,\n        index: 0,\n        factor: _factor,\n        flipped: 0,\n        refreshrate: 0,\n        fallback: false,\n        frames: [],\n        averages: [],\n        subscriptions: new Map(),\n        subscribe: function subscribe(ref) {\n          var key = Symbol();\n          api.subscriptions.set(key, ref.current);\n          return function () {\n            return void api.subscriptions[\"delete\"](key);\n          };\n        }\n      };\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    api = _useState2[0],\n    _ = _useState2[1];\n  var lastFactor = 0;\n  useFrame(function () {\n    var frames = api.frames,\n      averages = api.averages; // If the fallback has been reached do not continue running samples\n\n    if (api.fallback) return;\n    if (averages.length < iterations) {\n      frames.push(performance.now());\n      var msPassed = frames[frames.length - 1] - frames[0];\n      if (msPassed >= ms) {\n        api.fps = Math.round(frames.length / msPassed * 1000 * decimalPlacesRatio) / decimalPlacesRatio;\n        api.refreshrate = Math.max(api.refreshrate, api.fps);\n        averages[api.index++ % iterations] = api.fps;\n        if (averages.length === iterations) {\n          var _bounds = bounds(api.refreshrate),\n            _bounds2 = _slicedToArray(_bounds, 2),\n            lower = _bounds2[0],\n            upper = _bounds2[1];\n          var upperBounds = averages.filter(function (value) {\n            return value >= upper;\n          });\n          var lowerBounds = averages.filter(function (value) {\n            return value < lower;\n          }); // Trigger incline when more than -threshold- avgs exceed the upper bound\n\n          if (upperBounds.length > iterations * threshold) {\n            api.factor = Math.min(1, api.factor + step);\n            api.flipped++;\n            if (onIncline) onIncline(api);\n            api.subscriptions.forEach(function (value) {\n              return value.onIncline && value.onIncline(api);\n            });\n          } // Trigger decline when more than -threshold- avgs are below the lower bound\n\n          if (lowerBounds.length > iterations * threshold) {\n            api.factor = Math.max(0, api.factor - step);\n            api.flipped++;\n            if (onDecline) onDecline(api);\n            api.subscriptions.forEach(function (value) {\n              return value.onDecline && value.onDecline(api);\n            });\n          }\n          if (lastFactor !== api.factor) {\n            lastFactor = api.factor;\n            if (onChange) onChange(api);\n            api.subscriptions.forEach(function (value) {\n              return value.onChange && value.onChange(api);\n            });\n          }\n          if (api.flipped > flipflops && !api.fallback) {\n            api.fallback = true;\n            if (onFallback) onFallback(api);\n            api.subscriptions.forEach(function (value) {\n              return value.onFallback && value.onFallback(api);\n            });\n          }\n          api.averages = []; // Resetting the refreshrate creates more problems than it solves atm\n          // api.refreshrate = 0\n        }\n\n        api.frames = [];\n      }\n    }\n  });\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children);\n}\nfunction usePerformanceMonitor(_ref2) {\n  var onIncline = _ref2.onIncline,\n    onDecline = _ref2.onDecline,\n    onChange = _ref2.onChange,\n    onFallback = _ref2.onFallback;\n  var api = useContext(context);\n  var ref = useRef({\n    onIncline: onIncline,\n    onDecline: onDecline,\n    onChange: onChange,\n    onFallback: onFallback\n  });\n  useLayoutEffect(function () {\n    ref.current.onIncline = onIncline;\n    ref.current.onDecline = onDecline;\n    ref.current.onChange = onChange;\n    ref.current.onFallback = onFallback;\n  }, [onIncline, onDecline, onChange, onFallback]);\n  useLayoutEffect(function () {\n    return api.subscribe(ref);\n  }, [api]);\n}\nexport { PerformanceMonitor, usePerformanceMonitor };","map":null,"metadata":{},"sourceType":"module"}