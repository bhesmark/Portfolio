{"ast":null,"code":"import _toConsumableArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { Color, AdditiveBlending, ShaderMaterial, Vector3, Spherical } from 'three';\nvar StarfieldMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(StarfieldMaterial, _ShaderMaterial);\n  var _super = _createSuper(StarfieldMaterial);\n  function StarfieldMaterial() {\n    _classCallCheck(this, StarfieldMaterial);\n    return _super.call(this, {\n      uniforms: {\n        time: {\n          value: 0.0\n        },\n        fade: {\n          value: 1.0\n        }\n      },\n      vertexShader: /* glsl */\"\\n      uniform float time;\\n      attribute float size;\\n      varying vec3 vColor;\\n      void main() {\\n        vColor = color;\\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\\n        gl_Position = projectionMatrix * mvPosition;\\n      }\",\n      fragmentShader: /* glsl */\"\\n      uniform sampler2D pointTexture;\\n      uniform float fade;\\n      varying vec3 vColor;\\n      void main() {\\n        float opacity = 1.0;\\n        if (fade == 1.0) {\\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\\n        }\\n        gl_FragColor = vec4(vColor, opacity);\\n\\n        #include <tonemapping_fragment>\\n\\t      #include <encodings_fragment>\\n      }\"\n    });\n  }\n  return _createClass(StarfieldMaterial);\n}(ShaderMaterial);\nvar genStar = function genStar(r) {\n  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));\n};\nvar Stars = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var _ref$radius = _ref.radius,\n    radius = _ref$radius === void 0 ? 100 : _ref$radius,\n    _ref$depth = _ref.depth,\n    depth = _ref$depth === void 0 ? 50 : _ref$depth,\n    _ref$count = _ref.count,\n    count = _ref$count === void 0 ? 5000 : _ref$count,\n    _ref$saturation = _ref.saturation,\n    saturation = _ref$saturation === void 0 ? 0 : _ref$saturation,\n    _ref$factor = _ref.factor,\n    factor = _ref$factor === void 0 ? 4 : _ref$factor,\n    _ref$fade = _ref.fade,\n    fade = _ref$fade === void 0 ? false : _ref$fade,\n    _ref$speed = _ref.speed,\n    speed = _ref$speed === void 0 ? 1 : _ref$speed;\n  var material = React.useRef();\n  var _React$useMemo = React.useMemo(function () {\n      var positions = [];\n      var colors = [];\n      var sizes = Array.from({\n        length: count\n      }, function () {\n        return (0.5 + 0.5 * Math.random()) * factor;\n      });\n      var color = new Color();\n      var r = radius + depth;\n      var increment = depth / count;\n      for (var i = 0; i < count; i++) {\n        r -= increment * Math.random();\n        positions.push.apply(positions, _toConsumableArray(genStar(r).toArray()));\n        color.setHSL(i / count, saturation, 0.9);\n        colors.push(color.r, color.g, color.b);\n      }\n      return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];\n    }, [count, depth, factor, radius, saturation]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n    position = _React$useMemo2[0],\n    color = _React$useMemo2[1],\n    size = _React$useMemo2[2];\n  useFrame(function (state) {\n    return material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime() * speed);\n  });\n  var _React$useState = React.useState(function () {\n      return new StarfieldMaterial();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    starfieldMaterial = _React$useState2[0];\n  return /*#__PURE__*/React.createElement(\"points\", {\n    ref: ref\n  }, /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    args: [position, 3]\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    args: [color, 3]\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    args: [size, 1]\n  })), /*#__PURE__*/React.createElement(\"primitive\", {\n    ref: material,\n    object: starfieldMaterial,\n    attach: \"material\",\n    blending: AdditiveBlending,\n    \"uniforms-fade-value\": fade,\n    depthWrite: false,\n    transparent: true,\n    vertexColors: true\n  }));\n});\nexport { Stars };","map":null,"metadata":{},"sourceType":"module"}