{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\nvar _nodeId = 0;\nvar Node = /*#__PURE__*/function () {\n  function Node() {\n    var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, Node);\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n  _createClass(Node, [{\n    key: \"type\",\n    get: function get() {\n      return this.constructor.name;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.uuid;\n    }\n  }, {\n    key: \"getUpdateType\",\n    value: function getUpdateType() {\n      return this.updateType;\n    }\n  }, {\n    key: \"getNodeType\",\n    value: function getNodeType() {\n      return this.nodeType;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"analyze\",\n    value: function analyze(builder) {\n      var hash = this.getHash(builder);\n      var sharedNode = builder.getNodeFromHash(hash);\n      if (sharedNode !== undefined && this !== sharedNode) {\n        return sharedNode.analyze(builder);\n      }\n      var nodeData = builder.getDataFromNode(this);\n      nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n      var nodeKeys = getNodesKeys(this);\n      var _iterator = _createForOfIteratorHelper(nodeKeys),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var property = _step.value;\n          this[property].analyze(builder);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"build\",\n    value: function build(builder) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var hash = this.getHash(builder);\n      var sharedNode = builder.getNodeFromHash(hash);\n      if (sharedNode !== undefined && this !== sharedNode) {\n        return sharedNode.build(builder, output);\n      }\n      builder.addNode(this);\n      builder.addStack(this);\n      var nodeData = builder.getDataFromNode(this);\n      var isGenerateOnce = this.generate.length === 1;\n      var snippet = null;\n      if (isGenerateOnce) {\n        var type = this.getNodeType(builder);\n        snippet = nodeData.snippet;\n        if (snippet === undefined) {\n          snippet = this.generate(builder) || '';\n          nodeData.snippet = snippet;\n        }\n        snippet = builder.format(snippet, type, output);\n      } else {\n        snippet = this.generate(builder, output) || '';\n      }\n      builder.removeStack(this);\n      return snippet;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(json) {\n      var nodeKeys = getNodesKeys(this);\n      if (nodeKeys.length > 0) {\n        var inputNodes = {};\n        var _iterator2 = _createForOfIteratorHelper(nodeKeys),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var property = _step2.value;\n            inputNodes[property] = this[property].toJSON(json.meta).uuid;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        json.inputNodes = inputNodes;\n      }\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(json) {\n      if (json.inputNodes !== undefined) {\n        var nodes = json.meta.nodes;\n        for (var property in json.inputNodes) {\n          var uuid = json.inputNodes[property];\n          this[property] = nodes[uuid];\n        }\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(meta) {\n      var uuid = this.uuid,\n        type = this.type;\n      var isRoot = meta === undefined || typeof meta === 'string';\n      if (isRoot) {\n        meta = {\n          textures: {},\n          images: {},\n          nodes: {}\n        };\n      } // serialize\n\n      var data = meta.nodes[uuid];\n      if (data === undefined) {\n        data = {\n          uuid: uuid,\n          type: type,\n          meta: meta,\n          metadata: {\n            version: 4.5,\n            type: 'Node',\n            generator: 'Node.toJSON'\n          }\n        };\n        meta.nodes[data.uuid] = data;\n        this.serialize(data);\n        delete data.meta;\n      } // TODO: Copied from Object3D.toJSON\n\n      function extractFromCache(cache) {\n        var values = [];\n        for (var key in cache) {\n          var _data = cache[key];\n          delete _data.metadata;\n          values.push(_data);\n        }\n        return values;\n      }\n      if (isRoot) {\n        var textures = extractFromCache(meta.textures);\n        var images = extractFromCache(meta.images);\n        var nodes = extractFromCache(meta.nodes);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n        if (nodes.length > 0) data.nodes = nodes;\n      }\n      return data;\n    }\n  }]);\n  return Node;\n}();\nNode.prototype.isNode = true;\nexport default Node;","map":null,"metadata":{},"sourceType":"module"}