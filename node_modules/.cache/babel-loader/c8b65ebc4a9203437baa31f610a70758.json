{"ast":null,"code":"import _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Line, BufferGeometry, BufferAttribute, LineBasicMaterial, MathUtils } from 'three';\nvar PositionalAudioHelper = /*#__PURE__*/function (_Line) {\n  _inherits(PositionalAudioHelper, _Line);\n  var _super = _createSuper(PositionalAudioHelper);\n  function PositionalAudioHelper(audio) {\n    var _this;\n    var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var divisionsInnerAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n    var divisionsOuterAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    _classCallCheck(this, PositionalAudioHelper);\n    var geometry = new BufferGeometry();\n    var divisions = divisionsInnerAngle + divisionsOuterAngle * 2;\n    var positions = new Float32Array((divisions * 3 + 3) * 3);\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n    var materialInnerAngle = new LineBasicMaterial({\n      color: 0x00ff00\n    });\n    var materialOuterAngle = new LineBasicMaterial({\n      color: 0xffff00\n    });\n    _this = _super.call(this, geometry, [materialOuterAngle, materialInnerAngle]);\n    _this.type = 'PositionalAudioHelper';\n    _this.audio = audio;\n    _this.range = range;\n    _this.divisionsInnerAngle = divisionsInnerAngle;\n    _this.divisionsOuterAngle = divisionsOuterAngle;\n    _this.update();\n    return _this;\n  }\n  _createClass(PositionalAudioHelper, [{\n    key: \"update\",\n    value: function update() {\n      var audio = this.audio;\n      var range = this.range;\n      var divisionsInnerAngle = this.divisionsInnerAngle;\n      var divisionsOuterAngle = this.divisionsOuterAngle;\n      var coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);\n      var coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);\n      var halfConeInnerAngle = coneInnerAngle / 2;\n      var halfConeOuterAngle = coneOuterAngle / 2;\n      var start = 0;\n      var count = 0;\n      var i, stride;\n      var geometry = this.geometry;\n      var positionAttribute = geometry.attributes.position;\n      geometry.clearGroups(); //\n\n      function generateSegment(from, to, divisions, materialIndex) {\n        var step = (to - from) / divisions;\n        positionAttribute.setXYZ(start, 0, 0, 0);\n        count++;\n        for (i = from; i < to; i += step) {\n          stride = start + count;\n          positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);\n          positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);\n          positionAttribute.setXYZ(stride + 2, 0, 0, 0);\n          count += 3;\n        }\n        geometry.addGroup(start, count, materialIndex);\n        start += count;\n        count = 0;\n      } //\n\n      generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);\n      generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);\n      generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0); //\n\n      positionAttribute.needsUpdate = true;\n      if (coneInnerAngle === coneOuterAngle) this.material[0].visible = false;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material[0].dispose();\n      this.material[1].dispose();\n    }\n  }]);\n  return PositionalAudioHelper;\n}(Line);\nexport { PositionalAudioHelper };","map":null,"metadata":{},"sourceType":"module"}