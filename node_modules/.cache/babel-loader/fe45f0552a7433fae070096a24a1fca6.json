{"ast":null,"code":"import _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Line } from '../../core/Line.js';\nimport { Html } from '../Html.js';\nimport clamp from 'lodash.clamp';\nimport { context } from './context.js';\nvar clickDir = new THREE.Vector3();\nvar intersectionDir = new THREE.Vector3();\nvar toDegrees = function toDegrees(radians) {\n  return radians * 180 / Math.PI;\n};\nvar toRadians = function toRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\nvar calculateAngle = function calculateAngle(clickPoint, intersectionPoint, origin, e1, e2) {\n  clickDir.copy(clickPoint).sub(origin);\n  intersectionDir.copy(intersectionPoint).sub(origin);\n  var dote1e1 = e1.dot(e1);\n  var dote2e2 = e2.dot(e2);\n  var uClick = clickDir.dot(e1) / dote1e1;\n  var vClick = clickDir.dot(e2) / dote2e2;\n  var uIntersection = intersectionDir.dot(e1) / dote1e1;\n  var vIntersection = intersectionDir.dot(e2) / dote2e2;\n  var angleClick = Math.atan2(vClick, uClick);\n  var angleIntersection = Math.atan2(vIntersection, uIntersection);\n  return angleIntersection - angleClick;\n};\nvar fmod = function fmod(num, denom) {\n  var k = Math.floor(num / denom);\n  k = k < 0 ? k + 1 : k;\n  return num - k * denom;\n};\nvar minimizeAngle = function minimizeAngle(angle) {\n  var result = fmod(angle, 2 * Math.PI);\n  if (Math.abs(result) < 1e-6) {\n    return 0.0;\n  }\n  if (result < 0.0) {\n    result += 2 * Math.PI;\n  }\n  return result;\n};\nvar rotMatrix = new THREE.Matrix4();\nvar posNew = new THREE.Vector3();\nvar ray = new THREE.Ray();\nvar intersection = new THREE.Vector3();\nvar AxisRotator = function AxisRotator(_ref) {\n  var dir1 = _ref.dir1,\n    dir2 = _ref.dir2,\n    axis = _ref.axis;\n  var _React$useContext = React.useContext(context),\n    rotationLimits = _React$useContext.rotationLimits,\n    annotationsClass = _React$useContext.annotationsClass,\n    depthTest = _React$useContext.depthTest,\n    scale = _React$useContext.scale,\n    lineWidth = _React$useContext.lineWidth,\n    fixed = _React$useContext.fixed,\n    axisColors = _React$useContext.axisColors,\n    hoveredColor = _React$useContext.hoveredColor,\n    displayValues = _React$useContext.displayValues,\n    opacity = _React$useContext.opacity,\n    onDragStart = _React$useContext.onDragStart,\n    onDrag = _React$useContext.onDrag,\n    onDragEnd = _React$useContext.onDragEnd,\n    userData = _React$useContext.userData; // @ts-expect-error new in @react-three/fiber@7.0.5\n\n  var camControls = useThree(function (state) {\n    return state.controls;\n  });\n  var divRef = React.useRef(null);\n  var objRef = React.useRef(null);\n  var angle0 = React.useRef(0);\n  var angle = React.useRef(0);\n  var clickInfo = React.useRef(null);\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    isHovered = _React$useState2[0],\n    setIsHovered = _React$useState2[1];\n  var onPointerDown = React.useCallback(function (e) {\n    if (displayValues) {\n      divRef.current.innerText = \"\".concat(toDegrees(angle.current).toFixed(0), \"\\xBA\");\n      divRef.current.style.display = 'block';\n    }\n    e.stopPropagation();\n    var clickPoint = e.point.clone();\n    var origin = new THREE.Vector3().setFromMatrixPosition(objRef.current.matrixWorld);\n    var e1 = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 0).normalize();\n    var e2 = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 1).normalize();\n    var normal = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 2).normalize();\n    var plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, origin);\n    clickInfo.current = {\n      clickPoint: clickPoint,\n      origin: origin,\n      e1: e1,\n      e2: e2,\n      normal: normal,\n      plane: plane\n    };\n    onDragStart({\n      component: 'Rotator',\n      axis: axis,\n      origin: origin,\n      directions: [e1, e2, normal]\n    });\n    camControls && (camControls.enabled = false); // @ts-ignore\n\n    e.target.setPointerCapture(e.pointerId);\n  }, [camControls, onDragStart, axis]);\n  var onPointerMove = React.useCallback(function (e) {\n    e.stopPropagation();\n    if (!isHovered) setIsHovered(true);\n    if (clickInfo.current) {\n      var _clickInfo$current = clickInfo.current,\n        clickPoint = _clickInfo$current.clickPoint,\n        origin = _clickInfo$current.origin,\n        e1 = _clickInfo$current.e1,\n        e2 = _clickInfo$current.e2,\n        normal = _clickInfo$current.normal,\n        plane = _clickInfo$current.plane;\n      var _ref2 = (rotationLimits == null ? void 0 : rotationLimits[axis]) || [undefined, undefined],\n        _ref3 = _slicedToArray(_ref2, 2),\n        min = _ref3[0],\n        max = _ref3[1];\n      ray.copy(e.ray);\n      ray.intersectPlane(plane, intersection);\n      ray.direction.negate();\n      ray.intersectPlane(plane, intersection);\n      var deltaAngle = calculateAngle(clickPoint, intersection, origin, e1, e2);\n      var degrees = toDegrees(deltaAngle); // @ts-ignore\n\n      if (e.shiftKey) {\n        degrees = Math.round(degrees / 10) * 10;\n        deltaAngle = toRadians(degrees);\n      }\n      if (min !== undefined && max !== undefined && max - min < 2 * Math.PI) {\n        deltaAngle = minimizeAngle(deltaAngle);\n        deltaAngle = deltaAngle > Math.PI ? deltaAngle - 2 * Math.PI : deltaAngle;\n        deltaAngle = clamp(deltaAngle, min - angle0.current, max - angle0.current);\n        angle.current = angle0.current + deltaAngle;\n      } else {\n        angle.current = minimizeAngle(angle0.current + deltaAngle);\n        angle.current = angle.current > Math.PI ? angle.current - 2 * Math.PI : angle.current;\n      }\n      if (displayValues) {\n        degrees = toDegrees(angle.current);\n        divRef.current.innerText = \"\".concat(degrees.toFixed(0), \"\\xBA\");\n      }\n      rotMatrix.makeRotationAxis(normal, deltaAngle);\n      posNew.copy(origin).applyMatrix4(rotMatrix).sub(origin).negate();\n      rotMatrix.setPosition(posNew);\n      onDrag(rotMatrix);\n    }\n  }, [onDrag, isHovered, rotationLimits, axis]);\n  var onPointerUp = React.useCallback(function (e) {\n    if (displayValues) {\n      divRef.current.style.display = 'none';\n    }\n    e.stopPropagation();\n    angle0.current = angle.current;\n    clickInfo.current = null;\n    onDragEnd();\n    camControls && (camControls.enabled = true); // @ts-ignore\n\n    e.target.releasePointerCapture(e.pointerId);\n  }, [camControls, onDragEnd]);\n  var onPointerOut = React.useCallback(function (e) {\n    e.stopPropagation();\n    setIsHovered(false);\n  }, []);\n  var matrixL = React.useMemo(function () {\n    var dir1N = dir1.clone().normalize();\n    var dir2N = dir2.clone().normalize();\n    return new THREE.Matrix4().makeBasis(dir1N, dir2N, dir1N.clone().cross(dir2N));\n  }, [dir1, dir2]);\n  var r = fixed ? 0.65 : scale * 0.65;\n  var arc = React.useMemo(function () {\n    var segments = 32;\n    var points = [];\n    for (var j = 0; j <= segments; j++) {\n      var _angle = j * (Math.PI / 2) / segments;\n      points.push(new THREE.Vector3(Math.cos(_angle) * r, Math.sin(_angle) * r, 0));\n    }\n    return points;\n  }, [r]);\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: objRef,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onPointerOut: onPointerOut,\n    matrix: matrixL,\n    matrixAutoUpdate: false\n  }, /*#__PURE__*/React.createElement(Html, {\n    position: [r, r, 0]\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none',\n      background: '#151520',\n      color: 'white',\n      padding: '6px 8px',\n      borderRadius: 7,\n      whiteSpace: 'nowrap'\n    },\n    className: annotationsClass,\n    ref: divRef\n  })), /*#__PURE__*/React.createElement(Line, {\n    points: arc,\n    lineWidth: lineWidth * 4,\n    visible: false,\n    userData: userData\n  }), /*#__PURE__*/React.createElement(Line, {\n    transparent: true,\n    raycast: function raycast() {\n      return null;\n    },\n    depthTest: depthTest,\n    points: arc,\n    lineWidth: lineWidth,\n    color: isHovered ? hoveredColor : axisColors[axis],\n    opacity: opacity,\n    polygonOffset: true,\n    polygonOffsetFactor: -10\n  }));\n};\nexport { AxisRotator };","map":null,"metadata":{},"sourceType":"module"}