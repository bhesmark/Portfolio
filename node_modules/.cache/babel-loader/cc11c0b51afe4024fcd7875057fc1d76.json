{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\clent\\\\OneDrive\\\\Documents\\\\gsrlic\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { colorToRgb, getStyleFromRgb } from \"../../Utils/ColorUtils\";\nimport { Vector } from \"../../Core/Utils/Vector\";\nimport { getDistances } from \"../../Utils/NumberUtils\";\nexport function drawPolygonMask(context, rawData, stroke) {\n  var color = colorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n  var _iterator = _createForOfIteratorHelper(rawData),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      context.lineTo(item.x, item.y);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  context.closePath();\n  context.strokeStyle = getStyleFromRgb(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n  context.translate(position.x, position.y);\n  var color = colorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n  var _a;\n  var res = [];\n  var _iterator2 = _createForOfIteratorHelper(paths),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var path = _step2.value;\n      var segments = path.element.pathSegList,\n        len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0,\n        p = {\n          x: 0,\n          y: 0\n        };\n      for (var i = 0; i < len; i++) {\n        var segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n        var svgPathSeg = window.SVGPathSeg;\n        switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n          case svgPathSeg.PATHSEG_MOVETO_ABS:\n          case svgPathSeg.PATHSEG_LINETO_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n          case svgPathSeg.PATHSEG_ARC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n            {\n              var absSeg = segment;\n              p.x = absSeg.x;\n              p.y = absSeg.y;\n              break;\n            }\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n            p.x = segment.x;\n            break;\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n            p.y = segment.y;\n            break;\n          case svgPathSeg.PATHSEG_LINETO_REL:\n          case svgPathSeg.PATHSEG_MOVETO_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n          case svgPathSeg.PATHSEG_ARC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n            {\n              var relSeg = segment;\n              p.x += relSeg.x;\n              p.y += relSeg.y;\n              break;\n            }\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n            p.x += segment.x;\n            break;\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n            p.y += segment.y;\n            break;\n          case svgPathSeg.PATHSEG_UNKNOWN:\n          case svgPathSeg.PATHSEG_CLOSEPATH:\n            continue;\n        }\n        res.push({\n          x: p.x * scale + offset.x,\n          y: p.y * scale + offset.y\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n  var _getDistances = getDistances(pos, s1),\n    dx = _getDistances.dx,\n    dy = _getDistances.dy,\n    _getDistances2 = getDistances(s2, s1),\n    dxx = _getDistances2.dx,\n    dyy = _getDistances2.dy,\n    t = (dx * dxx + dy * dyy) / (Math.pow(dxx, 2) + Math.pow(dyy, 2)),\n    res = {\n      x: s1.x + dxx * t,\n      y: s1.x + dyy * t,\n      isOnSegment: t >= 0 && t <= 1\n    };\n  if (t < 0) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > 1) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n  return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n  var _getDistances3 = getDistances(start, stop),\n    dx = _getDistances3.dx,\n    dy = _getDistances3.dy,\n    wallAngle = Math.atan2(dy, dx),\n    wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n    d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}","map":null,"metadata":{},"sourceType":"module"}