{"ast":null,"code":"import _objectSpread from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"scale\", \"frames\", \"opacity\", \"width\", \"height\", \"blur\", \"far\", \"resolution\", \"smooth\", \"color\", \"depthWrite\", \"renderOrder\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\nvar ContactShadows = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var _ref$scale = _ref.scale,\n    scale = _ref$scale === void 0 ? 10 : _ref$scale,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? Infinity : _ref$frames,\n    _ref$opacity = _ref.opacity,\n    opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n    _ref$width = _ref.width,\n    width = _ref$width === void 0 ? 1 : _ref$width,\n    _ref$height = _ref.height,\n    height = _ref$height === void 0 ? 1 : _ref$height,\n    _ref$blur = _ref.blur,\n    blur = _ref$blur === void 0 ? 1 : _ref$blur,\n    _ref$far = _ref.far,\n    far = _ref$far === void 0 ? 10 : _ref$far,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 512 : _ref$resolution,\n    _ref$smooth = _ref.smooth,\n    smooth = _ref$smooth === void 0 ? true : _ref$smooth,\n    _ref$color = _ref.color,\n    color = _ref$color === void 0 ? '#000000' : _ref$color,\n    _ref$depthWrite = _ref.depthWrite,\n    depthWrite = _ref$depthWrite === void 0 ? false : _ref$depthWrite,\n    renderOrder = _ref.renderOrder,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var shadowCamera = React.useRef(null);\n  width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n  height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n  var _React$useMemo = React.useMemo(function () {\n      var renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n      var renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n      renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n      var planeGeometry = new THREE.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n      var blurPlane = new THREE.Mesh(planeGeometry);\n      var depthMaterial = new THREE.MeshDepthMaterial();\n      depthMaterial.depthTest = depthMaterial.depthWrite = false;\n      depthMaterial.onBeforeCompile = function (shader) {\n        shader.uniforms = _objectSpread(_objectSpread({}, shader.uniforms), {}, {\n          ucolor: {\n            value: new THREE.Color(color)\n          }\n        });\n        shader.fragmentShader = shader.fragmentShader.replace(\"void main() {\", //\n        \"uniform vec3 ucolor;\\n           void main() {\\n          \");\n        shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n        // Colorize the shadow, multiply by the falloff so that the center can remain darker\n        'vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );');\n      };\n      var horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n      var verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n      verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n      return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n    }, [resolution, width, height, scale, color]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 7),\n    renderTarget = _React$useMemo2[0],\n    planeGeometry = _React$useMemo2[1],\n    depthMaterial = _React$useMemo2[2],\n    blurPlane = _React$useMemo2[3],\n    horizontalBlurMaterial = _React$useMemo2[4],\n    verticalBlurMaterial = _React$useMemo2[5],\n    renderTargetBlur = _React$useMemo2[6];\n  var blurShadows = function blurShadows(blur) {\n    blurPlane.visible = true;\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTargetBlur);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTarget);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.visible = false;\n  };\n  var count = 0;\n  useFrame(function () {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      var initialBackground = scene.background;\n      scene.background = null;\n      var initialOverrideMaterial = scene.overrideMaterial;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      scene.overrideMaterial = initialOverrideMaterial;\n      blurShadows(blur);\n      if (smooth) blurShadows(blur * 0.4);\n      gl.setRenderTarget(null);\n      scene.background = initialBackground;\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    \"rotation-x\": Math.PI / 2\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: renderOrder,\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    map: renderTarget.texture,\n    \"map-encoding\": gl.outputEncoding,\n    transparent: true,\n    opacity: opacity,\n    depthWrite: depthWrite\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]\n  }));\n});\nexport { ContactShadows };","map":null,"metadata":{},"sourceType":"module"}