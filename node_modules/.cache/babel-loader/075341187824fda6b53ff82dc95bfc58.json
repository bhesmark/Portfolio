{"ast":null,"code":"import _toConsumableArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _assertThisInitialized from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty2 from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _createForOfIteratorHelper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { V, c as computeRubberband } from './maths-b28d9b98.esm.js';\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\nvar actionsWithoutCaptureSupported = ['enter', 'leave'];\nfunction hasCapture() {\n  var capture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var actionKey = arguments.length > 1 ? arguments[1] : undefined;\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var deviceProps = EVENT_TYPE_MAP[device];\n  var actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\nvar pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  var eventKey = prop.substring(2).toLowerCase();\n  var passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  var captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  var capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture: capture,\n    passive: passive\n  };\n}\nfunction toDomEventType(device) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var deviceProps = EVENT_TYPE_MAP[device];\n  var actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(function (e) {\n    var _event$currentTarget, _event$currentTarget$;\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P2) {\n  var dx = P2.clientX - P1.clientX;\n  var dy = P2.clientY - P1.clientY;\n  var cx = (P2.clientX + P1.clientX) / 2;\n  var cy = (P2.clientY + P1.clientY) / 2;\n  var distance = Math.hypot(dx, dy);\n  var angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var origin = [cx, cy];\n  return {\n    angle: angle,\n    distance: distance,\n    origin: origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(function (touch) {\n    return touch.identifier;\n  });\n}\nfunction touchDistanceAngle(event, ids) {\n  var _Array$from$filter = Array.from(event.touches).filter(function (touch) {\n      return ids.includes(touch.identifier);\n    }),\n    _Array$from$filter2 = _slicedToArray(_Array$from$filter, 2),\n    P1 = _Array$from$filter2[0],\n    P2 = _Array$from$filter2[1];\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  var valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  var valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  var deltaX = event.deltaX,\n    deltaY = event.deltaY,\n    deltaMode = event.deltaMode;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  var _event$currentTarget2 = event.currentTarget,\n    scrollX = _event$currentTarget2.scrollX,\n    scrollY = _event$currentTarget2.scrollY,\n    scrollLeft = _event$currentTarget2.scrollLeft,\n    scrollTop = _event$currentTarget2.scrollTop;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  var payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n  if ('shiftKey' in event) {\n    var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n    Object.assign(payload, {\n      shiftKey: shiftKey,\n      altKey: altKey,\n      metaKey: metaKey,\n      ctrlKey: ctrlKey\n    });\n  }\n  return payload;\n}\nfunction call(v) {\n  if (typeof v === 'function') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n    var _iterator = _createForOfIteratorHelper(fns),\n      _step2;\n    try {\n      for (_iterator.s(); !(_step2 = _iterator.n()).done;) {\n        var fn = _step2.value;\n        result = fn.apply(this, arguments) || result;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\nvar BEFORE_LAST_KINEMATICS_DELAY = 32;\nvar Engine = /*#__PURE__*/function () {\n  function Engine(ctrl, args, key) {\n    _classCallCheck(this, Engine);\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n  _createClass(Engine, [{\n    key: \"state\",\n    get: function get() {\n      return this.ctrl.state[this.key];\n    },\n    set: function set(state) {\n      this.ctrl.state[this.key] = state;\n    }\n  }, {\n    key: \"shared\",\n    get: function get() {\n      return this.ctrl.state.shared;\n    }\n  }, {\n    key: \"eventStore\",\n    get: function get() {\n      return this.ctrl.gestureEventStores[this.key];\n    }\n  }, {\n    key: \"timeoutStore\",\n    get: function get() {\n      return this.ctrl.gestureTimeoutStores[this.key];\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return this.ctrl.config[this.key];\n    }\n  }, {\n    key: \"sharedConfig\",\n    get: function get() {\n      return this.ctrl.config.shared;\n    }\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.ctrl.handlers[this.key];\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var state = this.state,\n        shared = this.shared,\n        ingKey = this.ingKey,\n        args = this.args;\n      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n      state._step = [false, false];\n      state.intentional = false;\n      state._movement = [0, 0];\n      state._distance = [0, 0];\n      state._direction = [0, 0];\n      state._delta = [0, 0];\n      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n      state.args = args;\n      state.axis = undefined;\n      state.memo = undefined;\n      state.elapsedTime = 0;\n      state.direction = [0, 0];\n      state.distance = [0, 0];\n      state.overflow = [0, 0];\n      state._movementBound = [false, false];\n      state.velocity = [0, 0];\n      state.movement = [0, 0];\n      state.delta = [0, 0];\n      state.timeStamp = 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start(event) {\n      var state = this.state;\n      var config = this.config;\n      if (!state._active) {\n        this.reset();\n        this.computeInitial();\n        state._active = true;\n        state.target = event.target;\n        state.currentTarget = event.currentTarget;\n        state.lastOffset = config.from ? call(config.from, state) : state.offset;\n        state.offset = state.lastOffset;\n      }\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }, {\n    key: \"computeValues\",\n    value: function computeValues(values) {\n      var state = this.state;\n      state._values = values;\n      state.values = this.config.transform(values);\n    }\n  }, {\n    key: \"computeInitial\",\n    value: function computeInitial() {\n      var state = this.state;\n      state._initial = state._values;\n      state.initial = state.values;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(event) {\n      var state = this.state,\n        config = this.config,\n        shared = this.shared;\n      state.args = this.args;\n      var dt = 0;\n      if (event) {\n        state.event = event;\n        if (config.preventDefault && event.cancelable) state.event.preventDefault();\n        state.type = event.type;\n        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n        shared.locked = !!document.pointerLockElement;\n        Object.assign(shared, getEventDetails(event));\n        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n        dt = event.timeStamp - state.timeStamp;\n        state.timeStamp = event.timeStamp;\n        state.elapsedTime = state.timeStamp - state.startTime;\n      }\n      if (state._active) {\n        var _absoluteDelta = state._delta.map(Math.abs);\n        V.addTo(state._distance, _absoluteDelta);\n      }\n      if (this.axisIntent) this.axisIntent(event);\n      var _state$_movement = _slicedToArray(state._movement, 2),\n        _m0 = _state$_movement[0],\n        _m1 = _state$_movement[1];\n      var _config$threshold = _slicedToArray(config.threshold, 2),\n        t0 = _config$threshold[0],\n        t1 = _config$threshold[1];\n      var _step = state._step,\n        values = state.values;\n      if (config.hasCustomTransform) {\n        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n      } else {\n        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n      }\n      state.intentional = _step[0] !== false || _step[1] !== false;\n      if (!state.intentional) return;\n      var movement = [0, 0];\n      if (config.hasCustomTransform) {\n        var _values2 = _slicedToArray(values, 2),\n          v0 = _values2[0],\n          v1 = _values2[1];\n        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n      } else {\n        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n      }\n      if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n      var previousOffset = state.offset;\n      var gestureIsActive = state._active && !state._blocked || state.active;\n      if (gestureIsActive) {\n        state.first = state._active && !state.active;\n        state.last = !state._active && state.active;\n        state.active = shared[this.ingKey] = state._active;\n        if (event) {\n          if (state.first) {\n            if ('bounds' in config) state._bounds = call(config.bounds, state);\n            if (this.setup) this.setup();\n          }\n          state.movement = movement;\n          this.computeOffset();\n        }\n      }\n      var _state$offset = _slicedToArray(state.offset, 2),\n        ox = _state$offset[0],\n        oy = _state$offset[1];\n      var _state$_bounds = _slicedToArray(state._bounds, 2),\n        _state$_bounds$ = _slicedToArray(_state$_bounds[0], 2),\n        x0 = _state$_bounds$[0],\n        x1 = _state$_bounds$[1],\n        _state$_bounds$2 = _slicedToArray(_state$_bounds[1], 2),\n        y0 = _state$_bounds$2[0],\n        y1 = _state$_bounds$2[1];\n      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n      var rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n      state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n      state.delta = V.sub(state.offset, previousOffset);\n      this.computeMovement();\n      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n        state.delta = V.sub(state.offset, previousOffset);\n        var absoluteDelta = state.delta.map(Math.abs);\n        V.addTo(state.distance, absoluteDelta);\n        state.direction = state.delta.map(Math.sign);\n        state._direction = state._delta.map(Math.sign);\n        if (!state.first && dt > 0) {\n          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        }\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit() {\n      var state = this.state;\n      var shared = this.shared;\n      var config = this.config;\n      if (!state._active) this.clean();\n      if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n      var memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, _defineProperty2({}, this.aliasKey, state.values)));\n      if (memo !== undefined) state.memo = memo;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.eventStore.clean();\n      this.timeoutStore.clean();\n    }\n  }]);\n  return Engine;\n}();\nfunction selectAxis(_ref3, threshold) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n    dx = _ref4[0],\n    dy = _ref4[1];\n  var absDx = Math.abs(dx);\n  var absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n  return undefined;\n}\nvar CoordinatesEngine = /*#__PURE__*/function (_Engine) {\n  _inherits(CoordinatesEngine, _Engine);\n  var _super = _createSuper(CoordinatesEngine);\n  function CoordinatesEngine() {\n    var _this;\n    _classCallCheck(this, CoordinatesEngine);\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"aliasKey\", 'xy');\n    return _this;\n  }\n  _createClass(CoordinatesEngine, [{\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(CoordinatesEngine.prototype), \"reset\", this).call(this);\n      this.state.axis = undefined;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.state.offset = [0, 0];\n      this.state.lastOffset = [0, 0];\n    }\n  }, {\n    key: \"computeOffset\",\n    value: function computeOffset() {\n      this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n    }\n  }, {\n    key: \"computeMovement\",\n    value: function computeMovement() {\n      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n    }\n  }, {\n    key: \"axisIntent\",\n    value: function axisIntent(event) {\n      var state = this.state;\n      var config = this.config;\n      if (!state.axis && event) {\n        var threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n        state.axis = selectAxis(state._movement, threshold);\n      }\n      state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n    }\n  }, {\n    key: \"restrictToAxis\",\n    value: function restrictToAxis(v) {\n      if (this.config.axis || this.config.lockDirection) {\n        switch (this.state.axis) {\n          case 'x':\n            v[1] = 0;\n            break;\n          case 'y':\n            v[0] = 0;\n            break;\n        }\n      }\n    }\n  }]);\n  return CoordinatesEngine;\n}(Engine);\nvar identity = function identity(v) {\n  return v;\n};\nvar DEFAULT_RUBBERBAND = 0.15;\nvar commonConfigResolver = {\n  enabled: function enabled() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  },\n  eventOptions: function eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault: function preventDefault() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return value;\n  },\n  rubberband: function rubberband() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return V.toVector(value);\n    }\n  },\n  from: function from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n  transform: function transform(value, _k, config) {\n    var transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (process.env.NODE_ENV === 'development') {\n      var originalTransform = transform || identity;\n      return function (v) {\n        var r = originalTransform(v);\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(\"[@use-gesture]: config.transform() must produce a valid result, but it was: [\".concat(r[0], \",\").concat([1], \"]\"));\n        }\n        return r;\n      };\n    }\n    return transform || identity;\n  },\n  threshold: function threshold(value) {\n    return V.toVector(value, 0);\n  }\n};\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget: function domTarget(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `domTarget` option has been renamed to `target`.\");\n      }\n      return NaN;\n    },\n    lockDirection: function lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`\");\n      }\n      return NaN;\n    },\n    initial: function initial(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `initial` option has been renamed to `from`.\");\n      }\n      return NaN;\n    }\n  });\n}\nvar DEFAULT_AXIS_THRESHOLD = 0;\nvar coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis: function axis(_v, _k, _ref5) {\n    var axis = _ref5.axis;\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold: function axisThreshold() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_AXIS_THRESHOLD;\n    return value;\n  },\n  bounds: function bounds() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof value === 'function') {\n      return function (state) {\n        return coordinatesConfigResolver.bounds(value(state));\n      };\n    }\n    if ('current' in value) {\n      return function () {\n        return value.current;\n      };\n    }\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n    var _value$left = value.left,\n      left = _value$left === void 0 ? -Infinity : _value$left,\n      _value$right = value.right,\n      right = _value$right === void 0 ? Infinity : _value$right,\n      _value$top = value.top,\n      top = _value$top === void 0 ? -Infinity : _value$top,\n      _value$bottom = value.bottom,\n      bottom = _value$bottom === void 0 ? Infinity : _value$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\nvar DISPLACEMENT = 10;\nvar KEYS_DELTA_MAP = {\n  ArrowRight: function ArrowRight() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [DISPLACEMENT * factor, 0];\n  },\n  ArrowLeft: function ArrowLeft() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [-DISPLACEMENT * factor, 0];\n  },\n  ArrowUp: function ArrowUp() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [0, -DISPLACEMENT * factor];\n  },\n  ArrowDown: function ArrowDown() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [0, DISPLACEMENT * factor];\n  }\n};\nvar DragEngine = /*#__PURE__*/function (_CoordinatesEngine) {\n  _inherits(DragEngine, _CoordinatesEngine);\n  var _super2 = _createSuper(DragEngine);\n  function DragEngine() {\n    var _this2;\n    _classCallCheck(this, DragEngine);\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this2), \"ingKey\", 'dragging');\n    return _this2;\n  }\n  _createClass(DragEngine, [{\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(DragEngine.prototype), \"reset\", this).call(this);\n      var state = this.state;\n      state._pointerId = undefined;\n      state._pointerActive = false;\n      state._keyboardActive = false;\n      state._preventScroll = false;\n      state._delayed = false;\n      state.swipe = [0, 0];\n      state.tap = false;\n      state.canceled = false;\n      state.cancel = this.cancel.bind(this);\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var state = this.state;\n      if (state._bounds instanceof HTMLElement) {\n        var boundRect = state._bounds.getBoundingClientRect();\n        var targetRect = state.currentTarget.getBoundingClientRect();\n        var _bounds = {\n          left: boundRect.left - targetRect.left + state.offset[0],\n          right: boundRect.right - targetRect.right + state.offset[0],\n          top: boundRect.top - targetRect.top + state.offset[1],\n          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n        };\n        state._bounds = coordinatesConfigResolver.bounds(_bounds);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this3 = this;\n      var state = this.state;\n      if (state.canceled) return;\n      state.canceled = true;\n      state._active = false;\n      setTimeout(function () {\n        _this3.compute();\n        _this3.emit();\n      }, 0);\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive() {\n      this.state._active = this.state._pointerActive || this.state._keyboardActive;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.pointerClean();\n      this.state._pointerActive = false;\n      this.state._keyboardActive = false;\n      _get(_getPrototypeOf(DragEngine.prototype), \"clean\", this).call(this);\n    }\n  }, {\n    key: \"pointerDown\",\n    value: function pointerDown(event) {\n      var config = this.config;\n      var state = this.state;\n      if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n      var ctrlIds = this.ctrl.setEventIds(event);\n      if (config.pointerCapture) {\n        event.target.setPointerCapture(event.pointerId);\n      }\n      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n      this.start(event);\n      this.setupPointer(event);\n      state._pointerId = pointerId(event);\n      state._pointerActive = true;\n      this.computeValues(pointerValues(event));\n      this.computeInitial();\n      if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n        state._active = false;\n        this.setupScrollPrevention(event);\n      } else if (config.delay > 0) {\n        this.setupDelayTrigger(event);\n        if (config.triggerAllEvents) {\n          this.compute(event);\n          this.emit();\n        }\n      } else {\n        this.startPointerDrag(event);\n      }\n    }\n  }, {\n    key: \"startPointerDrag\",\n    value: function startPointerDrag(event) {\n      var state = this.state;\n      state._active = true;\n      state._preventScroll = true;\n      state._delayed = false;\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"pointerMove\",\n    value: function pointerMove(event) {\n      var state = this.state;\n      var config = this.config;\n      if (!state._pointerActive) return;\n      if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n      var id = pointerId(event);\n      if (state._pointerId !== undefined && id !== state._pointerId) return;\n      var _values = pointerValues(event);\n      if (document.pointerLockElement === event.target) {\n        state._delta = [event.movementX, event.movementY];\n      } else {\n        state._delta = V.sub(_values, state._values);\n        this.computeValues(_values);\n      }\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      if (state._delayed && state.intentional) {\n        this.timeoutStore.remove('dragDelay');\n        state.active = false;\n        this.startPointerDrag(event);\n        return;\n      }\n      if (config.preventScrollAxis && !state._preventScroll) {\n        if (state.axis) {\n          if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n            state._active = false;\n            this.clean();\n            return;\n          } else {\n            this.timeoutStore.remove('startPointerDrag');\n            this.startPointerDrag(event);\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n      this.emit();\n    }\n  }, {\n    key: \"pointerUp\",\n    value: function pointerUp(event) {\n      this.ctrl.setEventIds(event);\n      try {\n        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n          ;\n          event.target.releasePointerCapture(event.pointerId);\n        }\n      } catch (_unused) {\n        if (process.env.NODE_ENV === 'development') {\n          console.warn(\"[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \\n\\nPlease upgrade to the latest version.\");\n        }\n      }\n      var state = this.state;\n      var config = this.config;\n      if (!state._active || !state._pointerActive) return;\n      var id = pointerId(event);\n      if (state._pointerId !== undefined && id !== state._pointerId) return;\n      this.state._pointerActive = false;\n      this.setActive();\n      this.compute(event);\n      var _state$_distance = _slicedToArray(state._distance, 2),\n        dx = _state$_distance[0],\n        dy = _state$_distance[1];\n      state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n      if (state.tap && config.filterTaps) {\n        state._force = true;\n      } else {\n        var _state$direction = _slicedToArray(state.direction, 2),\n          dirx = _state$direction[0],\n          diry = _state$direction[1];\n        var _state$velocity = _slicedToArray(state.velocity, 2),\n          vx = _state$velocity[0],\n          vy = _state$velocity[1];\n        var _state$movement = _slicedToArray(state.movement, 2),\n          mx = _state$movement[0],\n          my = _state$movement[1];\n        var _config$swipe$velocit = _slicedToArray(config.swipe.velocity, 2),\n          svx = _config$swipe$velocit[0],\n          svy = _config$swipe$velocit[1];\n        var _config$swipe$distanc = _slicedToArray(config.swipe.distance, 2),\n          sx = _config$swipe$distanc[0],\n          sy = _config$swipe$distanc[1];\n        var sdt = config.swipe.duration;\n        if (state.elapsedTime < sdt) {\n          if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n          if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n        }\n      }\n      this.emit();\n    }\n  }, {\n    key: \"pointerClick\",\n    value: function pointerClick(event) {\n      if (!this.state.tap && event.detail > 0) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"setupPointer\",\n    value: function setupPointer(event) {\n      var config = this.config;\n      var device = config.device;\n      if (process.env.NODE_ENV === 'development') {\n        try {\n          if (device === 'pointer' && config.preventScrollDelay === undefined) {\n            var currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n            var style = window.getComputedStyle(currentTarget);\n            if (style.touchAction === 'auto') {\n              console.warn(\"[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.\", currentTarget);\n            }\n          }\n        } catch (_unused2) {}\n      }\n      if (config.pointerLock) {\n        event.currentTarget.requestPointerLock();\n      }\n      if (!config.pointerCapture) {\n        this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n        this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n        this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n      }\n    }\n  }, {\n    key: \"pointerClean\",\n    value: function pointerClean() {\n      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n        document.exitPointerLock();\n      }\n    }\n  }, {\n    key: \"preventScroll\",\n    value: function preventScroll(event) {\n      if (this.state._preventScroll && event.cancelable) {\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"setupScrollPrevention\",\n    value: function setupScrollPrevention(event) {\n      this.state._preventScroll = false;\n      persistEvent(event);\n      var remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n        passive: false\n      });\n      this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n      this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n      this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n    }\n  }, {\n    key: \"setupDelayTrigger\",\n    value: function setupDelayTrigger(event) {\n      var _this4 = this;\n      this.state._delayed = true;\n      this.timeoutStore.add('dragDelay', function () {\n        _this4.state._step = [0, 0];\n        _this4.startPointerDrag(event);\n      }, this.config.delay);\n    }\n  }, {\n    key: \"keyDown\",\n    value: function keyDown(event) {\n      var deltaFn = KEYS_DELTA_MAP[event.key];\n      if (deltaFn) {\n        var state = this.state;\n        var factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n        this.start(event);\n        state._delta = deltaFn(factor);\n        state._keyboardActive = true;\n        V.addTo(state._movement, state._delta);\n        this.compute(event);\n        this.emit();\n      }\n    }\n  }, {\n    key: \"keyUp\",\n    value: function keyUp(event) {\n      if (!(event.key in KEYS_DELTA_MAP)) return;\n      this.state._keyboardActive = false;\n      this.setActive();\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      var device = this.config.device;\n      bindFunction(device, 'start', this.pointerDown.bind(this));\n      if (this.config.pointerCapture) {\n        bindFunction(device, 'change', this.pointerMove.bind(this));\n        bindFunction(device, 'end', this.pointerUp.bind(this));\n        bindFunction(device, 'cancel', this.pointerUp.bind(this));\n        bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n      }\n      if (this.config.keys) {\n        bindFunction('key', 'down', this.keyDown.bind(this));\n        bindFunction('key', 'up', this.keyUp.bind(this));\n      }\n      if (this.config.filterTaps) {\n        bindFunction('click', '', this.pointerClick.bind(this), {\n          capture: true,\n          passive: false\n        });\n      }\n    }\n  }]);\n  return DragEngine;\n}(CoordinatesEngine);\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nvar SUPPORT = {\n  isBrowser: isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\nvar DEFAULT_PREVENT_SCROLL_DELAY = 250;\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 50;\nvar DEFAULT_SWIPE_DURATION = 250;\nvar DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nvar dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device: function device(_v, _k, _ref6) {\n    var _ref6$pointer = _ref6.pointer;\n    _ref6$pointer = _ref6$pointer === void 0 ? {} : _ref6$pointer;\n    var _ref6$pointer$touch = _ref6$pointer.touch,\n      touch = _ref6$pointer$touch === void 0 ? false : _ref6$pointer$touch,\n      _ref6$pointer$lock = _ref6$pointer.lock,\n      lock = _ref6$pointer$lock === void 0 ? false : _ref6$pointer$lock,\n      _ref6$pointer$mouse = _ref6$pointer.mouse,\n      mouse = _ref6$pointer$mouse === void 0 ? false : _ref6$pointer$mouse;\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis: function preventScrollAxis(value, _k, _ref7) {\n    var preventScroll = _ref7.preventScroll;\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture: function pointerCapture(_v, _k, _ref8) {\n    var _ref8$pointer = _ref8.pointer;\n    _ref8$pointer = _ref8$pointer === void 0 ? {} : _ref8$pointer;\n    var _ref8$pointer$capture = _ref8$pointer.capture,\n      capture = _ref8$pointer$capture === void 0 ? true : _ref8$pointer$capture,\n      _ref8$pointer$buttons = _ref8$pointer.buttons,\n      buttons = _ref8$pointer$buttons === void 0 ? 1 : _ref8$pointer$buttons,\n      _ref8$pointer$keys = _ref8$pointer.keys,\n      keys = _ref8$pointer$keys === void 0 ? true : _ref8$pointer$keys;\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  threshold: function threshold(value, _k, _ref9) {\n    var _ref9$filterTaps = _ref9.filterTaps,\n      filterTaps = _ref9$filterTaps === void 0 ? false : _ref9$filterTaps,\n      _ref9$tapsThreshold = _ref9.tapsThreshold,\n      tapsThreshold = _ref9$tapsThreshold === void 0 ? 3 : _ref9$tapsThreshold,\n      _ref9$axis = _ref9.axis,\n      axis = _ref9$axis === void 0 ? undefined : _ref9$axis;\n    var threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe: function swipe() {\n    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref10$velocity = _ref10.velocity,\n      velocity = _ref10$velocity === void 0 ? DEFAULT_SWIPE_VELOCITY : _ref10$velocity,\n      _ref10$distance = _ref10.distance,\n      distance = _ref10$distance === void 0 ? DEFAULT_SWIPE_DISTANCE : _ref10$distance,\n      _ref10$duration = _ref10.duration,\n      duration = _ref10$duration === void 0 ? DEFAULT_SWIPE_DURATION : _ref10$duration;\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration: duration\n    };\n  },\n  delay: function delay() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold: function axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n});\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch: function useTouch(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.\");\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.\");\n      }\n      return NaN;\n    },\n    swipeVelocity: function swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.\");\n      }\n      return NaN;\n    },\n    swipeDistance: function swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.\");\n      }\n      return NaN;\n    },\n    swipeDuration: function swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.\");\n      }\n      return NaN;\n    }\n  });\n}\nfunction clampStateInternalMovementToBounds(state) {\n  var _state$overflow = _slicedToArray(state.overflow, 2),\n    ox = _state$overflow[0],\n    oy = _state$overflow[1];\n  var _state$_delta = _slicedToArray(state._delta, 2),\n    dx = _state$_delta[0],\n    dy = _state$_delta[1];\n  var _state$_direction = _slicedToArray(state._direction, 2),\n    dirx = _state$_direction[0],\n    diry = _state$_direction[1];\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\nvar SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nvar PINCH_WHEEL_RATIO = 100;\nvar PinchEngine = /*#__PURE__*/function (_Engine2) {\n  _inherits(PinchEngine, _Engine2);\n  var _super3 = _createSuper(PinchEngine);\n  function PinchEngine() {\n    var _this5;\n    _classCallCheck(this, PinchEngine);\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    _this5 = _super3.call.apply(_super3, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this5), \"ingKey\", 'pinching');\n    _defineProperty(_assertThisInitialized(_this5), \"aliasKey\", 'da');\n    return _this5;\n  }\n  _createClass(PinchEngine, [{\n    key: \"init\",\n    value: function init() {\n      this.state.offset = [1, 0];\n      this.state.lastOffset = [1, 0];\n      this.state._pointerEvents = new Map();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(PinchEngine.prototype), \"reset\", this).call(this);\n      var state = this.state;\n      state._touchIds = [];\n      state.canceled = false;\n      state.cancel = this.cancel.bind(this);\n      state.turns = 0;\n    }\n  }, {\n    key: \"computeOffset\",\n    value: function computeOffset() {\n      var _this$state = this.state,\n        type = _this$state.type,\n        movement = _this$state.movement,\n        lastOffset = _this$state.lastOffset;\n      if (type === 'wheel') {\n        this.state.offset = V.add(movement, lastOffset);\n      } else {\n        this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n      }\n    }\n  }, {\n    key: \"computeMovement\",\n    value: function computeMovement() {\n      var _this$state2 = this.state,\n        offset = _this$state2.offset,\n        lastOffset = _this$state2.lastOffset;\n      this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n    }\n  }, {\n    key: \"axisIntent\",\n    value: function axisIntent() {\n      var state = this.state;\n      var _state$_movement2 = _slicedToArray(state._movement, 2),\n        _m0 = _state$_movement2[0],\n        _m1 = _state$_movement2[1];\n      if (!state.axis) {\n        var axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n        if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n      }\n    }\n  }, {\n    key: \"restrictToAxis\",\n    value: function restrictToAxis(v) {\n      if (this.config.lockDirection) {\n        if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this6 = this;\n      var state = this.state;\n      if (state.canceled) return;\n      setTimeout(function () {\n        state.canceled = true;\n        state._active = false;\n        _this6.compute();\n        _this6.emit();\n      }, 0);\n    }\n  }, {\n    key: \"touchStart\",\n    value: function touchStart(event) {\n      this.ctrl.setEventIds(event);\n      var state = this.state;\n      var ctrlTouchIds = this.ctrl.touchIds;\n      if (state._active) {\n        if (state._touchIds.every(function (id) {\n          return ctrlTouchIds.has(id);\n        })) return;\n      }\n      if (ctrlTouchIds.size < 2) return;\n      this.start(event);\n      state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n      var payload = touchDistanceAngle(event, state._touchIds);\n      this.pinchStart(event, payload);\n    }\n  }, {\n    key: \"pointerStart\",\n    value: function pointerStart(event) {\n      if (event.buttons != null && event.buttons % 2 !== 1) return;\n      this.ctrl.setEventIds(event);\n      event.target.setPointerCapture(event.pointerId);\n      var state = this.state;\n      var _pointerEvents = state._pointerEvents;\n      var ctrlPointerIds = this.ctrl.pointerIds;\n      if (state._active) {\n        if (Array.from(_pointerEvents.keys()).every(function (id) {\n          return ctrlPointerIds.has(id);\n        })) return;\n      }\n      if (_pointerEvents.size < 2) {\n        _pointerEvents.set(event.pointerId, event);\n      }\n      if (state._pointerEvents.size < 2) return;\n      this.start(event);\n      var payload = distanceAngle.apply(void 0, _toConsumableArray(Array.from(_pointerEvents.values())));\n      this.pinchStart(event, payload);\n    }\n  }, {\n    key: \"pinchStart\",\n    value: function pinchStart(event, payload) {\n      var state = this.state;\n      state.origin = payload.origin;\n      this.computeValues([payload.distance, payload.angle]);\n      this.computeInitial();\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"touchMove\",\n    value: function touchMove(event) {\n      if (!this.state._active) return;\n      var payload = touchDistanceAngle(event, this.state._touchIds);\n      this.pinchMove(event, payload);\n    }\n  }, {\n    key: \"pointerMove\",\n    value: function pointerMove(event) {\n      var _pointerEvents = this.state._pointerEvents;\n      if (_pointerEvents.has(event.pointerId)) {\n        _pointerEvents.set(event.pointerId, event);\n      }\n      if (!this.state._active) return;\n      var payload = distanceAngle.apply(void 0, _toConsumableArray(Array.from(_pointerEvents.values())));\n      this.pinchMove(event, payload);\n    }\n  }, {\n    key: \"pinchMove\",\n    value: function pinchMove(event, payload) {\n      var state = this.state;\n      var prev_a = state._values[1];\n      var delta_a = payload.angle - prev_a;\n      var delta_turns = 0;\n      if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n      this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n      state.origin = payload.origin;\n      state.turns = delta_turns;\n      state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"touchEnd\",\n    value: function touchEnd(event) {\n      var _this7 = this;\n      this.ctrl.setEventIds(event);\n      if (!this.state._active) return;\n      if (this.state._touchIds.some(function (id) {\n        return !_this7.ctrl.touchIds.has(id);\n      })) {\n        this.state._active = false;\n        this.compute(event);\n        this.emit();\n      }\n    }\n  }, {\n    key: \"pointerEnd\",\n    value: function pointerEnd(event) {\n      var state = this.state;\n      this.ctrl.setEventIds(event);\n      try {\n        event.target.releasePointerCapture(event.pointerId);\n      } catch (_unused) {}\n      if (state._pointerEvents.has(event.pointerId)) {\n        state._pointerEvents[\"delete\"](event.pointerId);\n      }\n      if (!state._active) return;\n      if (state._pointerEvents.size < 2) {\n        state._active = false;\n        this.compute(event);\n        this.emit();\n      }\n    }\n  }, {\n    key: \"gestureStart\",\n    value: function gestureStart(event) {\n      if (event.cancelable) event.preventDefault();\n      var state = this.state;\n      if (state._active) return;\n      this.start(event);\n      this.computeValues([event.scale, event.rotation]);\n      state.origin = [event.clientX, event.clientY];\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"gestureMove\",\n    value: function gestureMove(event) {\n      if (event.cancelable) event.preventDefault();\n      if (!this.state._active) return;\n      var state = this.state;\n      this.computeValues([event.scale, event.rotation]);\n      state.origin = [event.clientX, event.clientY];\n      var _previousMovement = state._movement;\n      state._movement = [event.scale - 1, event.rotation];\n      state._delta = V.sub(state._movement, _previousMovement);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"gestureEnd\",\n    value: function gestureEnd(event) {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"wheel\",\n    value: function wheel(event) {\n      var modifierKey = this.config.modifierKey;\n      if (modifierKey && !event[modifierKey]) return;\n      if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n      this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n    }\n  }, {\n    key: \"wheelStart\",\n    value: function wheelStart(event) {\n      this.start(event);\n      this.wheelChange(event);\n    }\n  }, {\n    key: \"wheelChange\",\n    value: function wheelChange(event) {\n      var isR3f = ('uv' in event);\n      if (!isR3f) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n        if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n          console.warn(\"[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\\n\\nThis message will only appear in development mode.\");\n        }\n      }\n      var state = this.state;\n      state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n      V.addTo(state._movement, state._delta);\n      clampStateInternalMovementToBounds(state);\n      this.state.origin = [event.clientX, event.clientY];\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"wheelEnd\",\n    value: function wheelEnd() {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute();\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      var device = this.config.device;\n      if (!!device) {\n        bindFunction(device, 'start', this[device + 'Start'].bind(this));\n        bindFunction(device, 'change', this[device + 'Move'].bind(this));\n        bindFunction(device, 'end', this[device + 'End'].bind(this));\n        bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n      }\n      if (this.config.pinchOnWheel) {\n        bindFunction('wheel', '', this.wheel.bind(this), {\n          passive: false\n        });\n      }\n    }\n  }]);\n  return PinchEngine;\n}(Engine);\nvar pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device: function device(_v, _k, _ref11) {\n    var shared = _ref11.shared,\n      _ref11$pointer = _ref11.pointer;\n    _ref11$pointer = _ref11$pointer === void 0 ? {} : _ref11$pointer;\n    var _ref11$pointer$touch = _ref11$pointer.touch,\n      touch = _ref11$pointer$touch === void 0 ? false : _ref11$pointer$touch;\n    var sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds: function bounds(_v, _k, _ref12) {\n    var _ref12$scaleBounds = _ref12.scaleBounds,\n      scaleBounds = _ref12$scaleBounds === void 0 ? {} : _ref12$scaleBounds,\n      _ref12$angleBounds = _ref12.angleBounds,\n      angleBounds = _ref12$angleBounds === void 0 ? {} : _ref12$angleBounds;\n    var _scaleBounds = function _scaleBounds(state) {\n      var D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return function (state) {\n      return [_scaleBounds(state), _angleBounds(state)];\n    };\n  },\n  threshold: function threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    var threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey: function modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  },\n  pinchOnWheel: function pinchOnWheel() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  }\n});\nvar MoveEngine = /*#__PURE__*/function (_CoordinatesEngine2) {\n  _inherits(MoveEngine, _CoordinatesEngine2);\n  var _super4 = _createSuper(MoveEngine);\n  function MoveEngine() {\n    var _this8;\n    _classCallCheck(this, MoveEngine);\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    _this8 = _super4.call.apply(_super4, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this8), \"ingKey\", 'moving');\n    return _this8;\n  }\n  _createClass(MoveEngine, [{\n    key: \"move\",\n    value: function move(event) {\n      if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n      if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n      this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n    }\n  }, {\n    key: \"moveStart\",\n    value: function moveStart(event) {\n      this.start(event);\n      this.computeValues(pointerValues(event));\n      this.compute(event);\n      this.computeInitial();\n      this.emit();\n    }\n  }, {\n    key: \"moveChange\",\n    value: function moveChange(event) {\n      if (!this.state._active) return;\n      var values = pointerValues(event);\n      var state = this.state;\n      state._delta = V.sub(values, state._values);\n      V.addTo(state._movement, state._delta);\n      this.computeValues(values);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"moveEnd\",\n    value: function moveEnd(event) {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('pointer', 'change', this.move.bind(this));\n      bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n    }\n  }]);\n  return MoveEngine;\n}(CoordinatesEngine);\nvar moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: function mouseOnly() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  }\n});\nvar ScrollEngine = /*#__PURE__*/function (_CoordinatesEngine3) {\n  _inherits(ScrollEngine, _CoordinatesEngine3);\n  var _super5 = _createSuper(ScrollEngine);\n  function ScrollEngine() {\n    var _this9;\n    _classCallCheck(this, ScrollEngine);\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    _this9 = _super5.call.apply(_super5, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this9), \"ingKey\", 'scrolling');\n    return _this9;\n  }\n  _createClass(ScrollEngine, [{\n    key: \"scroll\",\n    value: function scroll(event) {\n      if (!this.state._active) this.start(event);\n      this.scrollChange(event);\n      this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n    }\n  }, {\n    key: \"scrollChange\",\n    value: function scrollChange(event) {\n      if (event.cancelable) event.preventDefault();\n      var state = this.state;\n      var values = scrollValues(event);\n      state._delta = V.sub(values, state._values);\n      V.addTo(state._movement, state._delta);\n      this.computeValues(values);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"scrollEnd\",\n    value: function scrollEnd() {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute();\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('scroll', '', this.scroll.bind(this));\n    }\n  }]);\n  return ScrollEngine;\n}(CoordinatesEngine);\nvar scrollConfigResolver = coordinatesConfigResolver;\nvar WheelEngine = /*#__PURE__*/function (_CoordinatesEngine4) {\n  _inherits(WheelEngine, _CoordinatesEngine4);\n  var _super6 = _createSuper(WheelEngine);\n  function WheelEngine() {\n    var _this10;\n    _classCallCheck(this, WheelEngine);\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    _this10 = _super6.call.apply(_super6, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this10), \"ingKey\", 'wheeling');\n    return _this10;\n  }\n  _createClass(WheelEngine, [{\n    key: \"wheel\",\n    value: function wheel(event) {\n      if (!this.state._active) this.start(event);\n      this.wheelChange(event);\n      this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n    }\n  }, {\n    key: \"wheelChange\",\n    value: function wheelChange(event) {\n      var state = this.state;\n      state._delta = wheelValues(event);\n      V.addTo(state._movement, state._delta);\n      clampStateInternalMovementToBounds(state);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"wheelEnd\",\n    value: function wheelEnd() {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute();\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('wheel', '', this.wheel.bind(this));\n    }\n  }]);\n  return WheelEngine;\n}(CoordinatesEngine);\nvar wheelConfigResolver = coordinatesConfigResolver;\nvar HoverEngine = /*#__PURE__*/function (_CoordinatesEngine5) {\n  _inherits(HoverEngine, _CoordinatesEngine5);\n  var _super7 = _createSuper(HoverEngine);\n  function HoverEngine() {\n    var _this11;\n    _classCallCheck(this, HoverEngine);\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    _this11 = _super7.call.apply(_super7, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this11), \"ingKey\", 'hovering');\n    return _this11;\n  }\n  _createClass(HoverEngine, [{\n    key: \"enter\",\n    value: function enter(event) {\n      if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n      this.start(event);\n      this.computeValues(pointerValues(event));\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(event) {\n      if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n      var state = this.state;\n      if (!state._active) return;\n      state._active = false;\n      var values = pointerValues(event);\n      state._movement = state._delta = V.sub(values, state._values);\n      this.computeValues(values);\n      this.compute(event);\n      state.delta = state.movement;\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('pointer', 'enter', this.enter.bind(this));\n      bindFunction('pointer', 'leave', this.leave.bind(this));\n    }\n  }]);\n  return HoverEngine;\n}(CoordinatesEngine);\nvar hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: function mouseOnly() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  }\n});\nvar EngineMap = new Map();\nvar ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nvar dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nvar hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nvar moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nvar pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nvar scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nvar wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };","map":null,"metadata":{},"sourceType":"module"}