{"ast":null,"code":"import _toConsumableArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { applyProps } from '@react-three/fiber';\n\n// and @0beqz https://gist.github.com/0beqz/8d51b4ae16d68021a09fb504af708fca\n\nvar worldposReplace = /* glsl */\"\\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n  #ifdef BOX_PROJECTED_ENV_MAP\\n    vWorldPosition = worldPosition.xyz;\\n  #endif\\n#endif\\n\";\nvar boxProjectDefinitions = /*glsl */\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  uniform vec3 envMapSize;\\n  uniform vec3 envMapPosition;\\n  varying vec3 vWorldPosition;\\n    \\n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\\n    vec3 nDir = normalize( v );\\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbminmax;\\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \\n    return boxIntersection - cubePos;\\n  }\\n#endif\\n\"; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nvar getIBLIrradiance_patch = /* glsl */\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\\n#endif\\n\"; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nvar getIBLRadiance_patch = /* glsl */\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\\n#endif\\n\";\nfunction boxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  shader.defines.BOX_PROJECTED_ENV_MAP = true; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  }; // vertex shader\n\n  shader.vertexShader = \"\\n  varying vec3 vWorldPosition;\\n  \".concat(shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace)); // fragment shader\n\n  shader.fragmentShader = \"\\n    \".concat(boxProjectDefinitions, \"\\n    \").concat(shader.fragmentShader.replace('#include <envmap_physical_pars_fragment>', THREE.ShaderChunk.envmap_physical_pars_fragment).replace('vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n         \".concat(getIBLIrradiance_patch, \"\\n         \")).replace('reflectVec = inverseTransformDirection( reflectVec, viewMatrix );', \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n         \".concat(getIBLRadiance_patch, \"\\n        \")));\n}\nfunction useBoxProjectedEnv() {\n  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector3();\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n  var _React$useState = React.useState(function () {\n      return {\n        position: new THREE.Vector3(),\n        size: new THREE.Vector3()\n      };\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    config = _React$useState2[0];\n  applyProps(config, {\n    position: position,\n    size: size\n  });\n  var ref = React.useRef(null);\n  var spread = React.useMemo(function () {\n    return {\n      ref: ref,\n      onBeforeCompile: function onBeforeCompile(shader) {\n        return boxProjectedEnvMap(shader, config.position, config.size);\n      },\n      customProgramCacheKey: function customProgramCacheKey() {\n        return JSON.stringify(config.position.toArray()) + JSON.stringify(config.size.toArray());\n      }\n    };\n  }, [].concat(_toConsumableArray(config.position.toArray()), _toConsumableArray(config.size.toArray())));\n  React.useLayoutEffect(function () {\n    return void (ref.current.needsUpdate = true);\n  }, [config]);\n  return spread;\n}\nexport { useBoxProjectedEnv };","map":null,"metadata":{},"sourceType":"module"}