{"ast":null,"code":"import _construct from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _toConsumableArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"limit\", \"lineWidth\", \"children\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport mergeRefs from 'react-merge-refs';\nimport { extend, useFrame } from '@react-three/fiber';\nimport { Line2, LineMaterial, LineSegmentsGeometry } from 'three-stdlib';\nvar context = /*#__PURE__*/React.createContext(null);\nvar Segments = /*#__PURE__*/React.forwardRef(function (props, forwardedRef) {\n  React.useMemo(function () {\n    return extend({\n      SegmentObject: SegmentObject\n    });\n  }, []);\n  var _props$limit = props.limit,\n    limit = _props$limit === void 0 ? 1000 : _props$limit,\n    _props$lineWidth = props.lineWidth,\n    lineWidth = _props$lineWidth === void 0 ? 1.0 : _props$lineWidth,\n    children = props.children,\n    rest = _objectWithoutProperties(props, _excluded);\n  var _React$useState = React.useState([]),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    segments = _React$useState2[0],\n    setSegments = _React$useState2[1];\n  var _React$useState3 = React.useState(function () {\n      return new Line2();\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 1),\n    line = _React$useState4[0];\n  var _React$useState5 = React.useState(function () {\n      return new LineMaterial();\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 1),\n    material = _React$useState6[0];\n  var _React$useState7 = React.useState(function () {\n      return new LineSegmentsGeometry();\n    }),\n    _React$useState8 = _slicedToArray(_React$useState7, 1),\n    geometry = _React$useState8[0];\n  var _React$useState9 = React.useState(function () {\n      return new THREE.Vector2(512, 512);\n    }),\n    _React$useState10 = _slicedToArray(_React$useState9, 1),\n    resolution = _React$useState10[0];\n  var _React$useState11 = React.useState(function () {\n      return Array(limit * 6).fill(0);\n    }),\n    _React$useState12 = _slicedToArray(_React$useState11, 1),\n    positions = _React$useState12[0];\n  var _React$useState13 = React.useState(function () {\n      return Array(limit * 6).fill(0);\n    }),\n    _React$useState14 = _slicedToArray(_React$useState13, 1),\n    colors = _React$useState14[0];\n  var api = React.useMemo(function () {\n    return {\n      subscribe: function subscribe(ref) {\n        setSegments(function (segments) {\n          return [].concat(_toConsumableArray(segments), [ref]);\n        });\n        return function () {\n          return setSegments(function (segments) {\n            return segments.filter(function (item) {\n              return item.current !== ref.current;\n            });\n          });\n        };\n      }\n    };\n  }, []);\n  useFrame(function () {\n    for (var i = 0; i < limit; i++) {\n      var _segments$i;\n      var segment = (_segments$i = segments[i]) == null ? void 0 : _segments$i.current;\n      if (segment) {\n        positions[i * 6 + 0] = segment.start.x;\n        positions[i * 6 + 1] = segment.start.y;\n        positions[i * 6 + 2] = segment.start.z;\n        positions[i * 6 + 3] = segment.end.x;\n        positions[i * 6 + 4] = segment.end.y;\n        positions[i * 6 + 5] = segment.end.z;\n        colors[i * 6 + 0] = segment.color.r;\n        colors[i * 6 + 1] = segment.color.g;\n        colors[i * 6 + 2] = segment.color.b;\n        colors[i * 6 + 3] = segment.color.r;\n        colors[i * 6 + 4] = segment.color.g;\n        colors[i * 6 + 5] = segment.color.b;\n      }\n    }\n    geometry.setColors(colors);\n    geometry.setPositions(positions);\n    line.computeLineDistances();\n  });\n  return /*#__PURE__*/React.createElement(\"primitive\", {\n    object: line,\n    ref: forwardedRef\n  }, /*#__PURE__*/React.createElement(\"primitive\", {\n    object: geometry,\n    attach: \"geometry\"\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: material,\n    attach: \"material\",\n    vertexColors: true,\n    resolution: resolution,\n    linewidth: lineWidth\n  }, rest)), /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children));\n});\nvar SegmentObject = /*#__PURE__*/_createClass(function SegmentObject() {\n  _classCallCheck(this, SegmentObject);\n  this.color = new THREE.Color('white');\n  this.start = new THREE.Vector3(0, 0, 0);\n  this.end = new THREE.Vector3(0, 0, 0);\n});\nvar normPos = function normPos(pos) {\n  return pos instanceof THREE.Vector3 ? pos : _construct(THREE.Vector3, _toConsumableArray(typeof pos === 'number' ? [pos, pos, pos] : pos));\n};\nvar Segment = /*#__PURE__*/React.forwardRef(function (_ref, forwardedRef) {\n  var color = _ref.color,\n    start = _ref.start,\n    end = _ref.end;\n  var api = React.useContext(context);\n  if (!api) throw 'Segment must used inside Segments component.';\n  var ref = React.useRef(null);\n  React.useLayoutEffect(function () {\n    return api.subscribe(ref);\n  }, []);\n  return /*#__PURE__*/React.createElement(\"segmentObject\", {\n    ref: mergeRefs([ref, forwardedRef]),\n    color: color,\n    start: normPos(start),\n    end: normPos(end)\n  });\n});\nexport { Segment, SegmentObject, Segments };","map":null,"metadata":{},"sourceType":"module"}