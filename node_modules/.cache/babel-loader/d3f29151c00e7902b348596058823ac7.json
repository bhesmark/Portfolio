{"ast":null,"code":"import _get from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport * as r from \"three\";\nfunction c(a, t, e, i, s) {\n  var n;\n  if (a = a.subarray || a.slice ? a : a.buffer, e = e.subarray || e.slice ? e : e.buffer, a = t ? a.subarray ? a.subarray(t, s && t + s) : a.slice(t, s && t + s) : a, e.set) e.set(a, i);else for (n = 0; n < a.length; n++) {\n    e[n + i] = a[n];\n  }\n  return e;\n}\nvar S = /*#__PURE__*/function (_r$BufferGeometry) {\n  _inherits(S, _r$BufferGeometry);\n  var _super = _createSuper(S);\n  function S() {\n    var _this;\n    _classCallCheck(this, S);\n    _this = _super.call(this), _this.type = \"MeshLine\", _this.isMeshLine = !0, _this.positions = [], _this.previous = [], _this.next = [], _this.side = [], _this.width = [], _this.indices_array = [], _this.uvs = [], _this.counters = [], _this._points = [], _this._geom = null, _this.widthCallback = null, _this.matrixWorld = new r.Matrix4(), Object.defineProperties(_assertThisInitialized(_this), {\n      geometry: {\n        enumerable: !0,\n        get: function get() {\n          return this._geom;\n        },\n        set: function set(t) {\n          this.setGeometry(t, this.widthCallback);\n        }\n      },\n      points: {\n        enumerable: !0,\n        get: function get() {\n          return this._points;\n        },\n        set: function set(t) {\n          this.setPoints(t, this.widthCallback);\n        }\n      }\n    });\n    return _this;\n  }\n  _createClass(S, [{\n    key: \"setMatrixWorld\",\n    value: function setMatrixWorld(t) {\n      this.matrixWorld = t;\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(t, e) {\n      t instanceof r.BufferGeometry && (this._geometry = t, this.setPoints(t.getAttribute(\"position\").array, e));\n    }\n  }, {\n    key: \"setPoints\",\n    value: function setPoints(t, e) {\n      if (!(t instanceof Float32Array) && !(t instanceof Array)) {\n        console.error(\"ERROR: The BufferArray of points is not instancied correctly.\");\n        return;\n      }\n      if (this._points = t, this.widthCallback = e, this.positions = [], this.counters = [], t.length && t[0] instanceof r.Vector3) for (var i = 0; i < t.length; i++) {\n        var s = t[i],\n          n = i / (t.length - 1);\n        this.positions.push(s.x, s.y, s.z), this.positions.push(s.x, s.y, s.z), this.counters.push(n), this.counters.push(n);\n      } else for (var _i = 0; _i < t.length; _i += 3) {\n        var _s = _i / (t.length - 1);\n        this.positions.push(t[_i], t[_i + 1], t[_i + 2]), this.positions.push(t[_i], t[_i + 1], t[_i + 2]), this.counters.push(_s), this.counters.push(_s);\n      }\n      this.process();\n    }\n  }, {\n    key: \"compareV3\",\n    value: function compareV3(t, e) {\n      var i = t * 6,\n        s = e * 6;\n      return this.positions[i] === this.positions[s] && this.positions[i + 1] === this.positions[s + 1] && this.positions[i + 2] === this.positions[s + 2];\n    }\n  }, {\n    key: \"copyV3\",\n    value: function copyV3(t) {\n      var e = t * 6;\n      return [this.positions[e], this.positions[e + 1], this.positions[e + 2]];\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      var t = this.positions.length / 6;\n      this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [];\n      var e, i;\n      this.compareV3(0, t - 1) ? i = this.copyV3(t - 2) : i = this.copyV3(0), this.previous.push(i[0], i[1], i[2]), this.previous.push(i[0], i[1], i[2]);\n      for (var s = 0; s < t; s++) {\n        if (this.side.push(1), this.side.push(-1), this.widthCallback ? e = this.widthCallback(s / (t - 1)) : e = 1, this.width.push(e), this.width.push(e), this.uvs.push(s / (t - 1), 0), this.uvs.push(s / (t - 1), 1), s < t - 1) {\n          i = this.copyV3(s), this.previous.push(i[0], i[1], i[2]), this.previous.push(i[0], i[1], i[2]);\n          var n = s * 2;\n          this.indices_array.push(n, n + 1, n + 2), this.indices_array.push(n + 2, n + 1, n + 3);\n        }\n        s > 0 && (i = this.copyV3(s), this.next.push(i[0], i[1], i[2]), this.next.push(i[0], i[1], i[2]));\n      }\n      this.compareV3(t - 1, 0) ? i = this.copyV3(1) : i = this.copyV3(t - 1), this.next.push(i[0], i[1], i[2]), this.next.push(i[0], i[1], i[2]), !this._attributes || this._attributes.position.count !== this.positions.length ? this._attributes = {\n        position: new r.BufferAttribute(new Float32Array(this.positions), 3),\n        previous: new r.BufferAttribute(new Float32Array(this.previous), 3),\n        next: new r.BufferAttribute(new Float32Array(this.next), 3),\n        side: new r.BufferAttribute(new Float32Array(this.side), 1),\n        width: new r.BufferAttribute(new Float32Array(this.width), 1),\n        uv: new r.BufferAttribute(new Float32Array(this.uvs), 2),\n        index: new r.BufferAttribute(new Uint16Array(this.indices_array), 1),\n        counters: new r.BufferAttribute(new Float32Array(this.counters), 1)\n      } : (this._attributes.position.copyArray(new Float32Array(this.positions)), this._attributes.position.needsUpdate = !0, this._attributes.previous.copyArray(new Float32Array(this.previous)), this._attributes.previous.needsUpdate = !0, this._attributes.next.copyArray(new Float32Array(this.next)), this._attributes.next.needsUpdate = !0, this._attributes.side.copyArray(new Float32Array(this.side)), this._attributes.side.needsUpdate = !0, this._attributes.width.copyArray(new Float32Array(this.width)), this._attributes.width.needsUpdate = !0, this._attributes.uv.copyArray(new Float32Array(this.uvs)), this._attributes.uv.needsUpdate = !0, this._attributes.index.copyArray(new Uint16Array(this.indices_array)), this._attributes.index.needsUpdate = !0), this.setAttribute(\"position\", this._attributes.position), this.setAttribute(\"previous\", this._attributes.previous), this.setAttribute(\"next\", this._attributes.next), this.setAttribute(\"side\", this._attributes.side), this.setAttribute(\"width\", this._attributes.width), this.setAttribute(\"uv\", this._attributes.uv), this.setAttribute(\"counters\", this._attributes.counters), this.setIndex(this._attributes.index), this.computeBoundingSphere(), this.computeBoundingBox();\n    }\n  }, {\n    key: \"advance\",\n    value: function advance(_ref) {\n      var t = _ref.x,\n        e = _ref.y,\n        i = _ref.z;\n      var s = this._attributes.position.array,\n        n = this._attributes.previous.array,\n        u = this._attributes.next.array,\n        o = s.length;\n      c(s, 0, n, 0, o), c(s, 6, s, 0, o - 6), s[o - 6] = t, s[o - 5] = e, s[o - 4] = i, s[o - 3] = t, s[o - 2] = e, s[o - 1] = i, c(s, 6, u, 0, o - 6), u[o - 6] = t, u[o - 5] = e, u[o - 4] = i, u[o - 3] = t, u[o - 2] = e, u[o - 1] = i, this._attributes.position.needsUpdate = !0, this._attributes.previous.needsUpdate = !0, this._attributes.next.needsUpdate = !0;\n    }\n  }]);\n  return S;\n}(r.BufferGeometry);\nr.ShaderChunk.meshline_vert = \"\\n  #include <common>\\n  \".concat(r.ShaderChunk.logdepthbuf_pars_vertex, \"\\n  \").concat(r.ShaderChunk.fog_pars_vertex, \"\\n\\n  attribute vec3 previous;\\n  attribute vec3 next;\\n  attribute float side;\\n  attribute float width;\\n  attribute float counters;\\n  \\n  uniform vec2 resolution;\\n  uniform float lineWidth;\\n  uniform vec3 color;\\n  uniform float opacity;\\n  uniform float sizeAttenuation;\\n  \\n  varying vec2 vUV;\\n  varying vec4 vColor;\\n  varying float vCounters;\\n  \\n  vec2 fix(vec4 i, float aspect) {\\n    vec2 res = i.xy / i.w;\\n    res.x *= aspect;\\n  \\tvCounters = counters;\\n    return res;\\n  }\\n  \\n  void main() {\\n    float aspect = resolution.x / resolution.y;\\n    vColor = vec4(color, opacity);\\n    vUV = uv;\\n  \\n    mat4 m = projectionMatrix * modelViewMatrix;\\n    vec4 finalPosition = m * vec4(position, 1.0);\\n    vec4 prevPos = m * vec4(previous, 1.0);\\n    vec4 nextPos = m * vec4(next, 1.0);\\n  \\n    vec2 currentP = fix(finalPosition, aspect);\\n    vec2 prevP = fix(prevPos, aspect);\\n    vec2 nextP = fix(nextPos, aspect);\\n  \\n    float w = lineWidth * width;\\n  \\n    vec2 dir;\\n    if (nextP == currentP) dir = normalize(currentP - prevP);\\n    else if (prevP == currentP) dir = normalize(nextP - currentP);\\n    else {\\n      vec2 dir1 = normalize(currentP - prevP);\\n      vec2 dir2 = normalize(nextP - currentP);\\n      dir = normalize(dir1 + dir2);\\n  \\n      vec2 perp = vec2(-dir1.y, dir1.x);\\n      vec2 miter = vec2(-dir.y, dir.x);\\n      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\\n    }\\n  \\n    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;\\n    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\\n    normal.xy *= .5 * w;\\n    //normal *= projectionMatrix;\\n    if (sizeAttenuation == 0.) {\\n      normal.xy *= finalPosition.w;\\n      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy;\\n    }\\n  \\n    finalPosition.xy += normal.xy * side;\\n    gl_Position = finalPosition;\\n    \").concat(r.ShaderChunk.logdepthbuf_vertex, \"\\n    \").concat(r.ShaderChunk.fog_vertex, \"\\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n    \").concat(r.ShaderChunk.fog_vertex, \"\\n  }\");\nr.ShaderChunk.meshline_frag = \"\\n  \\n  \".concat(r.ShaderChunk.fog_pars_fragment, \"\\n  \").concat(r.ShaderChunk.logdepthbuf_pars_fragment, \"\\n  \\n  uniform sampler2D map;\\n  uniform sampler2D alphaMap;\\n  uniform float useMap;\\n  uniform float useAlphaMap;\\n  uniform float useDash;\\n  uniform float dashArray;\\n  uniform float dashOffset;\\n  uniform float dashRatio;\\n  uniform float visibility;\\n  uniform float alphaTest;\\n  uniform vec2 repeat;\\n  \\n  varying vec2 vUV;\\n  varying vec4 vColor;\\n  varying float vCounters;\\n  \\n  void main() {\\n    \").concat(r.ShaderChunk.logdepthbuf_fragment, \"\\n    vec4 c = vColor;\\n    if (useMap == 1.) c *= texture2D(map, vUV * repeat);\\n    if (useAlphaMap == 1.) c.a *= texture2D(alphaMap, vUV * repeat).a;\\n    if (c.a < alphaTest) discard;\\n    if (useDash == 1.) {\\n      c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\\n    }\\n    gl_FragColor = c;\\n    gl_FragColor.a *= step(vCounters, visibility);\\n    \").concat(r.ShaderChunk.fog_fragment, \"\\n    #include <tonemapping_fragment>\\n    #include <encodings_fragment>\\n  }\");\nvar V = /*#__PURE__*/function (_r$ShaderMaterial) {\n  _inherits(V, _r$ShaderMaterial);\n  var _super2 = _createSuper(V);\n  function V(t) {\n    var _this2;\n    _classCallCheck(this, V);\n    _this2 = _super2.call(this, {\n      uniforms: Object.assign({}, r.UniformsLib.fog, {\n        lineWidth: {\n          value: 1\n        },\n        map: {\n          value: null\n        },\n        useMap: {\n          value: 0\n        },\n        alphaMap: {\n          value: null\n        },\n        useAlphaMap: {\n          value: 0\n        },\n        color: {\n          value: new r.Color(16777215)\n        },\n        opacity: {\n          value: 1\n        },\n        resolution: {\n          value: new r.Vector2(1, 1)\n        },\n        sizeAttenuation: {\n          value: 1\n        },\n        dashArray: {\n          value: 0\n        },\n        dashOffset: {\n          value: 0\n        },\n        dashRatio: {\n          value: 0.5\n        },\n        useDash: {\n          value: 0\n        },\n        visibility: {\n          value: 1\n        },\n        alphaTest: {\n          value: 0\n        },\n        repeat: {\n          value: new r.Vector2(1, 1)\n        }\n      }),\n      vertexShader: r.ShaderChunk.meshline_vert,\n      fragmentShader: r.ShaderChunk.meshline_frag\n    }), _this2.type = \"MeshLineMaterial\", Object.defineProperties(_assertThisInitialized(_this2), {\n      lineWidth: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.lineWidth.value;\n        },\n        set: function set(e) {\n          this.uniforms.lineWidth.value = e;\n        }\n      },\n      map: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.map.value;\n        },\n        set: function set(e) {\n          this.uniforms.map.value = e;\n        }\n      },\n      useMap: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.useMap.value;\n        },\n        set: function set(e) {\n          this.uniforms.useMap.value = e;\n        }\n      },\n      alphaMap: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.alphaMap.value;\n        },\n        set: function set(e) {\n          this.uniforms.alphaMap.value = e;\n        }\n      },\n      useAlphaMap: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n        set: function set(e) {\n          this.uniforms.useAlphaMap.value = e;\n        }\n      },\n      color: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.color.value;\n        },\n        set: function set(e) {\n          this.uniforms.color.value = e;\n        }\n      },\n      opacity: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(e) {\n          this.uniforms.opacity.value = e;\n        }\n      },\n      resolution: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(e) {\n          this.uniforms.resolution.value.copy(e);\n        }\n      },\n      sizeAttenuation: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n        set: function set(e) {\n          this.uniforms.sizeAttenuation.value = e;\n        }\n      },\n      dashArray: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.dashArray.value;\n        },\n        set: function set(e) {\n          this.uniforms.dashArray.value = e, this.useDash = e !== 0 ? 1 : 0;\n        }\n      },\n      dashOffset: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(e) {\n          this.uniforms.dashOffset.value = e;\n        }\n      },\n      dashRatio: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.dashRatio.value;\n        },\n        set: function set(e) {\n          this.uniforms.dashRatio.value = e;\n        }\n      },\n      useDash: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.useDash.value;\n        },\n        set: function set(e) {\n          this.uniforms.useDash.value = e;\n        }\n      },\n      visibility: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.visibility.value;\n        },\n        set: function set(e) {\n          this.uniforms.visibility.value = e;\n        }\n      },\n      alphaTest: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.alphaTest.value;\n        },\n        set: function set(e) {\n          this.uniforms.alphaTest.value = e;\n        }\n      },\n      repeat: {\n        enumerable: !0,\n        get: function get() {\n          return this.uniforms.repeat.value;\n        },\n        set: function set(e) {\n          this.uniforms.repeat.value.copy(e);\n        }\n      }\n    }), _this2.setValues(t);\n    return _this2;\n  }\n  _createClass(V, [{\n    key: \"copy\",\n    value: function copy(t) {\n      return _get(_getPrototypeOf(V.prototype), \"copy\", this).call(this, t), this.lineWidth = t.lineWidth, this.map = t.map, this.useMap = t.useMap, this.alphaMap = t.alphaMap, this.useAlphaMap = t.useAlphaMap, this.color.copy(t.color), this.opacity = t.opacity, this.resolution.copy(t.resolution), this.sizeAttenuation = t.sizeAttenuation, this.dashArray.copy(t.dashArray), this.dashOffset.copy(t.dashOffset), this.dashRatio.copy(t.dashRatio), this.useDash = t.useDash, this.visibility = t.visibility, this.alphaTest = t.alphaTest, this.repeat.copy(t.repeat), this;\n    }\n  }]);\n  return V;\n}(r.ShaderMaterial);\nfunction k(a, t) {\n  var e = new r.Matrix4(),\n    i = new r.Ray(),\n    s = new r.Sphere(),\n    n = new r.Vector3(),\n    u = this.geometry;\n  if (s.copy(u.boundingSphere), s.applyMatrix4(this.matrixWorld), a.ray.intersectSphere(s, n) === !1) return;\n  e.copy(this.matrixWorld).invert(), i.copy(a.ray).applyMatrix4(e);\n  var o = new r.Vector3(),\n    f = new r.Vector3(),\n    d = new r.Vector3(),\n    A = this instanceof r.LineSegments ? 2 : 1,\n    v = u.index,\n    m = u.attributes;\n  if (v !== null) {\n    var l = v.array,\n      y = m.position.array,\n      b = m.width.array;\n    for (var h = 0, x = l.length - 1; h < x; h += A) {\n      var w = l[h],\n        _ = l[h + 1];\n      o.fromArray(y, w * 3), f.fromArray(y, _ * 3);\n      var M = b[Math.floor(h / 3)] != null ? b[Math.floor(h / 3)] : 1,\n        g = a.params.Line.threshold + this.material.lineWidth * M / 2,\n        C = g * g;\n      if (i.distanceSqToSegment(o, f, n, d) > C) continue;\n      n.applyMatrix4(this.matrixWorld);\n      var p = a.ray.origin.distanceTo(n);\n      p < a.near || p > a.far || (t.push({\n        distance: p,\n        point: d.clone().applyMatrix4(this.matrixWorld),\n        index: h,\n        face: null,\n        faceIndex: null,\n        object: this\n      }), h = x);\n    }\n  }\n}\nexport { S as MeshLineGeometry, V as MeshLineMaterial, k as raycast };","map":null,"metadata":{},"sourceType":"module"}