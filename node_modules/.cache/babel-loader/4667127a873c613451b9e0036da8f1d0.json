{"ast":null,"code":"import _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"mixBlur\", \"mixStrength\", \"resolution\", \"blur\", \"args\", \"minDepthThreshold\", \"maxDepthThreshold\", \"depthScale\", \"depthToBlurRatioBias\", \"mirror\", \"children\", \"debug\", \"distortion\", \"mixContrast\", \"distortionMap\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, LinearFilter, WebGLRenderTarget, DepthTexture, DepthFormat, UnsignedShortType } from 'three';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\nimport { BlurPass } from '../materials/BlurPass.js';\nimport { MeshReflectorMaterial } from '../materials/MeshReflectorMaterial.js';\nextend({\n  MeshReflectorMaterial: MeshReflectorMaterial\n});\nvar Reflector = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var _ref$mixBlur = _ref.mixBlur,\n    mixBlur = _ref$mixBlur === void 0 ? 0 : _ref$mixBlur,\n    _ref$mixStrength = _ref.mixStrength,\n    mixStrength = _ref$mixStrength === void 0 ? 0.5 : _ref$mixStrength,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 256 : _ref$resolution,\n    _ref$blur = _ref.blur,\n    blur = _ref$blur === void 0 ? [0, 0] : _ref$blur,\n    _ref$args = _ref.args,\n    args = _ref$args === void 0 ? [1, 1] : _ref$args,\n    _ref$minDepthThreshol = _ref.minDepthThreshold,\n    minDepthThreshold = _ref$minDepthThreshol === void 0 ? 0.9 : _ref$minDepthThreshol,\n    _ref$maxDepthThreshol = _ref.maxDepthThreshold,\n    maxDepthThreshold = _ref$maxDepthThreshol === void 0 ? 1 : _ref$maxDepthThreshol,\n    _ref$depthScale = _ref.depthScale,\n    depthScale = _ref$depthScale === void 0 ? 0 : _ref$depthScale,\n    _ref$depthToBlurRatio = _ref.depthToBlurRatioBias,\n    depthToBlurRatioBias = _ref$depthToBlurRatio === void 0 ? 0.25 : _ref$depthToBlurRatio,\n    _ref$mirror = _ref.mirror,\n    mirror = _ref$mirror === void 0 ? 0 : _ref$mirror,\n    children = _ref.children,\n    _ref$debug = _ref.debug,\n    debug = _ref$debug === void 0 ? 0 : _ref$debug,\n    _ref$distortion = _ref.distortion,\n    distortion = _ref$distortion === void 0 ? 1 : _ref$distortion,\n    _ref$mixContrast = _ref.mixContrast,\n    mixContrast = _ref$mixContrast === void 0 ? 1 : _ref$mixContrast,\n    distortionMap = _ref.distortionMap,\n    props = _objectWithoutProperties(_ref, _excluded);\n  React.useEffect(function () {\n    console.warn('Reflector has been deprecated and will be removed next major. Replace it with <MeshReflectorMaterial />!');\n  }, []);\n  var gl = useThree(function (_ref2) {\n    var gl = _ref2.gl;\n    return gl;\n  });\n  var camera = useThree(function (_ref3) {\n    var camera = _ref3.camera;\n    return camera;\n  });\n  var scene = useThree(function (_ref4) {\n    var scene = _ref4.scene;\n    return scene;\n  });\n  blur = Array.isArray(blur) ? blur : [blur, blur];\n  var hasBlur = blur[0] + blur[1] > 0;\n  var meshRef = React.useRef(null);\n  var _React$useState = React.useState(function () {\n      return new Plane();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    reflectorPlane = _React$useState2[0];\n  var _React$useState3 = React.useState(function () {\n      return new Vector3();\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 1),\n    normal = _React$useState4[0];\n  var _React$useState5 = React.useState(function () {\n      return new Vector3();\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 1),\n    reflectorWorldPosition = _React$useState6[0];\n  var _React$useState7 = React.useState(function () {\n      return new Vector3();\n    }),\n    _React$useState8 = _slicedToArray(_React$useState7, 1),\n    cameraWorldPosition = _React$useState8[0];\n  var _React$useState9 = React.useState(function () {\n      return new Matrix4();\n    }),\n    _React$useState10 = _slicedToArray(_React$useState9, 1),\n    rotationMatrix = _React$useState10[0];\n  var _React$useState11 = React.useState(function () {\n      return new Vector3(0, 0, -1);\n    }),\n    _React$useState12 = _slicedToArray(_React$useState11, 1),\n    lookAtPosition = _React$useState12[0];\n  var _React$useState13 = React.useState(function () {\n      return new Vector4();\n    }),\n    _React$useState14 = _slicedToArray(_React$useState13, 1),\n    clipPlane = _React$useState14[0];\n  var _React$useState15 = React.useState(function () {\n      return new Vector3();\n    }),\n    _React$useState16 = _slicedToArray(_React$useState15, 1),\n    view = _React$useState16[0];\n  var _React$useState17 = React.useState(function () {\n      return new Vector3();\n    }),\n    _React$useState18 = _slicedToArray(_React$useState17, 1),\n    target = _React$useState18[0];\n  var _React$useState19 = React.useState(function () {\n      return new Vector4();\n    }),\n    _React$useState20 = _slicedToArray(_React$useState19, 1),\n    q = _React$useState20[0];\n  var _React$useState21 = React.useState(function () {\n      return new Matrix4();\n    }),\n    _React$useState22 = _slicedToArray(_React$useState21, 1),\n    textureMatrix = _React$useState22[0];\n  var _React$useState23 = React.useState(function () {\n      return new PerspectiveCamera();\n    }),\n    _React$useState24 = _slicedToArray(_React$useState23, 1),\n    virtualCamera = _React$useState24[0];\n  var beforeRender = React.useCallback(function () {\n    reflectorWorldPosition.setFromMatrixPosition(meshRef.current.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(meshRef.current.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(meshRef.current.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0;\n    projectionMatrix.elements[14] = clipPlane.w;\n  }, []);\n  var _React$useMemo = React.useMemo(function () {\n      var parameters = {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        encoding: gl.outputEncoding\n      };\n      var fbo1 = new WebGLRenderTarget(resolution, resolution, parameters);\n      fbo1.depthBuffer = true;\n      fbo1.depthTexture = new DepthTexture(resolution, resolution);\n      fbo1.depthTexture.format = DepthFormat;\n      fbo1.depthTexture.type = UnsignedShortType;\n      var fbo2 = new WebGLRenderTarget(resolution, resolution, parameters);\n      var blurpass = new BlurPass({\n        gl: gl,\n        resolution: resolution,\n        width: blur[0],\n        height: blur[1],\n        minDepthThreshold: minDepthThreshold,\n        maxDepthThreshold: maxDepthThreshold,\n        depthScale: depthScale,\n        depthToBlurRatioBias: depthToBlurRatioBias\n      });\n      var reflectorProps = {\n        mirror: mirror,\n        textureMatrix: textureMatrix,\n        mixBlur: mixBlur,\n        tDiffuse: fbo1.texture,\n        tDepth: fbo1.depthTexture,\n        tDiffuseBlur: fbo2.texture,\n        hasBlur: hasBlur,\n        mixStrength: mixStrength,\n        minDepthThreshold: minDepthThreshold,\n        maxDepthThreshold: maxDepthThreshold,\n        depthScale: depthScale,\n        depthToBlurRatioBias: depthToBlurRatioBias,\n        transparent: true,\n        debug: debug,\n        distortion: distortion,\n        distortionMap: distortionMap,\n        mixContrast: mixContrast,\n        'defines-USE_BLUR': hasBlur ? '' : undefined,\n        'defines-USE_DEPTH': depthScale > 0 ? '' : undefined,\n        'defines-USE_DISTORTION': distortionMap ? '' : undefined\n      };\n      return [fbo1, fbo2, blurpass, reflectorProps];\n    }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, debug, distortion, distortionMap, mixContrast]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 4),\n    fbo1 = _React$useMemo2[0],\n    fbo2 = _React$useMemo2[1],\n    blurpass = _React$useMemo2[2],\n    reflectorProps = _React$useMemo2[3];\n  useFrame(function () {\n    if (!(meshRef != null && meshRef.current)) return;\n    meshRef.current.visible = false;\n    var currentXrEnabled = gl.xr.enabled;\n    var currentShadowAutoUpdate = gl.shadowMap.autoUpdate;\n    beforeRender();\n    gl.xr.enabled = false;\n    gl.shadowMap.autoUpdate = false;\n    gl.setRenderTarget(fbo1);\n    gl.state.buffers.depth.setMask(true);\n    if (!gl.autoClear) gl.clear();\n    gl.render(scene, virtualCamera);\n    if (hasBlur) blurpass.render(gl, fbo1, fbo2);\n    gl.xr.enabled = currentXrEnabled;\n    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    meshRef.current.visible = true;\n    gl.setRenderTarget(null);\n  });\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: mergeRefs([meshRef, ref])\n  }, props), /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: args\n  }), children ? children('meshReflectorMaterial', reflectorProps) : /*#__PURE__*/React.createElement(\"meshReflectorMaterial\", reflectorProps));\n});\nexport { Reflector };","map":null,"metadata":{},"sourceType":"module"}