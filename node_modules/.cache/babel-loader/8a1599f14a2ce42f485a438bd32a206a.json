{"ast":null,"code":"import _toConsumableArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nvar isOrthographic = function isOrthographic(def) {\n  return def && def.isOrthographicCamera;\n};\nvar isBox3 = function isBox3(def) {\n  return def && def.isBox3;\n};\nvar context = /*#__PURE__*/React.createContext(null);\nfunction Bounds(_ref) {\n  var children = _ref.children,\n    _ref$damping = _ref.damping,\n    damping = _ref$damping === void 0 ? 6 : _ref$damping,\n    fit = _ref.fit,\n    clip = _ref.clip,\n    observe = _ref.observe,\n    _ref$margin = _ref.margin,\n    margin = _ref$margin === void 0 ? 1.2 : _ref$margin,\n    _ref$eps = _ref.eps,\n    eps = _ref$eps === void 0 ? 0.01 : _ref$eps,\n    onFit = _ref.onFit;\n  var ref = React.useRef(null);\n  var _useThree = useThree(),\n    camera = _useThree.camera,\n    invalidate = _useThree.invalidate,\n    size = _useThree.size,\n    controlsImpl = _useThree.controls;\n  var controls = controlsImpl;\n  var onFitRef = React.useRef(onFit);\n  onFitRef.current = onFit;\n  function equals(a, b) {\n    return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps && Math.abs(a.z - b.z) < eps;\n  }\n  function damp(v, t, lambda, delta) {\n    v.x = THREE.MathUtils.damp(v.x, t.x, lambda, delta);\n    v.y = THREE.MathUtils.damp(v.y, t.y, lambda, delta);\n    v.z = THREE.MathUtils.damp(v.z, t.z, lambda, delta);\n  }\n  var _React$useState = React.useState(function () {\n      return {\n        animating: false,\n        focus: new THREE.Vector3(),\n        camera: new THREE.Vector3(),\n        zoom: 1\n      };\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    current = _React$useState2[0];\n  var _React$useState3 = React.useState(function () {\n      return {\n        focus: new THREE.Vector3(),\n        camera: new THREE.Vector3(),\n        zoom: 1\n      };\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 1),\n    goal = _React$useState4[0];\n  var _React$useState5 = React.useState(function () {\n      return new THREE.Box3();\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 1),\n    box = _React$useState6[0];\n  var api = React.useMemo(function () {\n    function getSize() {\n      var size = box.getSize(new THREE.Vector3());\n      var center = box.getCenter(new THREE.Vector3());\n      var maxSize = Math.max(size.x, size.y, size.z);\n      var fitHeightDistance = isOrthographic(camera) ? maxSize * 4 : maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));\n      var fitWidthDistance = isOrthographic(camera) ? maxSize * 4 : fitHeightDistance / camera.aspect;\n      var distance = margin * Math.max(fitHeightDistance, fitWidthDistance);\n      return {\n        box: box,\n        size: size,\n        center: center,\n        distance: distance\n      };\n    }\n    return {\n      getSize: getSize,\n      refresh: function refresh(object) {\n        if (isBox3(object)) box.copy(object);else {\n          var target = object || ref.current;\n          target.updateWorldMatrix(true, true);\n          box.setFromObject(target);\n        }\n        if (box.isEmpty()) {\n          var max = camera.position.length() || 10;\n          box.setFromCenterAndSize(new THREE.Vector3(), new THREE.Vector3(max, max, max));\n        }\n        if ((controls == null ? void 0 : controls.constructor.name) === 'OrthographicTrackballControls') {\n          // Put camera on a sphere along which it should move\n          var _getSize = getSize(),\n            distance = _getSize.distance;\n          var direction = camera.position.clone().sub(controls.target).normalize().multiplyScalar(distance);\n          var newPos = controls.target.clone().add(direction);\n          camera.position.copy(newPos);\n        }\n        return this;\n      },\n      clip: function clip() {\n        var _getSize2 = getSize(),\n          distance = _getSize2.distance;\n        if (controls) controls.maxDistance = distance * 10;\n        camera.near = distance / 100;\n        camera.far = distance * 100;\n        camera.updateProjectionMatrix();\n        if (controls) controls.update();\n        invalidate();\n        return this;\n      },\n      to: function to(_ref2) {\n        var _goal$camera;\n        var position = _ref2.position,\n          target = _ref2.target;\n        current.camera.copy(camera.position);\n        var _getSize3 = getSize(),\n          center = _getSize3.center;\n        (_goal$camera = goal.camera).set.apply(_goal$camera, _toConsumableArray(position));\n        if (target) {\n          var _goal$focus;\n          (_goal$focus = goal.focus).set.apply(_goal$focus, _toConsumableArray(target));\n        } else {\n          goal.focus.copy(center);\n        }\n        if (damping) {\n          current.animating = true;\n        } else {\n          var _camera$position;\n          (_camera$position = camera.position).set.apply(_camera$position, _toConsumableArray(position));\n        }\n        return this;\n      },\n      fit: function fit() {\n        current.camera.copy(camera.position);\n        if (controls) current.focus.copy(controls.target);\n        var _getSize4 = getSize(),\n          center = _getSize4.center,\n          distance = _getSize4.distance;\n        var direction = center.clone().sub(camera.position).normalize().multiplyScalar(distance);\n        goal.camera.copy(center).sub(direction);\n        goal.focus.copy(center);\n        if (isOrthographic(camera)) {\n          current.zoom = camera.zoom;\n          var maxHeight = 0,\n            maxWidth = 0;\n          var vertices = [new THREE.Vector3(box.min.x, box.min.y, box.min.z), new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(box.min.x, box.min.y, box.max.z), new THREE.Vector3(box.min.x, box.max.y, box.max.z), new THREE.Vector3(box.max.x, box.max.y, box.max.z), new THREE.Vector3(box.max.x, box.max.y, box.min.z), new THREE.Vector3(box.max.x, box.min.y, box.max.z), new THREE.Vector3(box.max.x, box.min.y, box.min.z)]; // Transform the center and each corner to camera space\n\n          center.applyMatrix4(camera.matrixWorldInverse);\n          for (var _i = 0, _vertices = vertices; _i < _vertices.length; _i++) {\n            var v = _vertices[_i];\n            v.applyMatrix4(camera.matrixWorldInverse);\n            maxHeight = Math.max(maxHeight, Math.abs(v.y - center.y));\n            maxWidth = Math.max(maxWidth, Math.abs(v.x - center.x));\n          }\n          maxHeight *= 2;\n          maxWidth *= 2;\n          var zoomForHeight = (camera.top - camera.bottom) / maxHeight;\n          var zoomForWidth = (camera.right - camera.left) / maxWidth;\n          goal.zoom = Math.min(zoomForHeight, zoomForWidth) / margin;\n          if (!damping) {\n            camera.zoom = goal.zoom;\n            camera.updateProjectionMatrix();\n          }\n        }\n        if (damping) {\n          current.animating = true;\n        } else {\n          camera.position.copy(goal.camera);\n          camera.lookAt(goal.focus);\n          if (controls) {\n            controls.target.copy(goal.focus);\n            controls.update();\n          }\n        }\n        if (onFitRef.current) onFitRef.current(this.getSize());\n        invalidate();\n        return this;\n      }\n    };\n  }, [box, camera, controls, margin, damping, invalidate]);\n  React.useLayoutEffect(function () {\n    if (controls) {\n      // Try to prevent drag hijacking\n      var callback = function callback() {\n        return current.animating = false;\n      };\n      controls.addEventListener('start', callback);\n      return function () {\n        return controls.removeEventListener('start', callback);\n      };\n    }\n  }, [controls]); // Scale pointer on window resize\n\n  var count = React.useRef(0);\n  React.useLayoutEffect(function () {\n    if (observe || count.current++ === 0) {\n      api.refresh();\n      if (fit) api.fit();\n      if (clip) api.clip();\n    }\n  }, [size, clip, fit, observe, camera, controls]);\n  useFrame(function (state, delta) {\n    if (current.animating) {\n      damp(current.focus, goal.focus, damping, delta);\n      damp(current.camera, goal.camera, damping, delta);\n      current.zoom = THREE.MathUtils.damp(current.zoom, goal.zoom, damping, delta);\n      camera.position.copy(current.camera);\n      if (isOrthographic(camera)) {\n        camera.zoom = current.zoom;\n        camera.updateProjectionMatrix();\n      }\n      if (!controls) {\n        camera.lookAt(current.focus);\n      } else {\n        controls.target.copy(current.focus);\n        controls.update();\n      }\n      invalidate();\n      if (isOrthographic(camera) && !(Math.abs(current.zoom - goal.zoom) < eps)) return;\n      if (!isOrthographic(camera) && !equals(current.camera, goal.camera)) return;\n      if (controls && !equals(current.focus, goal.focus)) return;\n      current.animating = false;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: ref\n  }, /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children));\n}\nfunction useBounds() {\n  return React.useContext(context);\n}\nexport { Bounds, useBounds };","map":null,"metadata":{},"sourceType":"module"}