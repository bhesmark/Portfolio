{"ast":null,"code":"import _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _construct from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"children\", \"temporal\", \"frames\", \"limit\", \"blend\", \"scale\", \"opacity\", \"alphaTest\", \"color\", \"colorBlend\", \"resolution\", \"toneMapped\"],\n  _excluded2 = [\"castShadow\", \"bias\", \"mapSize\", \"size\", \"near\", \"far\", \"frames\", \"position\", \"radius\", \"amount\", \"intensity\", \"ambient\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nfunction isLight(object) {\n  return object.isLight;\n}\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\nvar accumulativeContext = /*#__PURE__*/React.createContext(null);\nvar SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, \"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vUv = uv;\\n   }\", \"varying vec2 vUv;\\n   uniform sampler2D map;\\n   uniform vec3 color;\\n   uniform float opacity;\\n   uniform float alphaTest;\\n   uniform float blend;\\n   void main() {\\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\\n     #include <tonemapping_fragment>\\n     #include <encodings_fragment>\\n   }\");\nvar DiscardMaterial = shaderMaterial({}, 'void main() { gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }', 'void main() { discard; }');\nvar AccumulativeShadows = /*#__PURE__*/React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n    temporal = _ref.temporal,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? 40 : _ref$frames,\n    _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? Infinity : _ref$limit,\n    _ref$blend = _ref.blend,\n    blend = _ref$blend === void 0 ? 20 : _ref$blend,\n    _ref$scale = _ref.scale,\n    scale = _ref$scale === void 0 ? 10 : _ref$scale,\n    _ref$opacity = _ref.opacity,\n    opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n    _ref$alphaTest = _ref.alphaTest,\n    alphaTest = _ref$alphaTest === void 0 ? 0.75 : _ref$alphaTest,\n    _ref$color = _ref.color,\n    color = _ref$color === void 0 ? 'black' : _ref$color,\n    _ref$colorBlend = _ref.colorBlend,\n    colorBlend = _ref$colorBlend === void 0 ? 2 : _ref$colorBlend,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 1024 : _ref$resolution,\n    _ref$toneMapped = _ref.toneMapped,\n    toneMapped = _ref$toneMapped === void 0 ? true : _ref$toneMapped,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    SoftShadowMaterial: SoftShadowMaterial\n  });\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var camera = useThree(function (state) {\n    return state.camera;\n  });\n  var gPlane = React.useRef(null);\n  var gLights = React.useRef(null);\n  var _React$useState = React.useState(function () {\n      return new ProgressiveLightMap(gl, scene, resolution);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    plm = _React$useState2[0];\n  React.useLayoutEffect(function () {\n    plm.configure(gPlane.current);\n  }, []);\n  var api = React.useMemo(function () {\n    return {\n      lights: new Map(),\n      temporal: !!temporal,\n      frames: Math.max(2, frames),\n      blend: Math.max(2, frames === Infinity ? blend : frames),\n      count: 0,\n      getMesh: function getMesh() {\n        return gPlane.current;\n      },\n      reset: function reset() {\n        // Clear buffers, reset opacities, set frame count to 0\n        plm.clear();\n        var material = gPlane.current.material;\n        material.opacity = 0;\n        material.alphaTest = 0;\n        api.count = 0;\n      },\n      update: function update() {\n        var frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        // Adapt the opacity-blend ratio to the number of frames\n        var material = gPlane.current.material;\n        if (!api.temporal) {\n          material.opacity = opacity;\n          material.alphaTest = alphaTest;\n        } else {\n          material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n          material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n        } // Switch accumulative lights on\n\n        gLights.current.visible = true; // Collect scene lights and meshes\n\n        plm.prepare(); // Update the lightmap and the accumulative lights\n\n        for (var i = 0; i < frames; i++) {\n          api.lights.forEach(function (light) {\n            return light.update();\n          });\n          plm.update(camera, api.blend);\n        } // Switch lights off\n\n        gLights.current.visible = false; // Restore lights and meshes\n\n        plm.finish();\n      }\n    };\n  }, [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(function () {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, function () {\n    return api;\n  }, [api]);\n  useFrame(function () {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: function traverse() {\n      return null;\n    },\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nvar RandomizedLight = /*#__PURE__*/React.forwardRef(function (_ref2, forwardRef) {\n  var _ref2$castShadow = _ref2.castShadow,\n    castShadow = _ref2$castShadow === void 0 ? true : _ref2$castShadow,\n    _ref2$bias = _ref2.bias,\n    bias = _ref2$bias === void 0 ? 0.001 : _ref2$bias,\n    _ref2$mapSize = _ref2.mapSize,\n    mapSize = _ref2$mapSize === void 0 ? 512 : _ref2$mapSize,\n    _ref2$size = _ref2.size,\n    size = _ref2$size === void 0 ? 5 : _ref2$size,\n    _ref2$near = _ref2.near,\n    near = _ref2$near === void 0 ? 0.5 : _ref2$near,\n    _ref2$far = _ref2.far,\n    far = _ref2$far === void 0 ? 500 : _ref2$far,\n    _ref2$frames = _ref2.frames,\n    frames = _ref2$frames === void 0 ? 1 : _ref2$frames,\n    _ref2$position = _ref2.position,\n    position = _ref2$position === void 0 ? [0, 0, 0] : _ref2$position,\n    _ref2$radius = _ref2.radius,\n    radius = _ref2$radius === void 0 ? 1 : _ref2$radius,\n    _ref2$amount = _ref2.amount,\n    amount = _ref2$amount === void 0 ? 8 : _ref2$amount,\n    _ref2$intensity = _ref2.intensity,\n    intensity = _ref2$intensity === void 0 ? 1 : _ref2$intensity,\n    _ref2$ambient = _ref2.ambient,\n    ambient = _ref2$ambient === void 0 ? 0.5 : _ref2$ambient,\n    props = _objectWithoutProperties(_ref2, _excluded2);\n  var gLights = React.useRef(null);\n  var length = _construct(THREE.Vector3, _toConsumableArray(position)).length();\n  var parent = React.useContext(accumulativeContext);\n  var update = React.useCallback(function () {\n    var light;\n    if (gLights.current) {\n      for (var l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          var lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          var phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length].concat(_toConsumableArray(position)));\n  var api = React.useMemo(function () {\n    return {\n      update: update\n    };\n  }, [update]);\n  React.useImperativeHandle(forwardRef, function () {\n    return api;\n  }, [api]);\n  React.useLayoutEffect(function () {\n    var group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return function () {\n      return void parent.lights[\"delete\"](group.uuid);\n    };\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, function (_, index) {\n    return /*#__PURE__*/React.createElement(\"directionalLight\", {\n      key: index,\n      castShadow: castShadow,\n      \"shadow-bias\": bias,\n      \"shadow-mapSize\": [mapSize, mapSize],\n      intensity: intensity / amount\n    }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n      attach: \"shadow-camera\",\n      args: [-size, size, size, -size, near, far]\n    }));\n  }));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer, scene) {\n    var _this = this;\n    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n    _classCallCheck(this, ProgressiveLightMap);\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null; // Create the Progressive LightMap Texture\n\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshPhongMaterial({\n      shininess: 0\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n    this.targetMat.onBeforeCompile = function (shader) {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      var bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n      }\"; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = _this.previousShadowMap;\n      shader.uniforms.averagingWindow = _this.averagingWindow;\n    };\n  }\n  _createClass(ProgressiveLightMap, [{\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n      this.renderer.setRenderTarget(this.progressiveLightMap1);\n      this.renderer.clear();\n      this.renderer.setRenderTarget(this.progressiveLightMap2);\n      this.renderer.clear();\n      this.lights = [];\n      this.meshes = [];\n      this.scene.traverse(function (object) {\n        if (isGeometry(object)) {\n          _this2.meshes.push({\n            object: object,\n            material: object.material\n          });\n        } else if (isLight(object)) {\n          _this2.lights.push({\n            object: object,\n            intensity: object.intensity\n          });\n        }\n      });\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare() {\n      var _this3 = this;\n      this.lights.forEach(function (light) {\n        return light.object.intensity = 0;\n      });\n      this.meshes.forEach(function (mesh) {\n        return mesh.object.material = _this3.discardMat;\n      });\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.lights.forEach(function (light) {\n        return light.object.intensity = light.intensity;\n      });\n      this.meshes.forEach(function (mesh) {\n        return mesh.object.material = mesh.material;\n      });\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(object) {\n      this.object = object;\n    }\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n      this.averagingWindow.value = blendWindow;\n      this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n      var oldBg = this.scene.background;\n      this.scene.background = null;\n      this.renderer.setRenderTarget(activeMap);\n      this.previousShadowMap.value = inactiveMap.texture;\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera);\n      this.renderer.setRenderTarget(null);\n      this.scene.background = oldBg;\n    }\n  }]);\n  return ProgressiveLightMap;\n}();\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":null,"metadata":{},"sourceType":"module"}