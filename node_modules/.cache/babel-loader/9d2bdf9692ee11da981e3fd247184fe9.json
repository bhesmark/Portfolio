{"ast":null,"code":"import _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { useFrame, useThree, createPortal } from '@react-three/fiber';\nimport * as React from 'react';\nimport { Vector3, Object3D, Vector2 } from 'three';\nimport { MeshLineGeometry, MeshLineMaterial } from 'meshline';\nvar defaults = {\n  width: 0.2,\n  length: 1,\n  decay: 1,\n  local: false,\n  stride: 0,\n  interval: 1\n};\nvar shiftLeft = function shiftLeft(collection) {\n  var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  collection.set(collection.subarray(steps));\n  collection.fill(-Infinity, -steps);\n  return collection;\n};\nfunction useTrail(target, settings) {\n  var _defaults$settings = _objectSpread(_objectSpread({}, defaults), settings),\n    length = _defaults$settings.length,\n    local = _defaults$settings.local,\n    decay = _defaults$settings.decay,\n    interval = _defaults$settings.interval,\n    stride = _defaults$settings.stride;\n  var points = React.useRef();\n  var _React$useState = React.useState(function () {\n      return new Vector3();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    worldPosition = _React$useState2[0];\n  React.useLayoutEffect(function () {\n    if (target) {\n      points.current = Float32Array.from({\n        length: length * 10 * 3\n      }, function (_, i) {\n        return target.position.getComponent(i % 3);\n      });\n    }\n  }, [length, target]);\n  var prevPosition = React.useRef(new Vector3());\n  var frameCount = React.useRef(0);\n  useFrame(function () {\n    if (!target) return;\n    if (!points.current) return;\n    if (frameCount.current === 0) {\n      var newPosition;\n      if (local) {\n        newPosition = target.position;\n      } else {\n        target.getWorldPosition(worldPosition);\n        newPosition = worldPosition;\n      }\n      var steps = 1 * decay;\n      for (var i = 0; i < steps; i++) {\n        if (newPosition.distanceTo(prevPosition.current) < stride) continue;\n        shiftLeft(points.current, 3);\n        points.current.set(newPosition.toArray(), points.current.length - 3);\n      }\n      prevPosition.current.copy(newPosition);\n    }\n    frameCount.current++;\n    frameCount.current = frameCount.current % interval;\n  });\n  return points;\n}\nvar Trail = /*#__PURE__*/React.forwardRef(function (props, forwardRef) {\n  var children = props.children;\n  var _defaults$props = _objectSpread(_objectSpread({}, defaults), props),\n    width = _defaults$props.width,\n    length = _defaults$props.length,\n    decay = _defaults$props.decay,\n    local = _defaults$props.local,\n    stride = _defaults$props.stride,\n    interval = _defaults$props.interval;\n  var _props$color = props.color,\n    color = _props$color === void 0 ? 'hotpink' : _props$color,\n    attenuation = props.attenuation,\n    target = props.target;\n  var size = useThree(function (s) {\n    return s.size;\n  });\n  var scene = useThree(function (s) {\n    return s.scene;\n  });\n  var ref = React.useRef(null);\n  var _React$useState3 = React.useState(null),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    anchor = _React$useState4[0],\n    setAnchor = _React$useState4[1];\n  var points = useTrail(anchor, {\n    length: length,\n    decay: decay,\n    local: local,\n    stride: stride,\n    interval: interval\n  });\n  React.useEffect(function () {\n    var t = (target == null ? void 0 : target.current) || ref.current.children.find(function (o) {\n      return o instanceof Object3D;\n    });\n    if (t) {\n      setAnchor(t);\n    }\n  }, [points, target]);\n  var geo = React.useMemo(function () {\n    return new MeshLineGeometry();\n  }, []);\n  var mat = React.useMemo(function () {\n    var _matOverride;\n    var m = new MeshLineMaterial({\n      lineWidth: 0.1 * width,\n      color: color,\n      sizeAttenuation: 1,\n      resolution: new Vector2(size.width, size.height)\n    }); // Get and apply first <meshLineMaterial /> from children\n\n    var matOverride;\n    if (children) {\n      if (Array.isArray(children)) {\n        matOverride = children.find(function (child) {\n          var c = child;\n          return typeof c.type === 'string' && c.type === 'meshLineMaterial';\n        });\n      } else {\n        var c = children;\n        if (typeof c.type === 'string' && c.type === 'meshLineMaterial') {\n          matOverride = c;\n        }\n      }\n    }\n    if (typeof ((_matOverride = matOverride) == null ? void 0 : _matOverride.props) === 'object') {\n      m.setValues(matOverride.props);\n    }\n    return m;\n  }, [width, color, size, children]);\n  React.useEffect(function () {\n    mat.uniforms.resolution.value.set(size.width, size.height);\n  }, [size]);\n  useFrame(function () {\n    if (!points.current) return;\n    geo.setPoints(points.current, attenuation);\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, createPortal( /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: forwardRef,\n    geometry: geo,\n    material: mat\n  }), scene), /*#__PURE__*/React.createElement(\"group\", {\n    ref: ref\n  }, children));\n});\nexport { Trail, useTrail };","map":null,"metadata":{},"sourceType":"module"}