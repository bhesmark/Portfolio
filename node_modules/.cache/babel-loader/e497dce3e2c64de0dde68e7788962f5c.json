{"ast":null,"code":"import _slicedToArray from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _get from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/baic/Documents/programm/gsrlic/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\nvar HTMLMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(HTMLMesh, _Mesh);\n  var _super = _createSuper(HTMLMesh);\n  function HTMLMesh(dom) {\n    var _this;\n    _classCallCheck(this, HTMLMesh);\n    var texture = new HTMLTexture(dom);\n    var geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    var material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    _this = _super.call(this, geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    _this.addEventListener('mousedown', onEvent);\n    _this.addEventListener('mousemove', onEvent);\n    _this.addEventListener('mouseup', onEvent);\n    _this.addEventListener('click', onEvent);\n    _this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases[\"delete\"](dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n    return _this;\n  }\n  return _createClass(HTMLMesh);\n}(Mesh);\nvar HTMLTexture = /*#__PURE__*/function (_CanvasTexture) {\n  _inherits(HTMLTexture, _CanvasTexture);\n  var _super2 = _createSuper(HTMLTexture);\n  function HTMLTexture(dom) {\n    var _this2;\n    _classCallCheck(this, HTMLTexture);\n    _this2 = _super2.call(this, html2canvas(dom));\n    _this2.dom = dom;\n    _this2.anisotropy = 16;\n    _this2.encoding = sRGBEncoding;\n    _this2.minFilter = LinearFilter;\n    _this2.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    var observer = new MutationObserver(function () {\n      if (!_this2.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        _this2.scheduleUpdate = setTimeout(function () {\n          return _this2.update();\n        }, 16);\n      }\n    });\n    var config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    _this2.observer = observer;\n    return _this2;\n  }\n  _createClass(HTMLTexture, [{\n    key: \"dispatchDOMEvent\",\n    value: function dispatchDOMEvent(event) {\n      if (event.data) {\n        htmlevent(this.dom, event.type, event.data.x, event.data.y);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.image = html2canvas(this.dom);\n      this.needsUpdate = true;\n      this.scheduleUpdate = null;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.observer) {\n        this.observer.disconnect();\n      }\n      this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n      _get(_getPrototypeOf(HTMLTexture.prototype), \"dispose\", this).call(this);\n    }\n  }]);\n  return HTMLTexture;\n}(CanvasTexture); //\nvar canvases = new WeakMap();\nfunction html2canvas(element) {\n  var range = document.createRange();\n  var color = new Color();\n  function Clipper(context) {\n    var clips = [];\n    var isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n      if (clips.length === 0) return;\n      var minX = -Infinity,\n        minY = -Infinity;\n      var maxX = Infinity,\n        maxY = Infinity;\n      for (var i = 0; i < clips.length; i++) {\n        var clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n    return {\n      add: function add(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function remove() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    var borderWidth = style[which + 'Width'];\n    var borderStyle = style[which + 'Style'];\n    var borderColor = style[which + 'Color'];\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element, style) {\n    var x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      var rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      var dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      var _rect = element.getBoundingClientRect();\n      x = _rect.left - offset.left - 0.5;\n      y = _rect.top - offset.top - 0.5;\n      width = _rect.width;\n      height = _rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      var backgroundColor = style.backgroundColor;\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n      var borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      var match = true;\n      var prevBorder = null;\n      for (var _i = 0, _borders = borders; _i < _borders.length; _i++) {\n        var border = _borders[_i];\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        var _width = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = _width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n      if (element instanceof HTMLInputElement) {\n        var accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        var luminance = Math.sqrt(0.299 * Math.pow(color.r, 2) + 0.587 * Math.pow(color.g, 2) + 0.114 * Math.pow(color.b, 2));\n        var accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element.checked) {\n            var currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            var properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element.type === 'range') {\n          var _map = ['min', 'max', 'value'].map(function (property) {\n              return parseFloat(element[property]);\n            }),\n            _map2 = _slicedToArray(_map, 3),\n            min = _map2[0],\n            max = _map2[1],\n            value = _map2[2];\n          var position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n    var isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n    for (var i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  var offset = element.getBoundingClientRect();\n  var canvas = canvases.get(element);\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  var context = canvas.getContext('2d'\n  /*, { alpha: false }*/);\n\n  var clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  var mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  var rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      var _rect2 = element.getBoundingClientRect();\n      if (x > _rect2.left && x < _rect2.right && y > _rect2.top && y < _rect2.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          var _map3 = ['min', 'max'].map(function (property) {\n              return parseFloat(element[property]);\n            }),\n            _map4 = _slicedToArray(_map3, 2),\n            min = _map4[0],\n            max = _map4[1];\n          var width = _rect2.width;\n          var offsetX = x - _rect2.x;\n          var proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n      for (var i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":null,"metadata":{},"sourceType":"module"}