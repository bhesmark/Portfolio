{"ast":null,"code":"var va = function va(e, r) {\n  return function () {\n    return r || e((r = {\n      exports: {}\n    }).exports, r), r.exports;\n  };\n};\nvar Ne = va(function () {});\nString.prototype.codePointAt || function () {\n  var e = function () {\n      try {\n        var t = {},\n          a = Object.defineProperty,\n          n = a(t, t, t) && a;\n      } catch (_unused) {}\n      return n;\n    }(),\n    r = function r(t) {\n      if (this == null) throw TypeError();\n      var a = String(this),\n        n = a.length,\n        s = t ? Number(t) : 0;\n      if (s != s && (s = 0), !(s < 0 || s >= n)) {\n        var i = a.charCodeAt(s),\n          u;\n        return i >= 55296 && i <= 56319 && n > s + 1 && (u = a.charCodeAt(s + 1), u >= 56320 && u <= 57343) ? (i - 55296) * 1024 + u - 56320 + 65536 : i;\n      }\n    };\n  e ? e(String.prototype, \"codePointAt\", {\n    value: r,\n    configurable: !0,\n    writable: !0\n  }) : String.prototype.codePointAt = r;\n}();\nvar Sr = 0,\n  xt = -3;\nfunction Le() {\n  this.table = new Uint16Array(16), this.trans = new Uint16Array(288);\n}\nfunction da(e, r) {\n  this.source = e, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = r, this.destLen = 0, this.ltree = new Le(), this.dtree = new Le();\n}\nvar bt = new Le(),\n  St = new Le(),\n  Tr = new Uint8Array(30),\n  kr = new Uint16Array(30),\n  Tt = new Uint8Array(30),\n  kt = new Uint16Array(30),\n  ga = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n  Br = new Le(),\n  se = new Uint8Array(288 + 32);\nfunction Ft(e, r, t, a) {\n  var n, s;\n  for (n = 0; n < t; ++n) {\n    e[n] = 0;\n  }\n  for (n = 0; n < 30 - t; ++n) {\n    e[n + t] = n / t | 0;\n  }\n  for (s = a, n = 0; n < 30; ++n) {\n    r[n] = s, s += 1 << e[n];\n  }\n}\nfunction ma(e, r) {\n  var t;\n  for (t = 0; t < 7; ++t) {\n    e.table[t] = 0;\n  }\n  for (e.table[7] = 24, e.table[8] = 152, e.table[9] = 112, t = 0; t < 24; ++t) {\n    e.trans[t] = 256 + t;\n  }\n  for (t = 0; t < 144; ++t) {\n    e.trans[24 + t] = t;\n  }\n  for (t = 0; t < 8; ++t) {\n    e.trans[24 + 144 + t] = 280 + t;\n  }\n  for (t = 0; t < 112; ++t) {\n    e.trans[24 + 144 + 8 + t] = 144 + t;\n  }\n  for (t = 0; t < 5; ++t) {\n    r.table[t] = 0;\n  }\n  for (r.table[5] = 32, t = 0; t < 32; ++t) {\n    r.trans[t] = t;\n  }\n}\nvar Ir = new Uint16Array(16);\nfunction ar(e, r, t, a) {\n  var n, s;\n  for (n = 0; n < 16; ++n) {\n    e.table[n] = 0;\n  }\n  for (n = 0; n < a; ++n) {\n    e.table[r[t + n]]++;\n  }\n  for (e.table[0] = 0, s = 0, n = 0; n < 16; ++n) {\n    Ir[n] = s, s += e.table[n];\n  }\n  for (n = 0; n < a; ++n) {\n    r[t + n] && (e.trans[Ir[r[t + n]]++] = n);\n  }\n}\nfunction ya(e) {\n  e.bitcount-- || (e.tag = e.source[e.sourceIndex++], e.bitcount = 7);\n  var r = e.tag & 1;\n  return e.tag >>>= 1, r;\n}\nfunction ie(e, r, t) {\n  if (!r) return t;\n  for (; e.bitcount < 24;) {\n    e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;\n  }\n  var a = e.tag & 65535 >>> 16 - r;\n  return e.tag >>>= r, e.bitcount -= r, a + t;\n}\nfunction hr(e, r) {\n  for (; e.bitcount < 24;) {\n    e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;\n  }\n  var t = 0,\n    a = 0,\n    n = 0,\n    s = e.tag;\n  do {\n    a = 2 * a + (s & 1), s >>>= 1, ++n, t += r.table[n], a -= r.table[n];\n  } while (a >= 0);\n  return e.tag = s, e.bitcount -= n, r.trans[t + a];\n}\nfunction xa(e, r, t) {\n  var a, n, s, i, u, o;\n  for (a = ie(e, 5, 257), n = ie(e, 5, 1), s = ie(e, 4, 4), i = 0; i < 19; ++i) {\n    se[i] = 0;\n  }\n  for (i = 0; i < s; ++i) {\n    var l = ie(e, 3, 0);\n    se[ga[i]] = l;\n  }\n  for (ar(Br, se, 0, 19), u = 0; u < a + n;) {\n    var f = hr(e, Br);\n    switch (f) {\n      case 16:\n        var h = se[u - 1];\n        for (o = ie(e, 2, 3); o; --o) {\n          se[u++] = h;\n        }\n        break;\n      case 17:\n        for (o = ie(e, 3, 3); o; --o) {\n          se[u++] = 0;\n        }\n        break;\n      case 18:\n        for (o = ie(e, 7, 11); o; --o) {\n          se[u++] = 0;\n        }\n        break;\n      default:\n        se[u++] = f;\n        break;\n    }\n  }\n  ar(r, se, 0, a), ar(t, se, a, n);\n}\nfunction Mr(e, r, t) {\n  for (;;) {\n    var a = hr(e, r);\n    if (a === 256) return Sr;\n    if (a < 256) e.dest[e.destLen++] = a;else {\n      var n, s, i, u;\n      for (a -= 257, n = ie(e, Tr[a], kr[a]), s = hr(e, t), i = e.destLen - ie(e, Tt[s], kt[s]), u = i; u < i + n; ++u) {\n        e.dest[e.destLen++] = e.dest[u];\n      }\n    }\n  }\n}\nfunction ba(e) {\n  for (var r, t, a; e.bitcount > 8;) {\n    e.sourceIndex--, e.bitcount -= 8;\n  }\n  if (r = e.source[e.sourceIndex + 1], r = 256 * r + e.source[e.sourceIndex], t = e.source[e.sourceIndex + 3], t = 256 * t + e.source[e.sourceIndex + 2], r !== (~t & 65535)) return xt;\n  for (e.sourceIndex += 4, a = r; a; --a) {\n    e.dest[e.destLen++] = e.source[e.sourceIndex++];\n  }\n  return e.bitcount = 0, Sr;\n}\nfunction Sa(e, r) {\n  var t = new da(e, r),\n    a,\n    n,\n    s;\n  do {\n    switch (a = ya(t), n = ie(t, 2, 0), n) {\n      case 0:\n        s = ba(t);\n        break;\n      case 1:\n        s = Mr(t, bt, St);\n        break;\n      case 2:\n        xa(t, t.ltree, t.dtree), s = Mr(t, t.ltree, t.dtree);\n        break;\n      default:\n        s = xt;\n    }\n    if (s !== Sr) throw new Error(\"Data error\");\n  } while (!a);\n  return t.destLen < t.dest.length ? typeof t.dest.slice == \"function\" ? t.dest.slice(0, t.destLen) : t.dest.subarray(0, t.destLen) : t.dest;\n}\nma(bt, St);\nFt(Tr, kr, 4, 3);\nFt(Tt, kt, 2, 1);\nTr[28] = 0;\nkr[28] = 258;\nvar Ta = Sa;\nfunction Te(e, r, t, a, n) {\n  return Math.pow(1 - n, 3) * e + 3 * Math.pow(1 - n, 2) * n * r + 3 * (1 - n) * Math.pow(n, 2) * t + Math.pow(n, 3) * a;\n}\nfunction pe() {\n  this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;\n}\npe.prototype.isEmpty = function () {\n  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n};\npe.prototype.addPoint = function (e, r) {\n  typeof e == \"number\" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), typeof r == \"number\" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = r, this.y2 = r), r < this.y1 && (this.y1 = r), r > this.y2 && (this.y2 = r));\n};\npe.prototype.addX = function (e) {\n  this.addPoint(e, null);\n};\npe.prototype.addY = function (e) {\n  this.addPoint(null, e);\n};\npe.prototype.addBezier = function (e, r, t, a, n, s, i, u) {\n  var o = [e, r],\n    l = [t, a],\n    f = [n, s],\n    h = [i, u];\n  this.addPoint(e, r), this.addPoint(i, u);\n  for (var p = 0; p <= 1; p++) {\n    var c = 6 * o[p] - 12 * l[p] + 6 * f[p],\n      d = -3 * o[p] + 9 * l[p] - 9 * f[p] + 3 * h[p],\n      x = 3 * l[p] - 3 * o[p];\n    if (d === 0) {\n      if (c === 0) continue;\n      var m = -x / c;\n      0 < m && m < 1 && (p === 0 && this.addX(Te(o[p], l[p], f[p], h[p], m)), p === 1 && this.addY(Te(o[p], l[p], f[p], h[p], m)));\n      continue;\n    }\n    var y = Math.pow(c, 2) - 4 * x * d;\n    if (!(y < 0)) {\n      var C = (-c + Math.sqrt(y)) / (2 * d);\n      0 < C && C < 1 && (p === 0 && this.addX(Te(o[p], l[p], f[p], h[p], C)), p === 1 && this.addY(Te(o[p], l[p], f[p], h[p], C)));\n      var S = (-c - Math.sqrt(y)) / (2 * d);\n      0 < S && S < 1 && (p === 0 && this.addX(Te(o[p], l[p], f[p], h[p], S)), p === 1 && this.addY(Te(o[p], l[p], f[p], h[p], S)));\n    }\n  }\n};\npe.prototype.addQuad = function (e, r, t, a, n, s) {\n  var i = e + .6666666666666666 * (t - e),\n    u = r + 2 / 3 * (a - r),\n    o = i + 1 / 3 * (n - e),\n    l = u + 1 / 3 * (s - r);\n  this.addBezier(e, r, i, u, o, l, n, s);\n};\nfunction P() {\n  this.commands = [], this.fill = \"black\", this.stroke = null, this.strokeWidth = 1;\n}\nP.prototype.moveTo = function (e, r) {\n  this.commands.push({\n    type: \"M\",\n    x: e,\n    y: r\n  });\n};\nP.prototype.lineTo = function (e, r) {\n  this.commands.push({\n    type: \"L\",\n    x: e,\n    y: r\n  });\n};\nP.prototype.curveTo = P.prototype.bezierCurveTo = function (e, r, t, a, n, s) {\n  this.commands.push({\n    type: \"C\",\n    x1: e,\n    y1: r,\n    x2: t,\n    y2: a,\n    x: n,\n    y: s\n  });\n};\nP.prototype.quadTo = P.prototype.quadraticCurveTo = function (e, r, t, a) {\n  this.commands.push({\n    type: \"Q\",\n    x1: e,\n    y1: r,\n    x: t,\n    y: a\n  });\n};\nP.prototype.close = P.prototype.closePath = function () {\n  this.commands.push({\n    type: \"Z\"\n  });\n};\nP.prototype.extend = function (e) {\n  if (e.commands) e = e.commands;else if (e instanceof pe) {\n    var r = e;\n    this.moveTo(r.x1, r.y1), this.lineTo(r.x2, r.y1), this.lineTo(r.x2, r.y2), this.lineTo(r.x1, r.y2), this.close();\n    return;\n  }\n  Array.prototype.push.apply(this.commands, e);\n};\nP.prototype.getBoundingBox = function () {\n  for (var e = new pe(), r = 0, t = 0, a = 0, n = 0, s = 0; s < this.commands.length; s++) {\n    var i = this.commands[s];\n    switch (i.type) {\n      case \"M\":\n        e.addPoint(i.x, i.y), r = a = i.x, t = n = i.y;\n        break;\n      case \"L\":\n        e.addPoint(i.x, i.y), a = i.x, n = i.y;\n        break;\n      case \"Q\":\n        e.addQuad(a, n, i.x1, i.y1, i.x, i.y), a = i.x, n = i.y;\n        break;\n      case \"C\":\n        e.addBezier(a, n, i.x1, i.y1, i.x2, i.y2, i.x, i.y), a = i.x, n = i.y;\n        break;\n      case \"Z\":\n        a = r, n = t;\n        break;\n      default:\n        throw new Error(\"Unexpected path command \" + i.type);\n    }\n  }\n  return e.isEmpty() && e.addPoint(0, 0), e;\n};\nP.prototype.draw = function (e) {\n  e.beginPath();\n  for (var r = 0; r < this.commands.length; r += 1) {\n    var t = this.commands[r];\n    t.type === \"M\" ? e.moveTo(t.x, t.y) : t.type === \"L\" ? e.lineTo(t.x, t.y) : t.type === \"C\" ? e.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y) : t.type === \"Q\" ? e.quadraticCurveTo(t.x1, t.y1, t.x, t.y) : t.type === \"Z\" && e.closePath();\n  }\n  this.fill && (e.fillStyle = this.fill, e.fill()), this.stroke && (e.strokeStyle = this.stroke, e.lineWidth = this.strokeWidth, e.stroke());\n};\nP.prototype.toPathData = function (e) {\n  e = e !== void 0 ? e : 2;\n  function r(i) {\n    return Math.round(i) === i ? \"\" + Math.round(i) : i.toFixed(e);\n  }\n  function t() {\n    for (var i = arguments, u = \"\", o = 0; o < arguments.length; o += 1) {\n      var l = i[o];\n      l >= 0 && o > 0 && (u += \" \"), u += r(l);\n    }\n    return u;\n  }\n  for (var a = \"\", n = 0; n < this.commands.length; n += 1) {\n    var s = this.commands[n];\n    s.type === \"M\" ? a += \"M\" + t(s.x, s.y) : s.type === \"L\" ? a += \"L\" + t(s.x, s.y) : s.type === \"C\" ? a += \"C\" + t(s.x1, s.y1, s.x2, s.y2, s.x, s.y) : s.type === \"Q\" ? a += \"Q\" + t(s.x1, s.y1, s.x, s.y) : s.type === \"Z\" && (a += \"Z\");\n  }\n  return a;\n};\nP.prototype.toSVG = function (e) {\n  var r = '<path d=\"';\n  return r += this.toPathData(e), r += '\"', this.fill && this.fill !== \"black\" && (this.fill === null ? r += ' fill=\"none\"' : r += ' fill=\"' + this.fill + '\"'), this.stroke && (r += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"'), r += \"/>\", r;\n};\nP.prototype.toDOMElement = function (e) {\n  var r = this.toPathData(e),\n    t = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  return t.setAttribute(\"d\", r), t;\n};\nfunction Ut(e) {\n  throw new Error(e);\n}\nfunction Pr(e, r) {\n  e || Ut(r);\n}\nvar U = {\n    fail: Ut,\n    argument: Pr,\n    assert: Pr\n  },\n  Gr = 32768,\n  Nr = 2147483648,\n  Fe = {},\n  g = {},\n  E = {};\nfunction ae(e) {\n  return function () {\n    return e;\n  };\n}\ng.BYTE = function (e) {\n  return U.argument(e >= 0 && e <= 255, \"Byte value should be between 0 and 255.\"), [e];\n};\nE.BYTE = ae(1);\ng.CHAR = function (e) {\n  return [e.charCodeAt(0)];\n};\nE.CHAR = ae(1);\ng.CHARARRAY = function (e) {\n  typeof e > \"u\" && (e = \"\", console.warn(\"Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.\"));\n  for (var r = [], t = 0; t < e.length; t += 1) {\n    r[t] = e.charCodeAt(t);\n  }\n  return r;\n};\nE.CHARARRAY = function (e) {\n  return typeof e > \"u\" ? 0 : e.length;\n};\ng.USHORT = function (e) {\n  return [e >> 8 & 255, e & 255];\n};\nE.USHORT = ae(2);\ng.SHORT = function (e) {\n  return e >= Gr && (e = -(2 * Gr - e)), [e >> 8 & 255, e & 255];\n};\nE.SHORT = ae(2);\ng.UINT24 = function (e) {\n  return [e >> 16 & 255, e >> 8 & 255, e & 255];\n};\nE.UINT24 = ae(3);\ng.ULONG = function (e) {\n  return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];\n};\nE.ULONG = ae(4);\ng.LONG = function (e) {\n  return e >= Nr && (e = -(2 * Nr - e)), [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];\n};\nE.LONG = ae(4);\ng.FIXED = g.ULONG;\nE.FIXED = E.ULONG;\ng.FWORD = g.SHORT;\nE.FWORD = E.SHORT;\ng.UFWORD = g.USHORT;\nE.UFWORD = E.USHORT;\ng.LONGDATETIME = function (e) {\n  return [0, 0, 0, 0, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];\n};\nE.LONGDATETIME = ae(8);\ng.TAG = function (e) {\n  return U.argument(e.length === 4, \"Tag should be exactly 4 ASCII characters.\"), [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)];\n};\nE.TAG = ae(4);\ng.Card8 = g.BYTE;\nE.Card8 = E.BYTE;\ng.Card16 = g.USHORT;\nE.Card16 = E.USHORT;\ng.OffSize = g.BYTE;\nE.OffSize = E.BYTE;\ng.SID = g.USHORT;\nE.SID = E.USHORT;\ng.NUMBER = function (e) {\n  return e >= -107 && e <= 107 ? [e + 139] : e >= 108 && e <= 1131 ? (e = e - 108, [(e >> 8) + 247, e & 255]) : e >= -1131 && e <= -108 ? (e = -e - 108, [(e >> 8) + 251, e & 255]) : e >= -32768 && e <= 32767 ? g.NUMBER16(e) : g.NUMBER32(e);\n};\nE.NUMBER = function (e) {\n  return g.NUMBER(e).length;\n};\ng.NUMBER16 = function (e) {\n  return [28, e >> 8 & 255, e & 255];\n};\nE.NUMBER16 = ae(3);\ng.NUMBER32 = function (e) {\n  return [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255];\n};\nE.NUMBER32 = ae(5);\ng.REAL = function (e) {\n  var r = e.toString(),\n    t = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(r);\n  if (t) {\n    var a = parseFloat(\"1e\" + ((t[2] ? +t[2] : 0) + t[1].length));\n    r = (Math.round(e * a) / a).toString();\n  }\n  for (var n = \"\", s = 0, i = r.length; s < i; s += 1) {\n    var u = r[s];\n    u === \"e\" ? n += r[++s] === \"-\" ? \"c\" : \"b\" : u === \".\" ? n += \"a\" : u === \"-\" ? n += \"e\" : n += u;\n  }\n  n += n.length & 1 ? \"f\" : \"ff\";\n  for (var o = [30], l = 0, f = n.length; l < f; l += 2) {\n    o.push(parseInt(n.substr(l, 2), 16));\n  }\n  return o;\n};\nE.REAL = function (e) {\n  return g.REAL(e).length;\n};\ng.NAME = g.CHARARRAY;\nE.NAME = E.CHARARRAY;\ng.STRING = g.CHARARRAY;\nE.STRING = E.CHARARRAY;\nFe.UTF8 = function (e, r, t) {\n  for (var a = [], n = t, s = 0; s < n; s++, r += 1) {\n    a[s] = e.getUint8(r);\n  }\n  return String.fromCharCode.apply(null, a);\n};\nFe.UTF16 = function (e, r, t) {\n  for (var a = [], n = t / 2, s = 0; s < n; s++, r += 2) {\n    a[s] = e.getUint16(r);\n  }\n  return String.fromCharCode.apply(null, a);\n};\ng.UTF16 = function (e) {\n  for (var r = [], t = 0; t < e.length; t += 1) {\n    var a = e.charCodeAt(t);\n    r[r.length] = a >> 8 & 255, r[r.length] = a & 255;\n  }\n  return r;\n};\nE.UTF16 = function (e) {\n  return e.length * 2;\n};\nvar cr = {\n  \"x-mac-croatian\": \"\\xC4\\xC5\\xC7\\xC9\\xD1\\xD6\\xDC\\xE1\\xE0\\xE2\\xE4\\xE3\\xE5\\xE7\\xE9\\xE8\\xEA\\xEB\\xED\\xEC\\xEE\\xEF\\xF1\\xF3\\xF2\\xF4\\xF6\\xF5\\xFA\\xF9\\xFB\\xFC\\u2020\\xB0\\xA2\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\u0160\\u2122\\xB4\\xA8\\u2260\\u017D\\xD8\\u221E\\xB1\\u2264\\u2265\\u2206\\xB5\\u2202\\u2211\\u220F\\u0161\\u222B\\xAA\\xBA\\u03A9\\u017E\\xF8\\xBF\\xA1\\xAC\\u221A\\u0192\\u2248\\u0106\\xAB\\u010C\\u2026\\xA0\\xC0\\xC3\\xD5\\u0152\\u0153\\u0110\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u25CA\\uF8FF\\xA9\\u2044\\u20AC\\u2039\\u203A\\xC6\\xBB\\u2013\\xB7\\u201A\\u201E\\u2030\\xC2\\u0107\\xC1\\u010D\\xC8\\xCD\\xCE\\xCF\\xCC\\xD3\\xD4\\u0111\\xD2\\xDA\\xDB\\xD9\\u0131\\u02C6\\u02DC\\xAF\\u03C0\\xCB\\u02DA\\xB8\\xCA\\xE6\\u02C7\",\n  \"x-mac-cyrillic\": \"\\u0410\\u0411\\u0412\\u0413\\u0414\\u0415\\u0416\\u0417\\u0418\\u0419\\u041A\\u041B\\u041C\\u041D\\u041E\\u041F\\u0420\\u0421\\u0422\\u0423\\u0424\\u0425\\u0426\\u0427\\u0428\\u0429\\u042A\\u042B\\u042C\\u042D\\u042E\\u042F\\u2020\\xB0\\u0490\\xA3\\xA7\\u2022\\xB6\\u0406\\xAE\\xA9\\u2122\\u0402\\u0452\\u2260\\u0403\\u0453\\u221E\\xB1\\u2264\\u2265\\u0456\\xB5\\u0491\\u0408\\u0404\\u0454\\u0407\\u0457\\u0409\\u0459\\u040A\\u045A\\u0458\\u0405\\xAC\\u221A\\u0192\\u2248\\u2206\\xAB\\xBB\\u2026\\xA0\\u040B\\u045B\\u040C\\u045C\\u0455\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u201E\\u040E\\u045E\\u040F\\u045F\\u2116\\u0401\\u0451\\u044F\\u0430\\u0431\\u0432\\u0433\\u0434\\u0435\\u0436\\u0437\\u0438\\u0439\\u043A\\u043B\\u043C\\u043D\\u043E\\u043F\\u0440\\u0441\\u0442\\u0443\\u0444\\u0445\\u0446\\u0447\\u0448\\u0449\\u044A\\u044B\\u044C\\u044D\\u044E\",\n  \"x-mac-gaelic\": \"\\xC4\\xC5\\xC7\\xC9\\xD1\\xD6\\xDC\\xE1\\xE0\\xE2\\xE4\\xE3\\xE5\\xE7\\xE9\\xE8\\xEA\\xEB\\xED\\xEC\\xEE\\xEF\\xF1\\xF3\\xF2\\xF4\\xF6\\xF5\\xFA\\xF9\\xFB\\xFC\\u2020\\xB0\\xA2\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\xA9\\u2122\\xB4\\xA8\\u2260\\xC6\\xD8\\u1E02\\xB1\\u2264\\u2265\\u1E03\\u010A\\u010B\\u1E0A\\u1E0B\\u1E1E\\u1E1F\\u0120\\u0121\\u1E40\\xE6\\xF8\\u1E41\\u1E56\\u1E57\\u027C\\u0192\\u017F\\u1E60\\xAB\\xBB\\u2026\\xA0\\xC0\\xC3\\xD5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\u1E61\\u1E9B\\xFF\\u0178\\u1E6A\\u20AC\\u2039\\u203A\\u0176\\u0177\\u1E6B\\xB7\\u1EF2\\u1EF3\\u204A\\xC2\\xCA\\xC1\\xCB\\xC8\\xCD\\xCE\\xCF\\xCC\\xD3\\xD4\\u2663\\xD2\\xDA\\xDB\\xD9\\u0131\\xDD\\xFD\\u0174\\u0175\\u1E84\\u1E85\\u1E80\\u1E81\\u1E82\\u1E83\",\n  \"x-mac-greek\": \"\\xC4\\xB9\\xB2\\xC9\\xB3\\xD6\\xDC\\u0385\\xE0\\xE2\\xE4\\u0384\\xA8\\xE7\\xE9\\xE8\\xEA\\xEB\\xA3\\u2122\\xEE\\xEF\\u2022\\xBD\\u2030\\xF4\\xF6\\xA6\\u20AC\\xF9\\xFB\\xFC\\u2020\\u0393\\u0394\\u0398\\u039B\\u039E\\u03A0\\xDF\\xAE\\xA9\\u03A3\\u03AA\\xA7\\u2260\\xB0\\xB7\\u0391\\xB1\\u2264\\u2265\\xA5\\u0392\\u0395\\u0396\\u0397\\u0399\\u039A\\u039C\\u03A6\\u03AB\\u03A8\\u03A9\\u03AC\\u039D\\xAC\\u039F\\u03A1\\u2248\\u03A4\\xAB\\xBB\\u2026\\xA0\\u03A5\\u03A7\\u0386\\u0388\\u0153\\u2013\\u2015\\u201C\\u201D\\u2018\\u2019\\xF7\\u0389\\u038A\\u038C\\u038E\\u03AD\\u03AE\\u03AF\\u03CC\\u038F\\u03CD\\u03B1\\u03B2\\u03C8\\u03B4\\u03B5\\u03C6\\u03B3\\u03B7\\u03B9\\u03BE\\u03BA\\u03BB\\u03BC\\u03BD\\u03BF\\u03C0\\u03CE\\u03C1\\u03C3\\u03C4\\u03B8\\u03C9\\u03C2\\u03C7\\u03C5\\u03B6\\u03CA\\u03CB\\u0390\\u03B0\\xAD\",\n  \"x-mac-icelandic\": \"\\xC4\\xC5\\xC7\\xC9\\xD1\\xD6\\xDC\\xE1\\xE0\\xE2\\xE4\\xE3\\xE5\\xE7\\xE9\\xE8\\xEA\\xEB\\xED\\xEC\\xEE\\xEF\\xF1\\xF3\\xF2\\xF4\\xF6\\xF5\\xFA\\xF9\\xFB\\xFC\\xDD\\xB0\\xA2\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\xA9\\u2122\\xB4\\xA8\\u2260\\xC6\\xD8\\u221E\\xB1\\u2264\\u2265\\xA5\\xB5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xAA\\xBA\\u03A9\\xE6\\xF8\\xBF\\xA1\\xAC\\u221A\\u0192\\u2248\\u2206\\xAB\\xBB\\u2026\\xA0\\xC0\\xC3\\xD5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u25CA\\xFF\\u0178\\u2044\\u20AC\\xD0\\xF0\\xDE\\xFE\\xFD\\xB7\\u201A\\u201E\\u2030\\xC2\\xCA\\xC1\\xCB\\xC8\\xCD\\xCE\\xCF\\xCC\\xD3\\xD4\\uF8FF\\xD2\\xDA\\xDB\\xD9\\u0131\\u02C6\\u02DC\\xAF\\u02D8\\u02D9\\u02DA\\xB8\\u02DD\\u02DB\\u02C7\",\n  \"x-mac-inuit\": \"\\u1403\\u1404\\u1405\\u1406\\u140A\\u140B\\u1431\\u1432\\u1433\\u1434\\u1438\\u1439\\u1449\\u144E\\u144F\\u1450\\u1451\\u1455\\u1456\\u1466\\u146D\\u146E\\u146F\\u1470\\u1472\\u1473\\u1483\\u148B\\u148C\\u148D\\u148E\\u1490\\u1491\\xB0\\u14A1\\u14A5\\u14A6\\u2022\\xB6\\u14A7\\xAE\\xA9\\u2122\\u14A8\\u14AA\\u14AB\\u14BB\\u14C2\\u14C3\\u14C4\\u14C5\\u14C7\\u14C8\\u14D0\\u14EF\\u14F0\\u14F1\\u14F2\\u14F4\\u14F5\\u1505\\u14D5\\u14D6\\u14D7\\u14D8\\u14DA\\u14DB\\u14EA\\u1528\\u1529\\u152A\\u152B\\u152D\\u2026\\xA0\\u152E\\u153E\\u1555\\u1556\\u1557\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\u1558\\u1559\\u155A\\u155D\\u1546\\u1547\\u1548\\u1549\\u154B\\u154C\\u1550\\u157F\\u1580\\u1581\\u1582\\u1583\\u1584\\u1585\\u158F\\u1590\\u1591\\u1592\\u1593\\u1594\\u1595\\u1671\\u1672\\u1673\\u1674\\u1675\\u1676\\u1596\\u15A0\\u15A1\\u15A2\\u15A3\\u15A4\\u15A5\\u15A6\\u157C\\u0141\\u0142\",\n  \"x-mac-ce\": \"\\xC4\\u0100\\u0101\\xC9\\u0104\\xD6\\xDC\\xE1\\u0105\\u010C\\xE4\\u010D\\u0106\\u0107\\xE9\\u0179\\u017A\\u010E\\xED\\u010F\\u0112\\u0113\\u0116\\xF3\\u0117\\xF4\\xF6\\xF5\\xFA\\u011A\\u011B\\xFC\\u2020\\xB0\\u0118\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\xA9\\u2122\\u0119\\xA8\\u2260\\u0123\\u012E\\u012F\\u012A\\u2264\\u2265\\u012B\\u0136\\u2202\\u2211\\u0142\\u013B\\u013C\\u013D\\u013E\\u0139\\u013A\\u0145\\u0146\\u0143\\xAC\\u221A\\u0144\\u0147\\u2206\\xAB\\xBB\\u2026\\xA0\\u0148\\u0150\\xD5\\u0151\\u014C\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u25CA\\u014D\\u0154\\u0155\\u0158\\u2039\\u203A\\u0159\\u0156\\u0157\\u0160\\u201A\\u201E\\u0161\\u015A\\u015B\\xC1\\u0164\\u0165\\xCD\\u017D\\u017E\\u016A\\xD3\\xD4\\u016B\\u016E\\xDA\\u016F\\u0170\\u0171\\u0172\\u0173\\xDD\\xFD\\u0137\\u017B\\u0141\\u017C\\u0122\\u02C7\",\n  macintosh: \"\\xC4\\xC5\\xC7\\xC9\\xD1\\xD6\\xDC\\xE1\\xE0\\xE2\\xE4\\xE3\\xE5\\xE7\\xE9\\xE8\\xEA\\xEB\\xED\\xEC\\xEE\\xEF\\xF1\\xF3\\xF2\\xF4\\xF6\\xF5\\xFA\\xF9\\xFB\\xFC\\u2020\\xB0\\xA2\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\xA9\\u2122\\xB4\\xA8\\u2260\\xC6\\xD8\\u221E\\xB1\\u2264\\u2265\\xA5\\xB5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xAA\\xBA\\u03A9\\xE6\\xF8\\xBF\\xA1\\xAC\\u221A\\u0192\\u2248\\u2206\\xAB\\xBB\\u2026\\xA0\\xC0\\xC3\\xD5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u25CA\\xFF\\u0178\\u2044\\u20AC\\u2039\\u203A\\uFB01\\uFB02\\u2021\\xB7\\u201A\\u201E\\u2030\\xC2\\xCA\\xC1\\xCB\\xC8\\xCD\\xCE\\xCF\\xCC\\xD3\\xD4\\uF8FF\\xD2\\xDA\\xDB\\xD9\\u0131\\u02C6\\u02DC\\xAF\\u02D8\\u02D9\\u02DA\\xB8\\u02DD\\u02DB\\u02C7\",\n  \"x-mac-romanian\": \"\\xC4\\xC5\\xC7\\xC9\\xD1\\xD6\\xDC\\xE1\\xE0\\xE2\\xE4\\xE3\\xE5\\xE7\\xE9\\xE8\\xEA\\xEB\\xED\\xEC\\xEE\\xEF\\xF1\\xF3\\xF2\\xF4\\xF6\\xF5\\xFA\\xF9\\xFB\\xFC\\u2020\\xB0\\xA2\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\xA9\\u2122\\xB4\\xA8\\u2260\\u0102\\u0218\\u221E\\xB1\\u2264\\u2265\\xA5\\xB5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xAA\\xBA\\u03A9\\u0103\\u0219\\xBF\\xA1\\xAC\\u221A\\u0192\\u2248\\u2206\\xAB\\xBB\\u2026\\xA0\\xC0\\xC3\\xD5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u25CA\\xFF\\u0178\\u2044\\u20AC\\u2039\\u203A\\u021A\\u021B\\u2021\\xB7\\u201A\\u201E\\u2030\\xC2\\xCA\\xC1\\xCB\\xC8\\xCD\\xCE\\xCF\\xCC\\xD3\\xD4\\uF8FF\\xD2\\xDA\\xDB\\xD9\\u0131\\u02C6\\u02DC\\xAF\\u02D8\\u02D9\\u02DA\\xB8\\u02DD\\u02DB\\u02C7\",\n  \"x-mac-turkish\": \"\\xC4\\xC5\\xC7\\xC9\\xD1\\xD6\\xDC\\xE1\\xE0\\xE2\\xE4\\xE3\\xE5\\xE7\\xE9\\xE8\\xEA\\xEB\\xED\\xEC\\xEE\\xEF\\xF1\\xF3\\xF2\\xF4\\xF6\\xF5\\xFA\\xF9\\xFB\\xFC\\u2020\\xB0\\xA2\\xA3\\xA7\\u2022\\xB6\\xDF\\xAE\\xA9\\u2122\\xB4\\xA8\\u2260\\xC6\\xD8\\u221E\\xB1\\u2264\\u2265\\xA5\\xB5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xAA\\xBA\\u03A9\\xE6\\xF8\\xBF\\xA1\\xAC\\u221A\\u0192\\u2248\\u2206\\xAB\\xBB\\u2026\\xA0\\xC0\\xC3\\xD5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xF7\\u25CA\\xFF\\u0178\\u011E\\u011F\\u0130\\u0131\\u015E\\u015F\\u2021\\xB7\\u201A\\u201E\\u2030\\xC2\\xCA\\xC1\\xCB\\xC8\\xCD\\xCE\\xCF\\xCC\\xD3\\xD4\\uF8FF\\xD2\\xDA\\xDB\\xD9\\uF8A0\\u02C6\\u02DC\\xAF\\u02D8\\u02D9\\u02DA\\xB8\\u02DD\\u02DB\\u02C7\"\n};\nFe.MACSTRING = function (e, r, t, a) {\n  var n = cr[a];\n  if (n !== void 0) {\n    for (var s = \"\", i = 0; i < t; i++) {\n      var u = e.getUint8(r + i);\n      u <= 127 ? s += String.fromCharCode(u) : s += n[u & 127];\n    }\n    return s;\n  }\n};\nvar He = typeof WeakMap == \"function\" && new WeakMap(),\n  ze,\n  ka = function ka(e) {\n    if (!ze) {\n      ze = {};\n      for (var r in cr) {\n        ze[r] = new String(r);\n      }\n    }\n    var t = ze[e];\n    if (t !== void 0) {\n      if (He) {\n        var a = He.get(t);\n        if (a !== void 0) return a;\n      }\n      var n = cr[e];\n      if (n !== void 0) {\n        for (var s = {}, i = 0; i < n.length; i++) {\n          s[n.charCodeAt(i)] = i + 128;\n        }\n        return He && He.set(t, s), s;\n      }\n    }\n  };\ng.MACSTRING = function (e, r) {\n  var t = ka(r);\n  if (t !== void 0) {\n    for (var a = [], n = 0; n < e.length; n++) {\n      var s = e.charCodeAt(n);\n      if (s >= 128 && (s = t[s], s === void 0)) return;\n      a[n] = s;\n    }\n    return a;\n  }\n};\nE.MACSTRING = function (e, r) {\n  var t = g.MACSTRING(e, r);\n  return t !== void 0 ? t.length : 0;\n};\nfunction vr(e) {\n  return e >= -128 && e <= 127;\n}\nfunction Fa(e, r, t) {\n  for (var a = 0, n = e.length; r < n && a < 64 && e[r] === 0;) {\n    ++r, ++a;\n  }\n  return t.push(128 | a - 1), r;\n}\nfunction Ua(e, r, t) {\n  for (var a = 0, n = e.length, s = r; s < n && a < 64;) {\n    var i = e[s];\n    if (!vr(i) || i === 0 && s + 1 < n && e[s + 1] === 0) break;\n    ++s, ++a;\n  }\n  t.push(a - 1);\n  for (var u = r; u < s; ++u) {\n    t.push(e[u] + 256 & 255);\n  }\n  return s;\n}\nfunction Ca(e, r, t) {\n  for (var a = 0, n = e.length, s = r; s < n && a < 64;) {\n    var i = e[s];\n    if (i === 0 || vr(i) && s + 1 < n && vr(e[s + 1])) break;\n    ++s, ++a;\n  }\n  t.push(64 | a - 1);\n  for (var u = r; u < s; ++u) {\n    var o = e[u];\n    t.push(o + 65536 >> 8 & 255, o + 256 & 255);\n  }\n  return s;\n}\ng.VARDELTAS = function (e) {\n  for (var r = 0, t = []; r < e.length;) {\n    var a = e[r];\n    a === 0 ? r = Fa(e, r, t) : a >= -128 && a <= 127 ? r = Ua(e, r, t) : r = Ca(e, r, t);\n  }\n  return t;\n};\ng.INDEX = function (e) {\n  for (var r = 1, t = [r], a = [], n = 0; n < e.length; n += 1) {\n    var s = g.OBJECT(e[n]);\n    Array.prototype.push.apply(a, s), r += s.length, t.push(r);\n  }\n  if (a.length === 0) return [0, 0];\n  for (var i = [], u = 1 + Math.floor(Math.log(r) / Math.log(2)) / 8 | 0, o = [void 0, g.BYTE, g.USHORT, g.UINT24, g.ULONG][u], l = 0; l < t.length; l += 1) {\n    var f = o(t[l]);\n    Array.prototype.push.apply(i, f);\n  }\n  return Array.prototype.concat(g.Card16(e.length), g.OffSize(u), i, a);\n};\nE.INDEX = function (e) {\n  return g.INDEX(e).length;\n};\ng.DICT = function (e) {\n  for (var r = [], t = Object.keys(e), a = t.length, n = 0; n < a; n += 1) {\n    var s = parseInt(t[n], 0),\n      i = e[s];\n    r = r.concat(g.OPERAND(i.value, i.type)), r = r.concat(g.OPERATOR(s));\n  }\n  return r;\n};\nE.DICT = function (e) {\n  return g.DICT(e).length;\n};\ng.OPERATOR = function (e) {\n  return e < 1200 ? [e] : [12, e - 1200];\n};\ng.OPERAND = function (e, r) {\n  var t = [];\n  if (Array.isArray(r)) for (var a = 0; a < r.length; a += 1) {\n    U.argument(e.length === r.length, \"Not enough arguments given for type\" + r), t = t.concat(g.OPERAND(e[a], r[a]));\n  } else if (r === \"SID\") t = t.concat(g.NUMBER(e));else if (r === \"offset\") t = t.concat(g.NUMBER32(e));else if (r === \"number\") t = t.concat(g.NUMBER(e));else if (r === \"real\") t = t.concat(g.REAL(e));else throw new Error(\"Unknown operand type \" + r);\n  return t;\n};\ng.OP = g.BYTE;\nE.OP = E.BYTE;\nvar We = typeof WeakMap == \"function\" && new WeakMap();\ng.CHARSTRING = function (e) {\n  if (We) {\n    var r = We.get(e);\n    if (r !== void 0) return r;\n  }\n  for (var t = [], a = e.length, n = 0; n < a; n += 1) {\n    var s = e[n];\n    t = t.concat(g[s.type](s.value));\n  }\n  return We && We.set(e, t), t;\n};\nE.CHARSTRING = function (e) {\n  return g.CHARSTRING(e).length;\n};\ng.OBJECT = function (e) {\n  var r = g[e.type];\n  return U.argument(r !== void 0, \"No encoding function for type \" + e.type), r(e.value);\n};\nE.OBJECT = function (e) {\n  var r = E[e.type];\n  return U.argument(r !== void 0, \"No sizeOf function for type \" + e.type), r(e.value);\n};\ng.TABLE = function (e) {\n  for (var r = [], t = e.fields.length, a = [], n = [], s = 0; s < t; s += 1) {\n    var i = e.fields[s],\n      u = g[i.type];\n    U.argument(u !== void 0, \"No encoding function for field type \" + i.type + \" (\" + i.name + \")\");\n    var o = e[i.name];\n    o === void 0 && (o = i.value);\n    var l = u(o);\n    i.type === \"TABLE\" ? (n.push(r.length), r = r.concat([0, 0]), a.push(l)) : r = r.concat(l);\n  }\n  for (var f = 0; f < a.length; f += 1) {\n    var h = n[f],\n      p = r.length;\n    U.argument(p < 65536, \"Table \" + e.tableName + \" too big.\"), r[h] = p >> 8, r[h + 1] = p & 255, r = r.concat(a[f]);\n  }\n  return r;\n};\nE.TABLE = function (e) {\n  for (var r = 0, t = e.fields.length, a = 0; a < t; a += 1) {\n    var n = e.fields[a],\n      s = E[n.type];\n    U.argument(s !== void 0, \"No sizeOf function for field type \" + n.type + \" (\" + n.name + \")\");\n    var i = e[n.name];\n    i === void 0 && (i = n.value), r += s(i), n.type === \"TABLE\" && (r += 2);\n  }\n  return r;\n};\ng.RECORD = g.TABLE;\nE.RECORD = E.TABLE;\ng.LITERAL = function (e) {\n  return e;\n};\nE.LITERAL = function (e) {\n  return e.length;\n};\nfunction z(e, r, t) {\n  if (r.length && (r[0].name !== \"coverageFormat\" || r[0].value === 1)) for (var a = 0; a < r.length; a += 1) {\n    var n = r[a];\n    this[n.name] = n.value;\n  }\n  if (this.tableName = e, this.fields = r, t) for (var s = Object.keys(t), i = 0; i < s.length; i += 1) {\n    var u = s[i],\n      o = t[u];\n    this[u] !== void 0 && (this[u] = o);\n  }\n}\nz.prototype.encode = function () {\n  return g.TABLE(this);\n};\nz.prototype.sizeOf = function () {\n  return E.TABLE(this);\n};\nfunction Re(e, r, t) {\n  t === void 0 && (t = r.length);\n  var a = new Array(r.length + 1);\n  a[0] = {\n    name: e + \"Count\",\n    type: \"USHORT\",\n    value: t\n  };\n  for (var n = 0; n < r.length; n++) {\n    a[n + 1] = {\n      name: e + n,\n      type: \"USHORT\",\n      value: r[n]\n    };\n  }\n  return a;\n}\nfunction dr(e, r, t) {\n  var a = r.length,\n    n = new Array(a + 1);\n  n[0] = {\n    name: e + \"Count\",\n    type: \"USHORT\",\n    value: a\n  };\n  for (var s = 0; s < a; s++) {\n    n[s + 1] = {\n      name: e + s,\n      type: \"TABLE\",\n      value: t(r[s], s)\n    };\n  }\n  return n;\n}\nfunction we(e, r, t) {\n  var a = r.length,\n    n = [];\n  n[0] = {\n    name: e + \"Count\",\n    type: \"USHORT\",\n    value: a\n  };\n  for (var s = 0; s < a; s++) {\n    n = n.concat(t(r[s], s));\n  }\n  return n;\n}\nfunction Ye(e) {\n  e.format === 1 ? z.call(this, \"coverageTable\", [{\n    name: \"coverageFormat\",\n    type: \"USHORT\",\n    value: 1\n  }].concat(Re(\"glyph\", e.glyphs))) : e.format === 2 ? z.call(this, \"coverageTable\", [{\n    name: \"coverageFormat\",\n    type: \"USHORT\",\n    value: 2\n  }].concat(we(\"rangeRecord\", e.ranges, function (r) {\n    return [{\n      name: \"startGlyphID\",\n      type: \"USHORT\",\n      value: r.start\n    }, {\n      name: \"endGlyphID\",\n      type: \"USHORT\",\n      value: r.end\n    }, {\n      name: \"startCoverageIndex\",\n      type: \"USHORT\",\n      value: r.index\n    }];\n  }))) : U.assert(!1, \"Coverage format must be 1 or 2.\");\n}\nYe.prototype = Object.create(z.prototype);\nYe.prototype.constructor = Ye;\nfunction Ze(e) {\n  z.call(this, \"scriptListTable\", we(\"scriptRecord\", e, function (r, t) {\n    var a = r.script,\n      n = a.defaultLangSys;\n    return U.assert(!!n, \"Unable to write GSUB: script \" + r.tag + \" has no default language system.\"), [{\n      name: \"scriptTag\" + t,\n      type: \"TAG\",\n      value: r.tag\n    }, {\n      name: \"script\" + t,\n      type: \"TABLE\",\n      value: new z(\"scriptTable\", [{\n        name: \"defaultLangSys\",\n        type: \"TABLE\",\n        value: new z(\"defaultLangSys\", [{\n          name: \"lookupOrder\",\n          type: \"USHORT\",\n          value: 0\n        }, {\n          name: \"reqFeatureIndex\",\n          type: \"USHORT\",\n          value: n.reqFeatureIndex\n        }].concat(Re(\"featureIndex\", n.featureIndexes)))\n      }].concat(we(\"langSys\", a.langSysRecords, function (s, i) {\n        var u = s.langSys;\n        return [{\n          name: \"langSysTag\" + i,\n          type: \"TAG\",\n          value: s.tag\n        }, {\n          name: \"langSys\" + i,\n          type: \"TABLE\",\n          value: new z(\"langSys\", [{\n            name: \"lookupOrder\",\n            type: \"USHORT\",\n            value: 0\n          }, {\n            name: \"reqFeatureIndex\",\n            type: \"USHORT\",\n            value: u.reqFeatureIndex\n          }].concat(Re(\"featureIndex\", u.featureIndexes)))\n        }];\n      })))\n    }];\n  }));\n}\nZe.prototype = Object.create(z.prototype);\nZe.prototype.constructor = Ze;\nfunction Qe(e) {\n  z.call(this, \"featureListTable\", we(\"featureRecord\", e, function (r, t) {\n    var a = r.feature;\n    return [{\n      name: \"featureTag\" + t,\n      type: \"TAG\",\n      value: r.tag\n    }, {\n      name: \"feature\" + t,\n      type: \"TABLE\",\n      value: new z(\"featureTable\", [{\n        name: \"featureParams\",\n        type: \"USHORT\",\n        value: a.featureParams\n      }].concat(Re(\"lookupListIndex\", a.lookupListIndexes)))\n    }];\n  }));\n}\nQe.prototype = Object.create(z.prototype);\nQe.prototype.constructor = Qe;\nfunction Ke(e, r) {\n  z.call(this, \"lookupListTable\", dr(\"lookup\", e, function (t) {\n    var a = r[t.lookupType];\n    return U.assert(!!a, \"Unable to write GSUB lookup type \" + t.lookupType + \" tables.\"), new z(\"lookupTable\", [{\n      name: \"lookupType\",\n      type: \"USHORT\",\n      value: t.lookupType\n    }, {\n      name: \"lookupFlag\",\n      type: \"USHORT\",\n      value: t.lookupFlag\n    }].concat(dr(\"subtable\", t.subtables, a)));\n  }));\n}\nKe.prototype = Object.create(z.prototype);\nKe.prototype.constructor = Ke;\nvar b = {\n  Table: z,\n  Record: z,\n  Coverage: Ye,\n  ScriptList: Ze,\n  FeatureList: Qe,\n  LookupList: Ke,\n  ushortList: Re,\n  tableList: dr,\n  recordList: we\n};\nfunction Hr(e, r) {\n  return e.getUint8(r);\n}\nfunction Je(e, r) {\n  return e.getUint16(r, !1);\n}\nfunction Ea(e, r) {\n  return e.getInt16(r, !1);\n}\nfunction Fr(e, r) {\n  return e.getUint32(r, !1);\n}\nfunction Ct(e, r) {\n  var t = e.getInt16(r, !1),\n    a = e.getUint16(r + 2, !1);\n  return t + a / 65535;\n}\nfunction Oa(e, r) {\n  for (var t = \"\", a = r; a < r + 4; a += 1) {\n    t += String.fromCharCode(e.getInt8(a));\n  }\n  return t;\n}\nfunction La(e, r, t) {\n  for (var a = 0, n = 0; n < t; n += 1) {\n    a <<= 8, a += e.getUint8(r + n);\n  }\n  return a;\n}\nfunction Ra(e, r, t) {\n  for (var a = [], n = r; n < t; n += 1) {\n    a.push(e.getUint8(n));\n  }\n  return a;\n}\nfunction wa(e) {\n  for (var r = \"\", t = 0; t < e.length; t += 1) {\n    r += String.fromCharCode(e[t]);\n  }\n  return r;\n}\nvar Da = {\n  \"byte\": 1,\n  uShort: 2,\n  \"short\": 2,\n  uLong: 4,\n  fixed: 4,\n  longDateTime: 8,\n  tag: 4\n};\nfunction v(e, r) {\n  this.data = e, this.offset = r, this.relativeOffset = 0;\n}\nv.prototype.parseByte = function () {\n  var e = this.data.getUint8(this.offset + this.relativeOffset);\n  return this.relativeOffset += 1, e;\n};\nv.prototype.parseChar = function () {\n  var e = this.data.getInt8(this.offset + this.relativeOffset);\n  return this.relativeOffset += 1, e;\n};\nv.prototype.parseCard8 = v.prototype.parseByte;\nv.prototype.parseUShort = function () {\n  var e = this.data.getUint16(this.offset + this.relativeOffset);\n  return this.relativeOffset += 2, e;\n};\nv.prototype.parseCard16 = v.prototype.parseUShort;\nv.prototype.parseSID = v.prototype.parseUShort;\nv.prototype.parseOffset16 = v.prototype.parseUShort;\nv.prototype.parseShort = function () {\n  var e = this.data.getInt16(this.offset + this.relativeOffset);\n  return this.relativeOffset += 2, e;\n};\nv.prototype.parseF2Dot14 = function () {\n  var e = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n  return this.relativeOffset += 2, e;\n};\nv.prototype.parseULong = function () {\n  var e = Fr(this.data, this.offset + this.relativeOffset);\n  return this.relativeOffset += 4, e;\n};\nv.prototype.parseOffset32 = v.prototype.parseULong;\nv.prototype.parseFixed = function () {\n  var e = Ct(this.data, this.offset + this.relativeOffset);\n  return this.relativeOffset += 4, e;\n};\nv.prototype.parseString = function (e) {\n  var r = this.data,\n    t = this.offset + this.relativeOffset,\n    a = \"\";\n  this.relativeOffset += e;\n  for (var n = 0; n < e; n++) {\n    a += String.fromCharCode(r.getUint8(t + n));\n  }\n  return a;\n};\nv.prototype.parseTag = function () {\n  return this.parseString(4);\n};\nv.prototype.parseLongDateTime = function () {\n  var e = Fr(this.data, this.offset + this.relativeOffset + 4);\n  return e -= 2082844800, this.relativeOffset += 8, e;\n};\nv.prototype.parseVersion = function (e) {\n  var r = Je(this.data, this.offset + this.relativeOffset),\n    t = Je(this.data, this.offset + this.relativeOffset + 2);\n  return this.relativeOffset += 4, e === void 0 && (e = 4096), r + t / e / 10;\n};\nv.prototype.skip = function (e, r) {\n  r === void 0 && (r = 1), this.relativeOffset += Da[e] * r;\n};\nv.prototype.parseULongList = function (e) {\n  e === void 0 && (e = this.parseULong());\n  for (var r = new Array(e), t = this.data, a = this.offset + this.relativeOffset, n = 0; n < e; n++) {\n    r[n] = t.getUint32(a), a += 4;\n  }\n  return this.relativeOffset += e * 4, r;\n};\nv.prototype.parseOffset16List = v.prototype.parseUShortList = function (e) {\n  e === void 0 && (e = this.parseUShort());\n  for (var r = new Array(e), t = this.data, a = this.offset + this.relativeOffset, n = 0; n < e; n++) {\n    r[n] = t.getUint16(a), a += 2;\n  }\n  return this.relativeOffset += e * 2, r;\n};\nv.prototype.parseShortList = function (e) {\n  for (var r = new Array(e), t = this.data, a = this.offset + this.relativeOffset, n = 0; n < e; n++) {\n    r[n] = t.getInt16(a), a += 2;\n  }\n  return this.relativeOffset += e * 2, r;\n};\nv.prototype.parseByteList = function (e) {\n  for (var r = new Array(e), t = this.data, a = this.offset + this.relativeOffset, n = 0; n < e; n++) {\n    r[n] = t.getUint8(a++);\n  }\n  return this.relativeOffset += e, r;\n};\nv.prototype.parseList = function (e, r) {\n  r || (r = e, e = this.parseUShort());\n  for (var t = new Array(e), a = 0; a < e; a++) {\n    t[a] = r.call(this);\n  }\n  return t;\n};\nv.prototype.parseList32 = function (e, r) {\n  r || (r = e, e = this.parseULong());\n  for (var t = new Array(e), a = 0; a < e; a++) {\n    t[a] = r.call(this);\n  }\n  return t;\n};\nv.prototype.parseRecordList = function (e, r) {\n  r || (r = e, e = this.parseUShort());\n  for (var t = new Array(e), a = Object.keys(r), n = 0; n < e; n++) {\n    for (var s = {}, i = 0; i < a.length; i++) {\n      var u = a[i],\n        o = r[u];\n      s[u] = o.call(this);\n    }\n    t[n] = s;\n  }\n  return t;\n};\nv.prototype.parseRecordList32 = function (e, r) {\n  r || (r = e, e = this.parseULong());\n  for (var t = new Array(e), a = Object.keys(r), n = 0; n < e; n++) {\n    for (var s = {}, i = 0; i < a.length; i++) {\n      var u = a[i],\n        o = r[u];\n      s[u] = o.call(this);\n    }\n    t[n] = s;\n  }\n  return t;\n};\nv.prototype.parseStruct = function (e) {\n  if (typeof e == \"function\") return e.call(this);\n  for (var r = Object.keys(e), t = {}, a = 0; a < r.length; a++) {\n    var n = r[a],\n      s = e[n];\n    t[n] = s.call(this);\n  }\n  return t;\n};\nv.prototype.parseValueRecord = function (e) {\n  if (e === void 0 && (e = this.parseUShort()), e !== 0) {\n    var r = {};\n    return e & 1 && (r.xPlacement = this.parseShort()), e & 2 && (r.yPlacement = this.parseShort()), e & 4 && (r.xAdvance = this.parseShort()), e & 8 && (r.yAdvance = this.parseShort()), e & 16 && (r.xPlaDevice = void 0, this.parseShort()), e & 32 && (r.yPlaDevice = void 0, this.parseShort()), e & 64 && (r.xAdvDevice = void 0, this.parseShort()), e & 128 && (r.yAdvDevice = void 0, this.parseShort()), r;\n  }\n};\nv.prototype.parseValueRecordList = function () {\n  for (var e = this.parseUShort(), r = this.parseUShort(), t = new Array(r), a = 0; a < r; a++) {\n    t[a] = this.parseValueRecord(e);\n  }\n  return t;\n};\nv.prototype.parsePointer = function (e) {\n  var r = this.parseOffset16();\n  if (r > 0) return new v(this.data, this.offset + r).parseStruct(e);\n};\nv.prototype.parsePointer32 = function (e) {\n  var r = this.parseOffset32();\n  if (r > 0) return new v(this.data, this.offset + r).parseStruct(e);\n};\nv.prototype.parseListOfLists = function (e) {\n  for (var r = this.parseOffset16List(), t = r.length, a = this.relativeOffset, n = new Array(t), s = 0; s < t; s++) {\n    var i = r[s];\n    if (i === 0) {\n      n[s] = void 0;\n      continue;\n    }\n    if (this.relativeOffset = i, e) {\n      for (var u = this.parseOffset16List(), o = new Array(u.length), l = 0; l < u.length; l++) {\n        this.relativeOffset = i + u[l], o[l] = e.call(this);\n      }\n      n[s] = o;\n    } else n[s] = this.parseUShortList();\n  }\n  return this.relativeOffset = a, n;\n};\nv.prototype.parseCoverage = function () {\n  var e = this.offset + this.relativeOffset,\n    r = this.parseUShort(),\n    t = this.parseUShort();\n  if (r === 1) return {\n    format: 1,\n    glyphs: this.parseUShortList(t)\n  };\n  if (r === 2) {\n    for (var a = new Array(t), n = 0; n < t; n++) {\n      a[n] = {\n        start: this.parseUShort(),\n        end: this.parseUShort(),\n        index: this.parseUShort()\n      };\n    }\n    return {\n      format: 2,\n      ranges: a\n    };\n  }\n  throw new Error(\"0x\" + e.toString(16) + \": Coverage format must be 1 or 2.\");\n};\nv.prototype.parseClassDef = function () {\n  var e = this.offset + this.relativeOffset,\n    r = this.parseUShort();\n  if (r === 1) return {\n    format: 1,\n    startGlyph: this.parseUShort(),\n    classes: this.parseUShortList()\n  };\n  if (r === 2) return {\n    format: 2,\n    ranges: this.parseRecordList({\n      start: v.uShort,\n      end: v.uShort,\n      classId: v.uShort\n    })\n  };\n  throw new Error(\"0x\" + e.toString(16) + \": ClassDef format must be 1 or 2.\");\n};\nv.list = function (e, r) {\n  return function () {\n    return this.parseList(e, r);\n  };\n};\nv.list32 = function (e, r) {\n  return function () {\n    return this.parseList32(e, r);\n  };\n};\nv.recordList = function (e, r) {\n  return function () {\n    return this.parseRecordList(e, r);\n  };\n};\nv.recordList32 = function (e, r) {\n  return function () {\n    return this.parseRecordList32(e, r);\n  };\n};\nv.pointer = function (e) {\n  return function () {\n    return this.parsePointer(e);\n  };\n};\nv.pointer32 = function (e) {\n  return function () {\n    return this.parsePointer32(e);\n  };\n};\nv.tag = v.prototype.parseTag;\nv[\"byte\"] = v.prototype.parseByte;\nv.uShort = v.offset16 = v.prototype.parseUShort;\nv.uShortList = v.prototype.parseUShortList;\nv.uLong = v.offset32 = v.prototype.parseULong;\nv.uLongList = v.prototype.parseULongList;\nv.struct = v.prototype.parseStruct;\nv.coverage = v.prototype.parseCoverage;\nv.classDef = v.prototype.parseClassDef;\nvar zr = {\n  reserved: v.uShort,\n  reqFeatureIndex: v.uShort,\n  featureIndexes: v.uShortList\n};\nv.prototype.parseScriptList = function () {\n  return this.parsePointer(v.recordList({\n    tag: v.tag,\n    script: v.pointer({\n      defaultLangSys: v.pointer(zr),\n      langSysRecords: v.recordList({\n        tag: v.tag,\n        langSys: v.pointer(zr)\n      })\n    })\n  })) || [];\n};\nv.prototype.parseFeatureList = function () {\n  return this.parsePointer(v.recordList({\n    tag: v.tag,\n    feature: v.pointer({\n      featureParams: v.offset16,\n      lookupListIndexes: v.uShortList\n    })\n  })) || [];\n};\nv.prototype.parseLookupList = function (e) {\n  return this.parsePointer(v.list(v.pointer(function () {\n    var r = this.parseUShort();\n    U.argument(1 <= r && r <= 9, \"GPOS/GSUB lookup type \" + r + \" unknown.\");\n    var t = this.parseUShort(),\n      a = t & 16;\n    return {\n      lookupType: r,\n      lookupFlag: t,\n      subtables: this.parseList(v.pointer(e[r])),\n      markFilteringSet: a ? this.parseUShort() : void 0\n    };\n  }))) || [];\n};\nv.prototype.parseFeatureVariationsList = function () {\n  return this.parsePointer32(function () {\n    var e = this.parseUShort(),\n      r = this.parseUShort();\n    U.argument(e === 1 && r < 1, \"GPOS/GSUB feature variations table unknown.\");\n    var t = this.parseRecordList32({\n      conditionSetOffset: v.offset32,\n      featureTableSubstitutionOffset: v.offset32\n    });\n    return t;\n  }) || [];\n};\nvar k = {\n  getByte: Hr,\n  getCard8: Hr,\n  getUShort: Je,\n  getCard16: Je,\n  getShort: Ea,\n  getULong: Fr,\n  getFixed: Ct,\n  getTag: Oa,\n  getOffset: La,\n  getBytes: Ra,\n  bytesToString: wa,\n  Parser: v\n};\nfunction Aa(e, r) {\n  r.parseUShort(), e.length = r.parseULong(), e.language = r.parseULong();\n  var t;\n  e.groupCount = t = r.parseULong(), e.glyphIndexMap = {};\n  for (var a = 0; a < t; a += 1) {\n    for (var n = r.parseULong(), s = r.parseULong(), i = r.parseULong(), u = n; u <= s; u += 1) {\n      e.glyphIndexMap[u] = i, i++;\n    }\n  }\n}\nfunction Ba(e, r, t, a, n) {\n  e.length = r.parseUShort(), e.language = r.parseUShort();\n  var s;\n  e.segCount = s = r.parseUShort() >> 1, r.skip(\"uShort\", 3), e.glyphIndexMap = {};\n  for (var i = new k.Parser(t, a + n + 14), u = new k.Parser(t, a + n + 16 + s * 2), o = new k.Parser(t, a + n + 16 + s * 4), l = new k.Parser(t, a + n + 16 + s * 6), f = a + n + 16 + s * 8, h = 0; h < s - 1; h += 1) {\n    for (var p = void 0, c = i.parseUShort(), d = u.parseUShort(), x = o.parseShort(), m = l.parseUShort(), y = d; y <= c; y += 1) {\n      m !== 0 ? (f = l.offset + l.relativeOffset - 2, f += m, f += (y - d) * 2, p = k.getUShort(t, f), p !== 0 && (p = p + x & 65535)) : p = y + x & 65535, e.glyphIndexMap[y] = p;\n    }\n  }\n}\nfunction Ia(e, r) {\n  var t = {};\n  t.version = k.getUShort(e, r), U.argument(t.version === 0, \"cmap table version should be 0.\"), t.numTables = k.getUShort(e, r + 2);\n  for (var a = -1, n = t.numTables - 1; n >= 0; n -= 1) {\n    var s = k.getUShort(e, r + 4 + n * 8),\n      i = k.getUShort(e, r + 4 + n * 8 + 2);\n    if (s === 3 && (i === 0 || i === 1 || i === 10) || s === 0 && (i === 0 || i === 1 || i === 2 || i === 3 || i === 4)) {\n      a = k.getULong(e, r + 4 + n * 8 + 4);\n      break;\n    }\n  }\n  if (a === -1) throw new Error(\"No valid cmap sub-tables found.\");\n  var u = new k.Parser(e, r + a);\n  if (t.format = u.parseUShort(), t.format === 12) Aa(t, u);else if (t.format === 4) Ba(t, u, e, r, a);else throw new Error(\"Only format 4 and 12 cmap tables are supported (found format \" + t.format + \").\");\n  return t;\n}\nfunction Ma(e, r, t) {\n  e.segments.push({\n    end: r,\n    start: r,\n    delta: -(r - t),\n    offset: 0,\n    glyphIndex: t\n  });\n}\nfunction Pa(e) {\n  e.segments.push({\n    end: 65535,\n    start: 65535,\n    delta: 1,\n    offset: 0\n  });\n}\nfunction Ga(e) {\n  var r = !0,\n    t;\n  for (t = e.length - 1; t > 0; t -= 1) {\n    var a = e.get(t);\n    if (a.unicode > 65535) {\n      console.log(\"Adding CMAP format 12 (needed!)\"), r = !1;\n      break;\n    }\n  }\n  var n = [{\n    name: \"version\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"numTables\",\n    type: \"USHORT\",\n    value: r ? 1 : 2\n  }, {\n    name: \"platformID\",\n    type: \"USHORT\",\n    value: 3\n  }, {\n    name: \"encodingID\",\n    type: \"USHORT\",\n    value: 1\n  }, {\n    name: \"offset\",\n    type: \"ULONG\",\n    value: r ? 12 : 12 + 8\n  }];\n  r || (n = n.concat([{\n    name: \"cmap12PlatformID\",\n    type: \"USHORT\",\n    value: 3\n  }, {\n    name: \"cmap12EncodingID\",\n    type: \"USHORT\",\n    value: 10\n  }, {\n    name: \"cmap12Offset\",\n    type: \"ULONG\",\n    value: 0\n  }])), n = n.concat([{\n    name: \"format\",\n    type: \"USHORT\",\n    value: 4\n  }, {\n    name: \"cmap4Length\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"language\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"segCountX2\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"searchRange\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"entrySelector\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"rangeShift\",\n    type: \"USHORT\",\n    value: 0\n  }]);\n  var s = new b.Table(\"cmap\", n);\n  for (s.segments = [], t = 0; t < e.length; t += 1) {\n    for (var i = e.get(t), u = 0; u < i.unicodes.length; u += 1) {\n      Ma(s, i.unicodes[u], t);\n    }\n    s.segments = s.segments.sort(function (C, S) {\n      return C.start - S.start;\n    });\n  }\n  Pa(s);\n  var o = s.segments.length,\n    l = 0,\n    f = [],\n    h = [],\n    p = [],\n    c = [],\n    d = [],\n    x = [];\n  for (t = 0; t < o; t += 1) {\n    var m = s.segments[t];\n    m.end <= 65535 && m.start <= 65535 ? (f = f.concat({\n      name: \"end_\" + t,\n      type: \"USHORT\",\n      value: m.end\n    }), h = h.concat({\n      name: \"start_\" + t,\n      type: \"USHORT\",\n      value: m.start\n    }), p = p.concat({\n      name: \"idDelta_\" + t,\n      type: \"SHORT\",\n      value: m.delta\n    }), c = c.concat({\n      name: \"idRangeOffset_\" + t,\n      type: \"USHORT\",\n      value: m.offset\n    }), m.glyphId !== void 0 && (d = d.concat({\n      name: \"glyph_\" + t,\n      type: \"USHORT\",\n      value: m.glyphId\n    }))) : l += 1, !r && m.glyphIndex !== void 0 && (x = x.concat({\n      name: \"cmap12Start_\" + t,\n      type: \"ULONG\",\n      value: m.start\n    }), x = x.concat({\n      name: \"cmap12End_\" + t,\n      type: \"ULONG\",\n      value: m.end\n    }), x = x.concat({\n      name: \"cmap12Glyph_\" + t,\n      type: \"ULONG\",\n      value: m.glyphIndex\n    }));\n  }\n  if (s.segCountX2 = (o - l) * 2, s.searchRange = Math.pow(2, Math.floor(Math.log(o - l) / Math.log(2))) * 2, s.entrySelector = Math.log(s.searchRange / 2) / Math.log(2), s.rangeShift = s.segCountX2 - s.searchRange, s.fields = s.fields.concat(f), s.fields.push({\n    name: \"reservedPad\",\n    type: \"USHORT\",\n    value: 0\n  }), s.fields = s.fields.concat(h), s.fields = s.fields.concat(p), s.fields = s.fields.concat(c), s.fields = s.fields.concat(d), s.cmap4Length = 14 + f.length * 2 + 2 + h.length * 2 + p.length * 2 + c.length * 2 + d.length * 2, !r) {\n    var y = 16 + x.length * 4;\n    s.cmap12Offset = 12 + 2 * 2 + 4 + s.cmap4Length, s.fields = s.fields.concat([{\n      name: \"cmap12Format\",\n      type: \"USHORT\",\n      value: 12\n    }, {\n      name: \"cmap12Reserved\",\n      type: \"USHORT\",\n      value: 0\n    }, {\n      name: \"cmap12Length\",\n      type: \"ULONG\",\n      value: y\n    }, {\n      name: \"cmap12Language\",\n      type: \"ULONG\",\n      value: 0\n    }, {\n      name: \"cmap12nGroups\",\n      type: \"ULONG\",\n      value: x.length / 3\n    }]), s.fields = s.fields.concat(x);\n  }\n  return s;\n}\nvar Et = {\n    parse: Ia,\n    make: Ga\n  },\n  qe = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"266 ff\", \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\", \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"],\n  Na = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"\", \"questiondown\", \"\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"\", \"ring\", \"cedilla\", \"\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"AE\", \"\", \"ordfeminine\", \"\", \"\", \"\", \"\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"\", \"\", \"\", \"\", \"\", \"ae\", \"\", \"\", \"\", \"dotlessi\", \"\", \"\", \"lslash\", \"oslash\", \"oe\", \"germandbls\"],\n  Ha = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"space\", \"exclamsmall\", \"Hungarumlautsmall\", \"\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"comma\", \"hyphen\", \"period\", \"fraction\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"colon\", \"semicolon\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"\", \"\", \"isuperior\", \"\", \"\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"\", \"\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"\", \"ff\", \"fi\", \"fl\", \"ffi\", \"ffl\", \"parenleftinferior\", \"\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"\", \"\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"\", \"Dotaccentsmall\", \"\", \"\", \"Macronsmall\", \"\", \"\", \"figuredash\", \"hypheninferior\", \"\", \"\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"\", \"\", \"\", \"onequarter\", \"onehalf\", \"threequarters\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"\", \"\", \"zerosuperior\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\"],\n  xe = [\".notdef\", \".null\", \"nonmarkingreturn\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quotesingle\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"grave\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"Adieresis\", \"Aring\", \"Ccedilla\", \"Eacute\", \"Ntilde\", \"Odieresis\", \"Udieresis\", \"aacute\", \"agrave\", \"acircumflex\", \"adieresis\", \"atilde\", \"aring\", \"ccedilla\", \"eacute\", \"egrave\", \"ecircumflex\", \"edieresis\", \"iacute\", \"igrave\", \"icircumflex\", \"idieresis\", \"ntilde\", \"oacute\", \"ograve\", \"ocircumflex\", \"odieresis\", \"otilde\", \"uacute\", \"ugrave\", \"ucircumflex\", \"udieresis\", \"dagger\", \"degree\", \"cent\", \"sterling\", \"section\", \"bullet\", \"paragraph\", \"germandbls\", \"registered\", \"copyright\", \"trademark\", \"acute\", \"dieresis\", \"notequal\", \"AE\", \"Oslash\", \"infinity\", \"plusminus\", \"lessequal\", \"greaterequal\", \"yen\", \"mu\", \"partialdiff\", \"summation\", \"product\", \"pi\", \"integral\", \"ordfeminine\", \"ordmasculine\", \"Omega\", \"ae\", \"oslash\", \"questiondown\", \"exclamdown\", \"logicalnot\", \"radical\", \"florin\", \"approxequal\", \"Delta\", \"guillemotleft\", \"guillemotright\", \"ellipsis\", \"nonbreakingspace\", \"Agrave\", \"Atilde\", \"Otilde\", \"OE\", \"oe\", \"endash\", \"emdash\", \"quotedblleft\", \"quotedblright\", \"quoteleft\", \"quoteright\", \"divide\", \"lozenge\", \"ydieresis\", \"Ydieresis\", \"fraction\", \"currency\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"daggerdbl\", \"periodcentered\", \"quotesinglbase\", \"quotedblbase\", \"perthousand\", \"Acircumflex\", \"Ecircumflex\", \"Aacute\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Oacute\", \"Ocircumflex\", \"apple\", \"Ograve\", \"Uacute\", \"Ucircumflex\", \"Ugrave\", \"dotlessi\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"Lslash\", \"lslash\", \"Scaron\", \"scaron\", \"Zcaron\", \"zcaron\", \"brokenbar\", \"Eth\", \"eth\", \"Yacute\", \"yacute\", \"Thorn\", \"thorn\", \"minus\", \"multiply\", \"onesuperior\", \"twosuperior\", \"threesuperior\", \"onehalf\", \"onequarter\", \"threequarters\", \"franc\", \"Gbreve\", \"gbreve\", \"Idotaccent\", \"Scedilla\", \"scedilla\", \"Cacute\", \"cacute\", \"Ccaron\", \"ccaron\", \"dcroat\"];\nfunction Ot(e) {\n  this.font = e;\n}\nOt.prototype.charToGlyphIndex = function (e) {\n  var r = e.codePointAt(0),\n    t = this.font.glyphs;\n  if (t) {\n    for (var a = 0; a < t.length; a += 1) {\n      for (var n = t.get(a), s = 0; s < n.unicodes.length; s += 1) {\n        if (n.unicodes[s] === r) return a;\n      }\n    }\n  }\n  return null;\n};\nfunction Lt(e) {\n  this.cmap = e;\n}\nLt.prototype.charToGlyphIndex = function (e) {\n  return this.cmap.glyphIndexMap[e.codePointAt(0)] || 0;\n};\nfunction je(e, r) {\n  this.encoding = e, this.charset = r;\n}\nje.prototype.charToGlyphIndex = function (e) {\n  var r = e.codePointAt(0),\n    t = this.encoding[r];\n  return this.charset.indexOf(t);\n};\nfunction Ur(e) {\n  switch (e.version) {\n    case 1:\n      this.names = xe.slice();\n      break;\n    case 2:\n      this.names = new Array(e.numberOfGlyphs);\n      for (var r = 0; r < e.numberOfGlyphs; r++) {\n        e.glyphNameIndex[r] < xe.length ? this.names[r] = xe[e.glyphNameIndex[r]] : this.names[r] = e.names[e.glyphNameIndex[r] - xe.length];\n      }\n      break;\n    case 2.5:\n      this.names = new Array(e.numberOfGlyphs);\n      for (var t = 0; t < e.numberOfGlyphs; t++) {\n        this.names[t] = xe[t + e.glyphNameIndex[t]];\n      }\n      break;\n    case 3:\n      this.names = [];\n      break;\n    default:\n      this.names = [];\n      break;\n  }\n}\nUr.prototype.nameToGlyphIndex = function (e) {\n  return this.names.indexOf(e);\n};\nUr.prototype.glyphIndexToName = function (e) {\n  return this.names[e];\n};\nfunction za(e) {\n  for (var r, t = e.tables.cmap.glyphIndexMap, a = Object.keys(t), n = 0; n < a.length; n += 1) {\n    var s = a[n],\n      i = t[s];\n    r = e.glyphs.get(i), r.addUnicode(parseInt(s));\n  }\n  for (var u = 0; u < e.glyphs.length; u += 1) {\n    r = e.glyphs.get(u), e.cffEncoding ? e.isCIDFont ? r.name = \"gid\" + u : r.name = e.cffEncoding.charset[u] : e.glyphNames.names && (r.name = e.glyphNames.glyphIndexToName(u));\n  }\n}\nfunction Wa(e) {\n  e._IndexToUnicodeMap = {};\n  for (var r = e.tables.cmap.glyphIndexMap, t = Object.keys(r), a = 0; a < t.length; a += 1) {\n    var n = t[a],\n      s = r[n];\n    e._IndexToUnicodeMap[s] === void 0 ? e._IndexToUnicodeMap[s] = {\n      unicodes: [parseInt(n)]\n    } : e._IndexToUnicodeMap[s].unicodes.push(parseInt(n));\n  }\n}\nfunction _a(e, r) {\n  r.lowMemory ? Wa(e) : za(e);\n}\nfunction Va(e, r, t, a, n) {\n  e.beginPath(), e.moveTo(r, t), e.lineTo(a, n), e.stroke();\n}\nvar ye = {\n  line: Va\n};\nfunction qa(e, r) {\n  var t = r || new P();\n  return {\n    configurable: !0,\n    get: function get() {\n      return typeof t == \"function\" && (t = t()), t;\n    },\n    set: function set(a) {\n      t = a;\n    }\n  };\n}\nfunction Q(e) {\n  this.bindConstructorValues(e);\n}\nQ.prototype.bindConstructorValues = function (e) {\n  this.index = e.index || 0, this.name = e.name || null, this.unicode = e.unicode || void 0, this.unicodes = e.unicodes || e.unicode !== void 0 ? [e.unicode] : [], \"xMin\" in e && (this.xMin = e.xMin), \"yMin\" in e && (this.yMin = e.yMin), \"xMax\" in e && (this.xMax = e.xMax), \"yMax\" in e && (this.yMax = e.yMax), \"advanceWidth\" in e && (this.advanceWidth = e.advanceWidth), Object.defineProperty(this, \"path\", qa(this, e.path));\n};\nQ.prototype.addUnicode = function (e) {\n  this.unicodes.length === 0 && (this.unicode = e), this.unicodes.push(e);\n};\nQ.prototype.getBoundingBox = function () {\n  return this.path.getBoundingBox();\n};\nQ.prototype.getPath = function (e, r, t, a, n) {\n  e = e !== void 0 ? e : 0, r = r !== void 0 ? r : 0, t = t !== void 0 ? t : 72;\n  var s, i;\n  a || (a = {});\n  var u = a.xScale,\n    o = a.yScale;\n  if (a.hinting && n && n.hinting && (i = this.path && n.hinting.exec(this, t)), i) s = n.hinting.getCommands(i), e = Math.round(e), r = Math.round(r), u = o = 1;else {\n    s = this.path.commands;\n    var l = 1 / (this.path.unitsPerEm || 1e3) * t;\n    u === void 0 && (u = l), o === void 0 && (o = l);\n  }\n  for (var f = new P(), h = 0; h < s.length; h += 1) {\n    var p = s[h];\n    p.type === \"M\" ? f.moveTo(e + p.x * u, r + -p.y * o) : p.type === \"L\" ? f.lineTo(e + p.x * u, r + -p.y * o) : p.type === \"Q\" ? f.quadraticCurveTo(e + p.x1 * u, r + -p.y1 * o, e + p.x * u, r + -p.y * o) : p.type === \"C\" ? f.curveTo(e + p.x1 * u, r + -p.y1 * o, e + p.x2 * u, r + -p.y2 * o, e + p.x * u, r + -p.y * o) : p.type === \"Z\" && f.closePath();\n  }\n  return f;\n};\nQ.prototype.getContours = function () {\n  if (this.points === void 0) return [];\n  for (var e = [], r = [], t = 0; t < this.points.length; t += 1) {\n    var a = this.points[t];\n    r.push(a), a.lastPointOfContour && (e.push(r), r = []);\n  }\n  return U.argument(r.length === 0, \"There are still points left in the current contour.\"), e;\n};\nQ.prototype.getMetrics = function () {\n  for (var e = this.path.commands, r = [], t = [], a = 0; a < e.length; a += 1) {\n    var n = e[a];\n    n.type !== \"Z\" && (r.push(n.x), t.push(n.y)), (n.type === \"Q\" || n.type === \"C\") && (r.push(n.x1), t.push(n.y1)), n.type === \"C\" && (r.push(n.x2), t.push(n.y2));\n  }\n  var s = {\n    xMin: Math.min.apply(null, r),\n    yMin: Math.min.apply(null, t),\n    xMax: Math.max.apply(null, r),\n    yMax: Math.max.apply(null, t),\n    leftSideBearing: this.leftSideBearing\n  };\n  return isFinite(s.xMin) || (s.xMin = 0), isFinite(s.xMax) || (s.xMax = this.advanceWidth), isFinite(s.yMin) || (s.yMin = 0), isFinite(s.yMax) || (s.yMax = 0), s.rightSideBearing = this.advanceWidth - s.leftSideBearing - (s.xMax - s.xMin), s;\n};\nQ.prototype.draw = function (e, r, t, a, n) {\n  this.getPath(r, t, a, n).draw(e);\n};\nQ.prototype.drawPoints = function (e, r, t, a) {\n  function n(h, p, c, d) {\n    e.beginPath();\n    for (var x = 0; x < h.length; x += 1) {\n      e.moveTo(p + h[x].x * d, c + h[x].y * d), e.arc(p + h[x].x * d, c + h[x].y * d, 2, 0, Math.PI * 2, !1);\n    }\n    e.closePath(), e.fill();\n  }\n  r = r !== void 0 ? r : 0, t = t !== void 0 ? t : 0, a = a !== void 0 ? a : 24;\n  for (var s = 1 / this.path.unitsPerEm * a, i = [], u = [], o = this.path, l = 0; l < o.commands.length; l += 1) {\n    var f = o.commands[l];\n    f.x !== void 0 && i.push({\n      x: f.x,\n      y: -f.y\n    }), f.x1 !== void 0 && u.push({\n      x: f.x1,\n      y: -f.y1\n    }), f.x2 !== void 0 && u.push({\n      x: f.x2,\n      y: -f.y2\n    });\n  }\n  e.fillStyle = \"blue\", n(i, r, t, s), e.fillStyle = \"red\", n(u, r, t, s);\n};\nQ.prototype.drawMetrics = function (e, r, t, a) {\n  var n;\n  r = r !== void 0 ? r : 0, t = t !== void 0 ? t : 0, a = a !== void 0 ? a : 24, n = 1 / this.path.unitsPerEm * a, e.lineWidth = 1, e.strokeStyle = \"black\", ye.line(e, r, -1e4, r, 1e4), ye.line(e, -1e4, t, 1e4, t);\n  var s = this.xMin || 0,\n    i = this.yMin || 0,\n    u = this.xMax || 0,\n    o = this.yMax || 0,\n    l = this.advanceWidth || 0;\n  e.strokeStyle = \"blue\", ye.line(e, r + s * n, -1e4, r + s * n, 1e4), ye.line(e, r + u * n, -1e4, r + u * n, 1e4), ye.line(e, -1e4, t + -i * n, 1e4, t + -i * n), ye.line(e, -1e4, t + -o * n, 1e4, t + -o * n), e.strokeStyle = \"green\", ye.line(e, r + l * n, -1e4, r + l * n, 1e4);\n};\nfunction _e(e, r, t) {\n  Object.defineProperty(e, r, {\n    get: function get() {\n      return e.path, e[t];\n    },\n    set: function set(a) {\n      e[t] = a;\n    },\n    enumerable: !0,\n    configurable: !0\n  });\n}\nfunction Cr(e, r) {\n  if (this.font = e, this.glyphs = {}, Array.isArray(r)) for (var t = 0; t < r.length; t++) {\n    var a = r[t];\n    a.path.unitsPerEm = e.unitsPerEm, this.glyphs[t] = a;\n  }\n  this.length = r && r.length || 0;\n}\nCr.prototype.get = function (e) {\n  if (this.glyphs[e] === void 0) {\n    this.font._push(e), typeof this.glyphs[e] == \"function\" && (this.glyphs[e] = this.glyphs[e]());\n    var r = this.glyphs[e],\n      t = this.font._IndexToUnicodeMap[e];\n    if (t) for (var a = 0; a < t.unicodes.length; a++) {\n      r.addUnicode(t.unicodes[a]);\n    }\n    this.font.cffEncoding ? this.font.isCIDFont ? r.name = \"gid\" + e : r.name = this.font.cffEncoding.charset[e] : this.font.glyphNames.names && (r.name = this.font.glyphNames.glyphIndexToName(e)), this.glyphs[e].advanceWidth = this.font._hmtxTableData[e].advanceWidth, this.glyphs[e].leftSideBearing = this.font._hmtxTableData[e].leftSideBearing;\n  } else typeof this.glyphs[e] == \"function\" && (this.glyphs[e] = this.glyphs[e]());\n  return this.glyphs[e];\n};\nCr.prototype.push = function (e, r) {\n  this.glyphs[e] = r, this.length++;\n};\nfunction Xa(e, r) {\n  return new Q({\n    index: r,\n    font: e\n  });\n}\nfunction Ya(e, r, t, a, n, s) {\n  return function () {\n    var i = new Q({\n      index: r,\n      font: e\n    });\n    return i.path = function () {\n      t(i, a, n);\n      var u = s(e.glyphs, i);\n      return u.unitsPerEm = e.unitsPerEm, u;\n    }, _e(i, \"xMin\", \"_xMin\"), _e(i, \"xMax\", \"_xMax\"), _e(i, \"yMin\", \"_yMin\"), _e(i, \"yMax\", \"_yMax\"), i;\n  };\n}\nfunction Za(e, r, t, a) {\n  return function () {\n    var n = new Q({\n      index: r,\n      font: e\n    });\n    return n.path = function () {\n      var s = t(e, n, a);\n      return s.unitsPerEm = e.unitsPerEm, s;\n    }, n;\n  };\n}\nvar ue = {\n  GlyphSet: Cr,\n  glyphLoader: Xa,\n  ttfGlyphLoader: Ya,\n  cffGlyphLoader: Za\n};\nfunction Rt(e, r) {\n  if (e === r) return !0;\n  if (Array.isArray(e) && Array.isArray(r)) {\n    if (e.length !== r.length) return !1;\n    for (var t = 0; t < e.length; t += 1) {\n      if (!Rt(e[t], r[t])) return !1;\n    }\n    return !0;\n  } else return !1;\n}\nfunction gr(e) {\n  var r;\n  return e.length < 1240 ? r = 107 : e.length < 33900 ? r = 1131 : r = 32768, r;\n}\nfunction ve(e, r, t) {\n  var a = [],\n    n = [],\n    s = k.getCard16(e, r),\n    i,\n    u;\n  if (s !== 0) {\n    var o = k.getByte(e, r + 2);\n    i = r + (s + 1) * o + 2;\n    for (var l = r + 3, f = 0; f < s + 1; f += 1) {\n      a.push(k.getOffset(e, l, o)), l += o;\n    }\n    u = i + a[s];\n  } else u = r + 2;\n  for (var h = 0; h < a.length - 1; h += 1) {\n    var p = k.getBytes(e, i + a[h], i + a[h + 1]);\n    t && (p = t(p)), n.push(p);\n  }\n  return {\n    objects: n,\n    startOffset: r,\n    endOffset: u\n  };\n}\nfunction Qa(e, r) {\n  var t = [],\n    a = k.getCard16(e, r),\n    n,\n    s;\n  if (a !== 0) {\n    var i = k.getByte(e, r + 2);\n    n = r + (a + 1) * i + 2;\n    for (var u = r + 3, o = 0; o < a + 1; o += 1) {\n      t.push(k.getOffset(e, u, i)), u += i;\n    }\n    s = n + t[a];\n  } else s = r + 2;\n  return {\n    offsets: t,\n    startOffset: r,\n    endOffset: s\n  };\n}\nfunction Ka(e, r, t, a, n) {\n  var s = k.getCard16(t, a),\n    i = 0;\n  if (s !== 0) {\n    var u = k.getByte(t, a + 2);\n    i = a + (s + 1) * u + 2;\n  }\n  var o = k.getBytes(t, i + r[e], i + r[e + 1]);\n  return n && (o = n(o)), o;\n}\nfunction Ja(e) {\n  for (var r = \"\", t = 15, a = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \".\", \"E\", \"E-\", null, \"-\"];;) {\n    var n = e.parseByte(),\n      s = n >> 4,\n      i = n & 15;\n    if (s === t || (r += a[s], i === t)) break;\n    r += a[i];\n  }\n  return parseFloat(r);\n}\nfunction ja(e, r) {\n  var t, a, n, s;\n  if (r === 28) return t = e.parseByte(), a = e.parseByte(), t << 8 | a;\n  if (r === 29) return t = e.parseByte(), a = e.parseByte(), n = e.parseByte(), s = e.parseByte(), t << 24 | a << 16 | n << 8 | s;\n  if (r === 30) return Ja(e);\n  if (r >= 32 && r <= 246) return r - 139;\n  if (r >= 247 && r <= 250) return t = e.parseByte(), (r - 247) * 256 + t + 108;\n  if (r >= 251 && r <= 254) return t = e.parseByte(), -(r - 251) * 256 - t - 108;\n  throw new Error(\"Invalid b0 \" + r);\n}\nfunction $a(e) {\n  for (var r = {}, t = 0; t < e.length; t += 1) {\n    var a = e[t][0],\n      n = e[t][1],\n      s = void 0;\n    if (n.length === 1 ? s = n[0] : s = n, r.hasOwnProperty(a) && !isNaN(r[a])) throw new Error(\"Object \" + r + \" already has key \" + a);\n    r[a] = s;\n  }\n  return r;\n}\nfunction wt(e, r, t) {\n  r = r !== void 0 ? r : 0;\n  var a = new k.Parser(e, r),\n    n = [],\n    s = [];\n  for (t = t !== void 0 ? t : e.length; a.relativeOffset < t;) {\n    var i = a.parseByte();\n    i <= 21 ? (i === 12 && (i = 1200 + a.parseByte()), n.push([i, s]), s = []) : s.push(ja(a, i));\n  }\n  return $a(n);\n}\nfunction Oe(e, r) {\n  return r <= 390 ? r = qe[r] : r = e[r - 391], r;\n}\nfunction Dt(e, r, t) {\n  for (var a = {}, n, s = 0; s < r.length; s += 1) {\n    var i = r[s];\n    if (Array.isArray(i.type)) {\n      var u = [];\n      u.length = i.type.length;\n      for (var o = 0; o < i.type.length; o++) {\n        n = e[i.op] !== void 0 ? e[i.op][o] : void 0, n === void 0 && (n = i.value !== void 0 && i.value[o] !== void 0 ? i.value[o] : null), i.type[o] === \"SID\" && (n = Oe(t, n)), u[o] = n;\n      }\n      a[i.name] = u;\n    } else n = e[i.op], n === void 0 && (n = i.value !== void 0 ? i.value : null), i.type === \"SID\" && (n = Oe(t, n)), a[i.name] = n;\n  }\n  return a;\n}\nfunction en(e, r) {\n  var t = {};\n  return t.formatMajor = k.getCard8(e, r), t.formatMinor = k.getCard8(e, r + 1), t.size = k.getCard8(e, r + 2), t.offsetSize = k.getCard8(e, r + 3), t.startOffset = r, t.endOffset = r + 4, t;\n}\nvar At = [{\n    name: \"version\",\n    op: 0,\n    type: \"SID\"\n  }, {\n    name: \"notice\",\n    op: 1,\n    type: \"SID\"\n  }, {\n    name: \"copyright\",\n    op: 1200,\n    type: \"SID\"\n  }, {\n    name: \"fullName\",\n    op: 2,\n    type: \"SID\"\n  }, {\n    name: \"familyName\",\n    op: 3,\n    type: \"SID\"\n  }, {\n    name: \"weight\",\n    op: 4,\n    type: \"SID\"\n  }, {\n    name: \"isFixedPitch\",\n    op: 1201,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"italicAngle\",\n    op: 1202,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"underlinePosition\",\n    op: 1203,\n    type: \"number\",\n    value: -100\n  }, {\n    name: \"underlineThickness\",\n    op: 1204,\n    type: \"number\",\n    value: 50\n  }, {\n    name: \"paintType\",\n    op: 1205,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"charstringType\",\n    op: 1206,\n    type: \"number\",\n    value: 2\n  }, {\n    name: \"fontMatrix\",\n    op: 1207,\n    type: [\"real\", \"real\", \"real\", \"real\", \"real\", \"real\"],\n    value: [.001, 0, 0, .001, 0, 0]\n  }, {\n    name: \"uniqueId\",\n    op: 13,\n    type: \"number\"\n  }, {\n    name: \"fontBBox\",\n    op: 5,\n    type: [\"number\", \"number\", \"number\", \"number\"],\n    value: [0, 0, 0, 0]\n  }, {\n    name: \"strokeWidth\",\n    op: 1208,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"xuid\",\n    op: 14,\n    type: [],\n    value: null\n  }, {\n    name: \"charset\",\n    op: 15,\n    type: \"offset\",\n    value: 0\n  }, {\n    name: \"encoding\",\n    op: 16,\n    type: \"offset\",\n    value: 0\n  }, {\n    name: \"charStrings\",\n    op: 17,\n    type: \"offset\",\n    value: 0\n  }, {\n    name: \"private\",\n    op: 18,\n    type: [\"number\", \"offset\"],\n    value: [0, 0]\n  }, {\n    name: \"ros\",\n    op: 1230,\n    type: [\"SID\", \"SID\", \"number\"]\n  }, {\n    name: \"cidFontVersion\",\n    op: 1231,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"cidFontRevision\",\n    op: 1232,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"cidFontType\",\n    op: 1233,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"cidCount\",\n    op: 1234,\n    type: \"number\",\n    value: 8720\n  }, {\n    name: \"uidBase\",\n    op: 1235,\n    type: \"number\"\n  }, {\n    name: \"fdArray\",\n    op: 1236,\n    type: \"offset\"\n  }, {\n    name: \"fdSelect\",\n    op: 1237,\n    type: \"offset\"\n  }, {\n    name: \"fontName\",\n    op: 1238,\n    type: \"SID\"\n  }],\n  Bt = [{\n    name: \"subrs\",\n    op: 19,\n    type: \"offset\",\n    value: 0\n  }, {\n    name: \"defaultWidthX\",\n    op: 20,\n    type: \"number\",\n    value: 0\n  }, {\n    name: \"nominalWidthX\",\n    op: 21,\n    type: \"number\",\n    value: 0\n  }];\nfunction rn(e, r) {\n  var t = wt(e, 0, e.byteLength);\n  return Dt(t, At, r);\n}\nfunction It(e, r, t, a) {\n  var n = wt(e, r, t);\n  return Dt(n, Bt, a);\n}\nfunction Wr(e, r, t, a) {\n  for (var n = [], s = 0; s < t.length; s += 1) {\n    var i = new DataView(new Uint8Array(t[s]).buffer),\n      u = rn(i, a);\n    u._subrs = [], u._subrsBias = 0, u._defaultWidthX = 0, u._nominalWidthX = 0;\n    var o = u[\"private\"][0],\n      l = u[\"private\"][1];\n    if (o !== 0 && l !== 0) {\n      var f = It(e, l + r, o, a);\n      if (u._defaultWidthX = f.defaultWidthX, u._nominalWidthX = f.nominalWidthX, f.subrs !== 0) {\n        var h = l + f.subrs,\n          p = ve(e, h + r);\n        u._subrs = p.objects, u._subrsBias = gr(u._subrs);\n      }\n      u._privateDict = f;\n    }\n    n.push(u);\n  }\n  return n;\n}\nfunction tn(e, r, t, a) {\n  var n,\n    s,\n    i = new k.Parser(e, r);\n  t -= 1;\n  var u = [\".notdef\"],\n    o = i.parseCard8();\n  if (o === 0) for (var l = 0; l < t; l += 1) {\n    n = i.parseSID(), u.push(Oe(a, n));\n  } else if (o === 1) for (; u.length <= t;) {\n    n = i.parseSID(), s = i.parseCard8();\n    for (var f = 0; f <= s; f += 1) {\n      u.push(Oe(a, n)), n += 1;\n    }\n  } else if (o === 2) for (; u.length <= t;) {\n    n = i.parseSID(), s = i.parseCard16();\n    for (var h = 0; h <= s; h += 1) {\n      u.push(Oe(a, n)), n += 1;\n    }\n  } else throw new Error(\"Unknown charset format \" + o);\n  return u;\n}\nfunction an(e, r, t) {\n  var a,\n    n = {},\n    s = new k.Parser(e, r),\n    i = s.parseCard8();\n  if (i === 0) for (var u = s.parseCard8(), o = 0; o < u; o += 1) {\n    a = s.parseCard8(), n[a] = o;\n  } else if (i === 1) {\n    var l = s.parseCard8();\n    a = 1;\n    for (var f = 0; f < l; f += 1) {\n      for (var h = s.parseCard8(), p = s.parseCard8(), c = h; c <= h + p; c += 1) {\n        n[c] = a, a += 1;\n      }\n    }\n  } else throw new Error(\"Unknown encoding format \" + i);\n  return new je(n, t);\n}\nfunction _r(e, r, t) {\n  var a,\n    n,\n    s,\n    i,\n    u = new P(),\n    o = [],\n    l = 0,\n    f = !1,\n    h = !1,\n    p = 0,\n    c = 0,\n    d,\n    x,\n    m,\n    y;\n  if (e.isCIDFont) {\n    var C = e.tables.cff.topDict._fdSelect[r.index],\n      S = e.tables.cff.topDict._fdArray[C];\n    d = S._subrs, x = S._subrsBias, m = S._defaultWidthX, y = S._nominalWidthX;\n  } else d = e.tables.cff.topDict._subrs, x = e.tables.cff.topDict._subrsBias, m = e.tables.cff.topDict._defaultWidthX, y = e.tables.cff.topDict._nominalWidthX;\n  var R = m;\n  function O(F, G) {\n    h && u.closePath(), u.moveTo(F, G), h = !0;\n  }\n  function D() {\n    var F;\n    F = o.length % 2 !== 0, F && !f && (R = o.shift() + y), l += o.length >> 1, o.length = 0, f = !0;\n  }\n  function L(F) {\n    for (var G, Y, Z, j, $, M, N, W, _, V, H, X, A = 0; A < F.length;) {\n      var q = F[A];\n      switch (A += 1, q) {\n        case 1:\n          D();\n          break;\n        case 3:\n          D();\n          break;\n        case 4:\n          o.length > 1 && !f && (R = o.shift() + y, f = !0), c += o.pop(), O(p, c);\n          break;\n        case 5:\n          for (; o.length > 0;) {\n            p += o.shift(), c += o.shift(), u.lineTo(p, c);\n          }\n          break;\n        case 6:\n          for (; o.length > 0 && (p += o.shift(), u.lineTo(p, c), o.length !== 0);) {\n            c += o.shift(), u.lineTo(p, c);\n          }\n          break;\n        case 7:\n          for (; o.length > 0 && (c += o.shift(), u.lineTo(p, c), o.length !== 0);) {\n            p += o.shift(), u.lineTo(p, c);\n          }\n          break;\n        case 8:\n          for (; o.length > 0;) {\n            a = p + o.shift(), n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), p = s + o.shift(), c = i + o.shift(), u.curveTo(a, n, s, i, p, c);\n          }\n          break;\n        case 10:\n          $ = o.pop() + x, M = d[$], M && L(M);\n          break;\n        case 11:\n          return;\n        case 12:\n          switch (q = F[A], A += 1, q) {\n            case 35:\n              a = p + o.shift(), n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), N = s + o.shift(), W = i + o.shift(), _ = N + o.shift(), V = W + o.shift(), H = _ + o.shift(), X = V + o.shift(), p = H + o.shift(), c = X + o.shift(), o.shift(), u.curveTo(a, n, s, i, N, W), u.curveTo(_, V, H, X, p, c);\n              break;\n            case 34:\n              a = p + o.shift(), n = c, s = a + o.shift(), i = n + o.shift(), N = s + o.shift(), W = i, _ = N + o.shift(), V = i, H = _ + o.shift(), X = c, p = H + o.shift(), u.curveTo(a, n, s, i, N, W), u.curveTo(_, V, H, X, p, c);\n              break;\n            case 36:\n              a = p + o.shift(), n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), N = s + o.shift(), W = i, _ = N + o.shift(), V = i, H = _ + o.shift(), X = V + o.shift(), p = H + o.shift(), u.curveTo(a, n, s, i, N, W), u.curveTo(_, V, H, X, p, c);\n              break;\n            case 37:\n              a = p + o.shift(), n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), N = s + o.shift(), W = i + o.shift(), _ = N + o.shift(), V = W + o.shift(), H = _ + o.shift(), X = V + o.shift(), Math.abs(H - p) > Math.abs(X - c) ? p = H + o.shift() : c = X + o.shift(), u.curveTo(a, n, s, i, N, W), u.curveTo(_, V, H, X, p, c);\n              break;\n            default:\n              console.log(\"Glyph \" + r.index + \": unknown operator \" + 1200 + q), o.length = 0;\n          }\n          break;\n        case 14:\n          o.length > 0 && !f && (R = o.shift() + y, f = !0), h && (u.closePath(), h = !1);\n          break;\n        case 18:\n          D();\n          break;\n        case 19:\n        case 20:\n          D(), A += l + 7 >> 3;\n          break;\n        case 21:\n          o.length > 2 && !f && (R = o.shift() + y, f = !0), c += o.pop(), p += o.pop(), O(p, c);\n          break;\n        case 22:\n          o.length > 1 && !f && (R = o.shift() + y, f = !0), p += o.pop(), O(p, c);\n          break;\n        case 23:\n          D();\n          break;\n        case 24:\n          for (; o.length > 2;) {\n            a = p + o.shift(), n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), p = s + o.shift(), c = i + o.shift(), u.curveTo(a, n, s, i, p, c);\n          }\n          p += o.shift(), c += o.shift(), u.lineTo(p, c);\n          break;\n        case 25:\n          for (; o.length > 6;) {\n            p += o.shift(), c += o.shift(), u.lineTo(p, c);\n          }\n          a = p + o.shift(), n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), p = s + o.shift(), c = i + o.shift(), u.curveTo(a, n, s, i, p, c);\n          break;\n        case 26:\n          for (o.length % 2 && (p += o.shift()); o.length > 0;) {\n            a = p, n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), p = s, c = i + o.shift(), u.curveTo(a, n, s, i, p, c);\n          }\n          break;\n        case 27:\n          for (o.length % 2 && (c += o.shift()); o.length > 0;) {\n            a = p + o.shift(), n = c, s = a + o.shift(), i = n + o.shift(), p = s + o.shift(), c = i, u.curveTo(a, n, s, i, p, c);\n          }\n          break;\n        case 28:\n          G = F[A], Y = F[A + 1], o.push((G << 24 | Y << 16) >> 16), A += 2;\n          break;\n        case 29:\n          $ = o.pop() + e.gsubrsBias, M = e.gsubrs[$], M && L(M);\n          break;\n        case 30:\n          for (; o.length > 0 && (a = p, n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), p = s + o.shift(), c = i + (o.length === 1 ? o.shift() : 0), u.curveTo(a, n, s, i, p, c), o.length !== 0);) {\n            a = p + o.shift(), n = c, s = a + o.shift(), i = n + o.shift(), c = i + o.shift(), p = s + (o.length === 1 ? o.shift() : 0), u.curveTo(a, n, s, i, p, c);\n          }\n          break;\n        case 31:\n          for (; o.length > 0 && (a = p + o.shift(), n = c, s = a + o.shift(), i = n + o.shift(), c = i + o.shift(), p = s + (o.length === 1 ? o.shift() : 0), u.curveTo(a, n, s, i, p, c), o.length !== 0);) {\n            a = p, n = c + o.shift(), s = a + o.shift(), i = n + o.shift(), p = s + o.shift(), c = i + (o.length === 1 ? o.shift() : 0), u.curveTo(a, n, s, i, p, c);\n          }\n          break;\n        default:\n          q < 32 ? console.log(\"Glyph \" + r.index + \": unknown operator \" + q) : q < 247 ? o.push(q - 139) : q < 251 ? (G = F[A], A += 1, o.push((q - 247) * 256 + G + 108)) : q < 255 ? (G = F[A], A += 1, o.push(-(q - 251) * 256 - G - 108)) : (G = F[A], Y = F[A + 1], Z = F[A + 2], j = F[A + 3], A += 4, o.push((G << 24 | Y << 16 | Z << 8 | j) / 65536));\n      }\n    }\n  }\n  return L(t), r.advanceWidth = R, u;\n}\nfunction nn(e, r, t, a) {\n  var n = [],\n    s,\n    i = new k.Parser(e, r),\n    u = i.parseCard8();\n  if (u === 0) for (var o = 0; o < t; o++) {\n    if (s = i.parseCard8(), s >= a) throw new Error(\"CFF table CID Font FDSelect has bad FD index value \" + s + \" (FD count \" + a + \")\");\n    n.push(s);\n  } else if (u === 3) {\n    var l = i.parseCard16(),\n      f = i.parseCard16();\n    if (f !== 0) throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad initial GID \" + f);\n    for (var h, p = 0; p < l; p++) {\n      if (s = i.parseCard8(), h = i.parseCard16(), s >= a) throw new Error(\"CFF table CID Font FDSelect has bad FD index value \" + s + \" (FD count \" + a + \")\");\n      if (h > t) throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad GID \" + h);\n      for (; f < h; f++) {\n        n.push(s);\n      }\n      f = h;\n    }\n    if (h !== t) throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad final GID \" + h);\n  } else throw new Error(\"CFF Table CID Font FDSelect table has unsupported format \" + u);\n  return n;\n}\nfunction sn(e, r, t, a) {\n  t.tables.cff = {};\n  var n = en(e, r),\n    s = ve(e, n.endOffset, k.bytesToString),\n    i = ve(e, s.endOffset),\n    u = ve(e, i.endOffset, k.bytesToString),\n    o = ve(e, u.endOffset);\n  t.gsubrs = o.objects, t.gsubrsBias = gr(t.gsubrs);\n  var l = Wr(e, r, i.objects, u.objects);\n  if (l.length !== 1) throw new Error(\"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" + l.length);\n  var f = l[0];\n  if (t.tables.cff.topDict = f, f._privateDict && (t.defaultWidthX = f._privateDict.defaultWidthX, t.nominalWidthX = f._privateDict.nominalWidthX), f.ros[0] !== void 0 && f.ros[1] !== void 0 && (t.isCIDFont = !0), t.isCIDFont) {\n    var h = f.fdArray,\n      p = f.fdSelect;\n    if (h === 0 || p === 0) throw new Error(\"Font is marked as a CID font, but FDArray and/or FDSelect information is missing\");\n    h += r;\n    var c = ve(e, h),\n      d = Wr(e, r, c.objects, u.objects);\n    f._fdArray = d, p += r, f._fdSelect = nn(e, p, t.numGlyphs, d.length);\n  }\n  var x = r + f[\"private\"][1],\n    m = It(e, x, f[\"private\"][0], u.objects);\n  if (t.defaultWidthX = m.defaultWidthX, t.nominalWidthX = m.nominalWidthX, m.subrs !== 0) {\n    var y = x + m.subrs,\n      C = ve(e, y);\n    t.subrs = C.objects, t.subrsBias = gr(t.subrs);\n  } else t.subrs = [], t.subrsBias = 0;\n  var S;\n  a.lowMemory ? (S = Qa(e, r + f.charStrings), t.nGlyphs = S.offsets.length) : (S = ve(e, r + f.charStrings), t.nGlyphs = S.objects.length);\n  var R = tn(e, r + f.charset, t.nGlyphs, u.objects);\n  if (f.encoding === 0 ? t.cffEncoding = new je(Na, R) : f.encoding === 1 ? t.cffEncoding = new je(Ha, R) : t.cffEncoding = an(e, r + f.encoding, R), t.encoding = t.encoding || t.cffEncoding, t.glyphs = new ue.GlyphSet(t), a.lowMemory) t._push = function (L) {\n    var F = Ka(L, S.offsets, e, r + f.charStrings);\n    t.glyphs.push(L, ue.cffGlyphLoader(t, L, _r, F));\n  };else for (var O = 0; O < t.nGlyphs; O += 1) {\n    var D = S.objects[O];\n    t.glyphs.push(O, ue.cffGlyphLoader(t, O, _r, D));\n  }\n}\nfunction Mt(e, r) {\n  var t,\n    a = qe.indexOf(e);\n  return a >= 0 && (t = a), a = r.indexOf(e), a >= 0 ? t = a + qe.length : (t = qe.length + r.length, r.push(e)), t;\n}\nfunction on() {\n  return new b.Record(\"Header\", [{\n    name: \"major\",\n    type: \"Card8\",\n    value: 1\n  }, {\n    name: \"minor\",\n    type: \"Card8\",\n    value: 0\n  }, {\n    name: \"hdrSize\",\n    type: \"Card8\",\n    value: 4\n  }, {\n    name: \"major\",\n    type: \"Card8\",\n    value: 1\n  }]);\n}\nfunction un(e) {\n  var r = new b.Record(\"Name INDEX\", [{\n    name: \"names\",\n    type: \"INDEX\",\n    value: []\n  }]);\n  r.names = [];\n  for (var t = 0; t < e.length; t += 1) {\n    r.names.push({\n      name: \"name_\" + t,\n      type: \"NAME\",\n      value: e[t]\n    });\n  }\n  return r;\n}\nfunction Pt(e, r, t) {\n  for (var a = {}, n = 0; n < e.length; n += 1) {\n    var s = e[n],\n      i = r[s.name];\n    i !== void 0 && !Rt(i, s.value) && (s.type === \"SID\" && (i = Mt(i, t)), a[s.op] = {\n      name: s.name,\n      type: s.type,\n      value: i\n    });\n  }\n  return a;\n}\nfunction Vr(e, r) {\n  var t = new b.Record(\"Top DICT\", [{\n    name: \"dict\",\n    type: \"DICT\",\n    value: {}\n  }]);\n  return t.dict = Pt(At, e, r), t;\n}\nfunction qr(e) {\n  var r = new b.Record(\"Top DICT INDEX\", [{\n    name: \"topDicts\",\n    type: \"INDEX\",\n    value: []\n  }]);\n  return r.topDicts = [{\n    name: \"topDict_0\",\n    type: \"TABLE\",\n    value: e\n  }], r;\n}\nfunction ln(e) {\n  var r = new b.Record(\"String INDEX\", [{\n    name: \"strings\",\n    type: \"INDEX\",\n    value: []\n  }]);\n  r.strings = [];\n  for (var t = 0; t < e.length; t += 1) {\n    r.strings.push({\n      name: \"string_\" + t,\n      type: \"STRING\",\n      value: e[t]\n    });\n  }\n  return r;\n}\nfunction fn() {\n  return new b.Record(\"Global Subr INDEX\", [{\n    name: \"subrs\",\n    type: \"INDEX\",\n    value: []\n  }]);\n}\nfunction pn(e, r) {\n  for (var t = new b.Record(\"Charsets\", [{\n      name: \"format\",\n      type: \"Card8\",\n      value: 0\n    }]), a = 0; a < e.length; a += 1) {\n    var n = e[a],\n      s = Mt(n, r);\n    t.fields.push({\n      name: \"glyph_\" + a,\n      type: \"SID\",\n      value: s\n    });\n  }\n  return t;\n}\nfunction hn(e) {\n  var r = [],\n    t = e.path;\n  r.push({\n    name: \"width\",\n    type: \"NUMBER\",\n    value: e.advanceWidth\n  });\n  for (var a = 0, n = 0, s = 0; s < t.commands.length; s += 1) {\n    var i = void 0,\n      u = void 0,\n      o = t.commands[s];\n    if (o.type === \"Q\") {\n      var l = .3333333333333333,\n        f = 2 / 3;\n      o = {\n        type: \"C\",\n        x: o.x,\n        y: o.y,\n        x1: Math.round(l * a + f * o.x1),\n        y1: Math.round(l * n + f * o.y1),\n        x2: Math.round(l * o.x + f * o.x1),\n        y2: Math.round(l * o.y + f * o.y1)\n      };\n    }\n    if (o.type === \"M\") i = Math.round(o.x - a), u = Math.round(o.y - n), r.push({\n      name: \"dx\",\n      type: \"NUMBER\",\n      value: i\n    }), r.push({\n      name: \"dy\",\n      type: \"NUMBER\",\n      value: u\n    }), r.push({\n      name: \"rmoveto\",\n      type: \"OP\",\n      value: 21\n    }), a = Math.round(o.x), n = Math.round(o.y);else if (o.type === \"L\") i = Math.round(o.x - a), u = Math.round(o.y - n), r.push({\n      name: \"dx\",\n      type: \"NUMBER\",\n      value: i\n    }), r.push({\n      name: \"dy\",\n      type: \"NUMBER\",\n      value: u\n    }), r.push({\n      name: \"rlineto\",\n      type: \"OP\",\n      value: 5\n    }), a = Math.round(o.x), n = Math.round(o.y);else if (o.type === \"C\") {\n      var h = Math.round(o.x1 - a),\n        p = Math.round(o.y1 - n),\n        c = Math.round(o.x2 - o.x1),\n        d = Math.round(o.y2 - o.y1);\n      i = Math.round(o.x - o.x2), u = Math.round(o.y - o.y2), r.push({\n        name: \"dx1\",\n        type: \"NUMBER\",\n        value: h\n      }), r.push({\n        name: \"dy1\",\n        type: \"NUMBER\",\n        value: p\n      }), r.push({\n        name: \"dx2\",\n        type: \"NUMBER\",\n        value: c\n      }), r.push({\n        name: \"dy2\",\n        type: \"NUMBER\",\n        value: d\n      }), r.push({\n        name: \"dx\",\n        type: \"NUMBER\",\n        value: i\n      }), r.push({\n        name: \"dy\",\n        type: \"NUMBER\",\n        value: u\n      }), r.push({\n        name: \"rrcurveto\",\n        type: \"OP\",\n        value: 8\n      }), a = Math.round(o.x), n = Math.round(o.y);\n    }\n  }\n  return r.push({\n    name: \"endchar\",\n    type: \"OP\",\n    value: 14\n  }), r;\n}\nfunction cn(e) {\n  for (var r = new b.Record(\"CharStrings INDEX\", [{\n      name: \"charStrings\",\n      type: \"INDEX\",\n      value: []\n    }]), t = 0; t < e.length; t += 1) {\n    var a = e.get(t),\n      n = hn(a);\n    r.charStrings.push({\n      name: a.name,\n      type: \"CHARSTRING\",\n      value: n\n    });\n  }\n  return r;\n}\nfunction vn(e, r) {\n  var t = new b.Record(\"Private DICT\", [{\n    name: \"dict\",\n    type: \"DICT\",\n    value: {}\n  }]);\n  return t.dict = Pt(Bt, e, r), t;\n}\nfunction dn(e, r) {\n  for (var t = new b.Table(\"CFF \", [{\n      name: \"header\",\n      type: \"RECORD\"\n    }, {\n      name: \"nameIndex\",\n      type: \"RECORD\"\n    }, {\n      name: \"topDictIndex\",\n      type: \"RECORD\"\n    }, {\n      name: \"stringIndex\",\n      type: \"RECORD\"\n    }, {\n      name: \"globalSubrIndex\",\n      type: \"RECORD\"\n    }, {\n      name: \"charsets\",\n      type: \"RECORD\"\n    }, {\n      name: \"charStringsIndex\",\n      type: \"RECORD\"\n    }, {\n      name: \"privateDict\",\n      type: \"RECORD\"\n    }]), a = 1 / r.unitsPerEm, n = {\n      version: r.version,\n      fullName: r.fullName,\n      familyName: r.familyName,\n      weight: r.weightName,\n      fontBBox: r.fontBBox || [0, 0, 0, 0],\n      fontMatrix: [a, 0, 0, a, 0, 0],\n      charset: 999,\n      encoding: 0,\n      charStrings: 999,\n      \"private\": [0, 999]\n    }, s = {}, i = [], u, o = 1; o < e.length; o += 1) {\n    u = e.get(o), i.push(u.name);\n  }\n  var l = [];\n  t.header = on(), t.nameIndex = un([r.postScriptName]);\n  var f = Vr(n, l);\n  t.topDictIndex = qr(f), t.globalSubrIndex = fn(), t.charsets = pn(i, l), t.charStringsIndex = cn(e), t.privateDict = vn(s, l), t.stringIndex = ln(l);\n  var h = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();\n  return n.charset = h, n.encoding = 0, n.charStrings = n.charset + t.charsets.sizeOf(), n[\"private\"][1] = n.charStrings + t.charStringsIndex.sizeOf(), f = Vr(n, l), t.topDictIndex = qr(f), t;\n}\nvar Gt = {\n  parse: sn,\n  make: dn\n};\nfunction gn(e, r) {\n  var t = {},\n    a = new k.Parser(e, r);\n  return t.version = a.parseVersion(), t.fontRevision = Math.round(a.parseFixed() * 1e3) / 1e3, t.checkSumAdjustment = a.parseULong(), t.magicNumber = a.parseULong(), U.argument(t.magicNumber === 1594834165, \"Font header has wrong magic number.\"), t.flags = a.parseUShort(), t.unitsPerEm = a.parseUShort(), t.created = a.parseLongDateTime(), t.modified = a.parseLongDateTime(), t.xMin = a.parseShort(), t.yMin = a.parseShort(), t.xMax = a.parseShort(), t.yMax = a.parseShort(), t.macStyle = a.parseUShort(), t.lowestRecPPEM = a.parseUShort(), t.fontDirectionHint = a.parseShort(), t.indexToLocFormat = a.parseShort(), t.glyphDataFormat = a.parseShort(), t;\n}\nfunction mn(e) {\n  var r = Math.round(new Date().getTime() / 1e3) + 2082844800,\n    t = r;\n  return e.createdTimestamp && (t = e.createdTimestamp + 2082844800), new b.Table(\"head\", [{\n    name: \"version\",\n    type: \"FIXED\",\n    value: 65536\n  }, {\n    name: \"fontRevision\",\n    type: \"FIXED\",\n    value: 65536\n  }, {\n    name: \"checkSumAdjustment\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"magicNumber\",\n    type: \"ULONG\",\n    value: 1594834165\n  }, {\n    name: \"flags\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"unitsPerEm\",\n    type: \"USHORT\",\n    value: 1e3\n  }, {\n    name: \"created\",\n    type: \"LONGDATETIME\",\n    value: t\n  }, {\n    name: \"modified\",\n    type: \"LONGDATETIME\",\n    value: r\n  }, {\n    name: \"xMin\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"yMin\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"xMax\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"yMax\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"macStyle\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"lowestRecPPEM\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"fontDirectionHint\",\n    type: \"SHORT\",\n    value: 2\n  }, {\n    name: \"indexToLocFormat\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"glyphDataFormat\",\n    type: \"SHORT\",\n    value: 0\n  }], e);\n}\nvar Nt = {\n  parse: gn,\n  make: mn\n};\nfunction yn(e, r) {\n  var t = {},\n    a = new k.Parser(e, r);\n  return t.version = a.parseVersion(), t.ascender = a.parseShort(), t.descender = a.parseShort(), t.lineGap = a.parseShort(), t.advanceWidthMax = a.parseUShort(), t.minLeftSideBearing = a.parseShort(), t.minRightSideBearing = a.parseShort(), t.xMaxExtent = a.parseShort(), t.caretSlopeRise = a.parseShort(), t.caretSlopeRun = a.parseShort(), t.caretOffset = a.parseShort(), a.relativeOffset += 8, t.metricDataFormat = a.parseShort(), t.numberOfHMetrics = a.parseUShort(), t;\n}\nfunction xn(e) {\n  return new b.Table(\"hhea\", [{\n    name: \"version\",\n    type: \"FIXED\",\n    value: 65536\n  }, {\n    name: \"ascender\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"descender\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"lineGap\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"advanceWidthMax\",\n    type: \"UFWORD\",\n    value: 0\n  }, {\n    name: \"minLeftSideBearing\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"minRightSideBearing\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"xMaxExtent\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"caretSlopeRise\",\n    type: \"SHORT\",\n    value: 1\n  }, {\n    name: \"caretSlopeRun\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"caretOffset\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"reserved1\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"reserved2\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"reserved3\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"reserved4\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"metricDataFormat\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"numberOfHMetrics\",\n    type: \"USHORT\",\n    value: 0\n  }], e);\n}\nvar Ht = {\n  parse: yn,\n  make: xn\n};\nfunction bn(e, r, t, a, n) {\n  for (var s, i, u = new k.Parser(e, r), o = 0; o < a; o += 1) {\n    o < t && (s = u.parseUShort(), i = u.parseShort());\n    var l = n.get(o);\n    l.advanceWidth = s, l.leftSideBearing = i;\n  }\n}\nfunction Sn(e, r, t, a, n) {\n  e._hmtxTableData = {};\n  for (var s, i, u = new k.Parser(r, t), o = 0; o < n; o += 1) {\n    o < a && (s = u.parseUShort(), i = u.parseShort()), e._hmtxTableData[o] = {\n      advanceWidth: s,\n      leftSideBearing: i\n    };\n  }\n}\nfunction Tn(e, r, t, a, n, s, i) {\n  i.lowMemory ? Sn(e, r, t, a, n) : bn(r, t, a, n, s);\n}\nfunction kn(e) {\n  for (var r = new b.Table(\"hmtx\", []), t = 0; t < e.length; t += 1) {\n    var a = e.get(t),\n      n = a.advanceWidth || 0,\n      s = a.leftSideBearing || 0;\n    r.fields.push({\n      name: \"advanceWidth_\" + t,\n      type: \"USHORT\",\n      value: n\n    }), r.fields.push({\n      name: \"leftSideBearing_\" + t,\n      type: \"SHORT\",\n      value: s\n    });\n  }\n  return r;\n}\nvar zt = {\n  parse: Tn,\n  make: kn\n};\nfunction Fn(e) {\n  for (var r = new b.Table(\"ltag\", [{\n      name: \"version\",\n      type: \"ULONG\",\n      value: 1\n    }, {\n      name: \"flags\",\n      type: \"ULONG\",\n      value: 0\n    }, {\n      name: \"numTags\",\n      type: \"ULONG\",\n      value: e.length\n    }]), t = \"\", a = 12 + e.length * 4, n = 0; n < e.length; ++n) {\n    var s = t.indexOf(e[n]);\n    s < 0 && (s = t.length, t += e[n]), r.fields.push({\n      name: \"offset \" + n,\n      type: \"USHORT\",\n      value: a + s\n    }), r.fields.push({\n      name: \"length \" + n,\n      type: \"USHORT\",\n      value: e[n].length\n    });\n  }\n  return r.fields.push({\n    name: \"stringPool\",\n    type: \"CHARARRAY\",\n    value: t\n  }), r;\n}\nfunction Un(e, r) {\n  var t = new k.Parser(e, r),\n    a = t.parseULong();\n  U.argument(a === 1, \"Unsupported ltag table version.\"), t.skip(\"uLong\", 1);\n  for (var n = t.parseULong(), s = [], i = 0; i < n; i++) {\n    for (var u = \"\", o = r + t.parseUShort(), l = t.parseUShort(), f = o; f < o + l; ++f) {\n      u += String.fromCharCode(e.getInt8(f));\n    }\n    s.push(u);\n  }\n  return s;\n}\nvar Wt = {\n  make: Fn,\n  parse: Un\n};\nfunction Cn(e, r) {\n  var t = {},\n    a = new k.Parser(e, r);\n  return t.version = a.parseVersion(), t.numGlyphs = a.parseUShort(), t.version === 1 && (t.maxPoints = a.parseUShort(), t.maxContours = a.parseUShort(), t.maxCompositePoints = a.parseUShort(), t.maxCompositeContours = a.parseUShort(), t.maxZones = a.parseUShort(), t.maxTwilightPoints = a.parseUShort(), t.maxStorage = a.parseUShort(), t.maxFunctionDefs = a.parseUShort(), t.maxInstructionDefs = a.parseUShort(), t.maxStackElements = a.parseUShort(), t.maxSizeOfInstructions = a.parseUShort(), t.maxComponentElements = a.parseUShort(), t.maxComponentDepth = a.parseUShort()), t;\n}\nfunction En(e) {\n  return new b.Table(\"maxp\", [{\n    name: \"version\",\n    type: \"FIXED\",\n    value: 20480\n  }, {\n    name: \"numGlyphs\",\n    type: \"USHORT\",\n    value: e\n  }]);\n}\nvar _t = {\n    parse: Cn,\n    make: En\n  },\n  Vt = [\"copyright\", \"fontFamily\", \"fontSubfamily\", \"uniqueID\", \"fullName\", \"version\", \"postScriptName\", \"trademark\", \"manufacturer\", \"designer\", \"description\", \"manufacturerURL\", \"designerURL\", \"license\", \"licenseURL\", \"reserved\", \"preferredFamily\", \"preferredSubfamily\", \"compatibleFullName\", \"sampleText\", \"postScriptFindFontName\", \"wwsFamily\", \"wwsSubfamily\"],\n  qt = {\n    0: \"en\",\n    1: \"fr\",\n    2: \"de\",\n    3: \"it\",\n    4: \"nl\",\n    5: \"sv\",\n    6: \"es\",\n    7: \"da\",\n    8: \"pt\",\n    9: \"no\",\n    10: \"he\",\n    11: \"ja\",\n    12: \"ar\",\n    13: \"fi\",\n    14: \"el\",\n    15: \"is\",\n    16: \"mt\",\n    17: \"tr\",\n    18: \"hr\",\n    19: \"zh-Hant\",\n    20: \"ur\",\n    21: \"hi\",\n    22: \"th\",\n    23: \"ko\",\n    24: \"lt\",\n    25: \"pl\",\n    26: \"hu\",\n    27: \"es\",\n    28: \"lv\",\n    29: \"se\",\n    30: \"fo\",\n    31: \"fa\",\n    32: \"ru\",\n    33: \"zh\",\n    34: \"nl-BE\",\n    35: \"ga\",\n    36: \"sq\",\n    37: \"ro\",\n    38: \"cz\",\n    39: \"sk\",\n    40: \"si\",\n    41: \"yi\",\n    42: \"sr\",\n    43: \"mk\",\n    44: \"bg\",\n    45: \"uk\",\n    46: \"be\",\n    47: \"uz\",\n    48: \"kk\",\n    49: \"az-Cyrl\",\n    50: \"az-Arab\",\n    51: \"hy\",\n    52: \"ka\",\n    53: \"mo\",\n    54: \"ky\",\n    55: \"tg\",\n    56: \"tk\",\n    57: \"mn-CN\",\n    58: \"mn\",\n    59: \"ps\",\n    60: \"ks\",\n    61: \"ku\",\n    62: \"sd\",\n    63: \"bo\",\n    64: \"ne\",\n    65: \"sa\",\n    66: \"mr\",\n    67: \"bn\",\n    68: \"as\",\n    69: \"gu\",\n    70: \"pa\",\n    71: \"or\",\n    72: \"ml\",\n    73: \"kn\",\n    74: \"ta\",\n    75: \"te\",\n    76: \"si\",\n    77: \"my\",\n    78: \"km\",\n    79: \"lo\",\n    80: \"vi\",\n    81: \"id\",\n    82: \"tl\",\n    83: \"ms\",\n    84: \"ms-Arab\",\n    85: \"am\",\n    86: \"ti\",\n    87: \"om\",\n    88: \"so\",\n    89: \"sw\",\n    90: \"rw\",\n    91: \"rn\",\n    92: \"ny\",\n    93: \"mg\",\n    94: \"eo\",\n    128: \"cy\",\n    129: \"eu\",\n    130: \"ca\",\n    131: \"la\",\n    132: \"qu\",\n    133: \"gn\",\n    134: \"ay\",\n    135: \"tt\",\n    136: \"ug\",\n    137: \"dz\",\n    138: \"jv\",\n    139: \"su\",\n    140: \"gl\",\n    141: \"af\",\n    142: \"br\",\n    143: \"iu\",\n    144: \"gd\",\n    145: \"gv\",\n    146: \"ga\",\n    147: \"to\",\n    148: \"el-polyton\",\n    149: \"kl\",\n    150: \"az\",\n    151: \"nn\"\n  },\n  On = {\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 0,\n    4: 0,\n    5: 0,\n    6: 0,\n    7: 0,\n    8: 0,\n    9: 0,\n    10: 5,\n    11: 1,\n    12: 4,\n    13: 0,\n    14: 6,\n    15: 0,\n    16: 0,\n    17: 0,\n    18: 0,\n    19: 2,\n    20: 4,\n    21: 9,\n    22: 21,\n    23: 3,\n    24: 29,\n    25: 29,\n    26: 29,\n    27: 29,\n    28: 29,\n    29: 0,\n    30: 0,\n    31: 4,\n    32: 7,\n    33: 25,\n    34: 0,\n    35: 0,\n    36: 0,\n    37: 0,\n    38: 29,\n    39: 29,\n    40: 0,\n    41: 5,\n    42: 7,\n    43: 7,\n    44: 7,\n    45: 7,\n    46: 7,\n    47: 7,\n    48: 7,\n    49: 7,\n    50: 4,\n    51: 24,\n    52: 23,\n    53: 7,\n    54: 7,\n    55: 7,\n    56: 7,\n    57: 27,\n    58: 7,\n    59: 4,\n    60: 4,\n    61: 4,\n    62: 4,\n    63: 26,\n    64: 9,\n    65: 9,\n    66: 9,\n    67: 13,\n    68: 13,\n    69: 11,\n    70: 10,\n    71: 12,\n    72: 17,\n    73: 16,\n    74: 14,\n    75: 15,\n    76: 18,\n    77: 19,\n    78: 20,\n    79: 22,\n    80: 30,\n    81: 0,\n    82: 0,\n    83: 0,\n    84: 4,\n    85: 28,\n    86: 28,\n    87: 28,\n    88: 0,\n    89: 0,\n    90: 0,\n    91: 0,\n    92: 0,\n    93: 0,\n    94: 0,\n    128: 0,\n    129: 0,\n    130: 0,\n    131: 0,\n    132: 0,\n    133: 0,\n    134: 0,\n    135: 7,\n    136: 4,\n    137: 26,\n    138: 0,\n    139: 0,\n    140: 0,\n    141: 0,\n    142: 0,\n    143: 28,\n    144: 0,\n    145: 0,\n    146: 0,\n    147: 0,\n    148: 6,\n    149: 0,\n    150: 0,\n    151: 0\n  },\n  Xt = {\n    1078: \"af\",\n    1052: \"sq\",\n    1156: \"gsw\",\n    1118: \"am\",\n    5121: \"ar-DZ\",\n    15361: \"ar-BH\",\n    3073: \"ar\",\n    2049: \"ar-IQ\",\n    11265: \"ar-JO\",\n    13313: \"ar-KW\",\n    12289: \"ar-LB\",\n    4097: \"ar-LY\",\n    6145: \"ary\",\n    8193: \"ar-OM\",\n    16385: \"ar-QA\",\n    1025: \"ar-SA\",\n    10241: \"ar-SY\",\n    7169: \"aeb\",\n    14337: \"ar-AE\",\n    9217: \"ar-YE\",\n    1067: \"hy\",\n    1101: \"as\",\n    2092: \"az-Cyrl\",\n    1068: \"az\",\n    1133: \"ba\",\n    1069: \"eu\",\n    1059: \"be\",\n    2117: \"bn\",\n    1093: \"bn-IN\",\n    8218: \"bs-Cyrl\",\n    5146: \"bs\",\n    1150: \"br\",\n    1026: \"bg\",\n    1027: \"ca\",\n    3076: \"zh-HK\",\n    5124: \"zh-MO\",\n    2052: \"zh\",\n    4100: \"zh-SG\",\n    1028: \"zh-TW\",\n    1155: \"co\",\n    1050: \"hr\",\n    4122: \"hr-BA\",\n    1029: \"cs\",\n    1030: \"da\",\n    1164: \"prs\",\n    1125: \"dv\",\n    2067: \"nl-BE\",\n    1043: \"nl\",\n    3081: \"en-AU\",\n    10249: \"en-BZ\",\n    4105: \"en-CA\",\n    9225: \"en-029\",\n    16393: \"en-IN\",\n    6153: \"en-IE\",\n    8201: \"en-JM\",\n    17417: \"en-MY\",\n    5129: \"en-NZ\",\n    13321: \"en-PH\",\n    18441: \"en-SG\",\n    7177: \"en-ZA\",\n    11273: \"en-TT\",\n    2057: \"en-GB\",\n    1033: \"en\",\n    12297: \"en-ZW\",\n    1061: \"et\",\n    1080: \"fo\",\n    1124: \"fil\",\n    1035: \"fi\",\n    2060: \"fr-BE\",\n    3084: \"fr-CA\",\n    1036: \"fr\",\n    5132: \"fr-LU\",\n    6156: \"fr-MC\",\n    4108: \"fr-CH\",\n    1122: \"fy\",\n    1110: \"gl\",\n    1079: \"ka\",\n    3079: \"de-AT\",\n    1031: \"de\",\n    5127: \"de-LI\",\n    4103: \"de-LU\",\n    2055: \"de-CH\",\n    1032: \"el\",\n    1135: \"kl\",\n    1095: \"gu\",\n    1128: \"ha\",\n    1037: \"he\",\n    1081: \"hi\",\n    1038: \"hu\",\n    1039: \"is\",\n    1136: \"ig\",\n    1057: \"id\",\n    1117: \"iu\",\n    2141: \"iu-Latn\",\n    2108: \"ga\",\n    1076: \"xh\",\n    1077: \"zu\",\n    1040: \"it\",\n    2064: \"it-CH\",\n    1041: \"ja\",\n    1099: \"kn\",\n    1087: \"kk\",\n    1107: \"km\",\n    1158: \"quc\",\n    1159: \"rw\",\n    1089: \"sw\",\n    1111: \"kok\",\n    1042: \"ko\",\n    1088: \"ky\",\n    1108: \"lo\",\n    1062: \"lv\",\n    1063: \"lt\",\n    2094: \"dsb\",\n    1134: \"lb\",\n    1071: \"mk\",\n    2110: \"ms-BN\",\n    1086: \"ms\",\n    1100: \"ml\",\n    1082: \"mt\",\n    1153: \"mi\",\n    1146: \"arn\",\n    1102: \"mr\",\n    1148: \"moh\",\n    1104: \"mn\",\n    2128: \"mn-CN\",\n    1121: \"ne\",\n    1044: \"nb\",\n    2068: \"nn\",\n    1154: \"oc\",\n    1096: \"or\",\n    1123: \"ps\",\n    1045: \"pl\",\n    1046: \"pt\",\n    2070: \"pt-PT\",\n    1094: \"pa\",\n    1131: \"qu-BO\",\n    2155: \"qu-EC\",\n    3179: \"qu\",\n    1048: \"ro\",\n    1047: \"rm\",\n    1049: \"ru\",\n    9275: \"smn\",\n    4155: \"smj-NO\",\n    5179: \"smj\",\n    3131: \"se-FI\",\n    1083: \"se\",\n    2107: \"se-SE\",\n    8251: \"sms\",\n    6203: \"sma-NO\",\n    7227: \"sms\",\n    1103: \"sa\",\n    7194: \"sr-Cyrl-BA\",\n    3098: \"sr\",\n    6170: \"sr-Latn-BA\",\n    2074: \"sr-Latn\",\n    1132: \"nso\",\n    1074: \"tn\",\n    1115: \"si\",\n    1051: \"sk\",\n    1060: \"sl\",\n    11274: \"es-AR\",\n    16394: \"es-BO\",\n    13322: \"es-CL\",\n    9226: \"es-CO\",\n    5130: \"es-CR\",\n    7178: \"es-DO\",\n    12298: \"es-EC\",\n    17418: \"es-SV\",\n    4106: \"es-GT\",\n    18442: \"es-HN\",\n    2058: \"es-MX\",\n    19466: \"es-NI\",\n    6154: \"es-PA\",\n    15370: \"es-PY\",\n    10250: \"es-PE\",\n    20490: \"es-PR\",\n    3082: \"es\",\n    1034: \"es\",\n    21514: \"es-US\",\n    14346: \"es-UY\",\n    8202: \"es-VE\",\n    2077: \"sv-FI\",\n    1053: \"sv\",\n    1114: \"syr\",\n    1064: \"tg\",\n    2143: \"tzm\",\n    1097: \"ta\",\n    1092: \"tt\",\n    1098: \"te\",\n    1054: \"th\",\n    1105: \"bo\",\n    1055: \"tr\",\n    1090: \"tk\",\n    1152: \"ug\",\n    1058: \"uk\",\n    1070: \"hsb\",\n    1056: \"ur\",\n    2115: \"uz-Cyrl\",\n    1091: \"uz\",\n    1066: \"vi\",\n    1106: \"cy\",\n    1160: \"wo\",\n    1157: \"sah\",\n    1144: \"ii\",\n    1130: \"yo\"\n  };\nfunction Ln(e, r, t) {\n  switch (e) {\n    case 0:\n      if (r === 65535) return \"und\";\n      if (t) return t[r];\n      break;\n    case 1:\n      return qt[r];\n    case 3:\n      return Xt[r];\n  }\n}\nvar mr = \"utf-16\",\n  Rn = {\n    0: \"macintosh\",\n    1: \"x-mac-japanese\",\n    2: \"x-mac-chinesetrad\",\n    3: \"x-mac-korean\",\n    6: \"x-mac-greek\",\n    7: \"x-mac-cyrillic\",\n    9: \"x-mac-devanagai\",\n    10: \"x-mac-gurmukhi\",\n    11: \"x-mac-gujarati\",\n    12: \"x-mac-oriya\",\n    13: \"x-mac-bengali\",\n    14: \"x-mac-tamil\",\n    15: \"x-mac-telugu\",\n    16: \"x-mac-kannada\",\n    17: \"x-mac-malayalam\",\n    18: \"x-mac-sinhalese\",\n    19: \"x-mac-burmese\",\n    20: \"x-mac-khmer\",\n    21: \"x-mac-thai\",\n    22: \"x-mac-lao\",\n    23: \"x-mac-georgian\",\n    24: \"x-mac-armenian\",\n    25: \"x-mac-chinesesimp\",\n    26: \"x-mac-tibetan\",\n    27: \"x-mac-mongolian\",\n    28: \"x-mac-ethiopic\",\n    29: \"x-mac-ce\",\n    30: \"x-mac-vietnamese\",\n    31: \"x-mac-extarabic\"\n  },\n  wn = {\n    15: \"x-mac-icelandic\",\n    17: \"x-mac-turkish\",\n    18: \"x-mac-croatian\",\n    24: \"x-mac-ce\",\n    25: \"x-mac-ce\",\n    26: \"x-mac-ce\",\n    27: \"x-mac-ce\",\n    28: \"x-mac-ce\",\n    30: \"x-mac-icelandic\",\n    37: \"x-mac-romanian\",\n    38: \"x-mac-ce\",\n    39: \"x-mac-ce\",\n    40: \"x-mac-ce\",\n    143: \"x-mac-inuit\",\n    146: \"x-mac-gaelic\"\n  };\nfunction Yt(e, r, t) {\n  switch (e) {\n    case 0:\n      return mr;\n    case 1:\n      return wn[t] || Rn[r];\n    case 3:\n      if (r === 1 || r === 10) return mr;\n      break;\n  }\n}\nfunction Dn(e, r, t) {\n  for (var a = {}, n = new k.Parser(e, r), s = n.parseUShort(), i = n.parseUShort(), u = n.offset + n.parseUShort(), o = 0; o < i; o++) {\n    var l = n.parseUShort(),\n      f = n.parseUShort(),\n      h = n.parseUShort(),\n      p = n.parseUShort(),\n      c = Vt[p] || p,\n      d = n.parseUShort(),\n      x = n.parseUShort(),\n      m = Ln(l, h, t),\n      y = Yt(l, f, h);\n    if (y !== void 0 && m !== void 0) {\n      var C = void 0;\n      if (y === mr ? C = Fe.UTF16(e, u + x, d) : C = Fe.MACSTRING(e, u + x, d, y), C) {\n        var S = a[c];\n        S === void 0 && (S = a[c] = {}), S[m] = C;\n      }\n    }\n  }\n  var R = 0;\n  return s === 1 && (R = n.parseUShort()), a;\n}\nfunction nr(e) {\n  var r = {};\n  for (var t in e) {\n    r[e[t]] = parseInt(t);\n  }\n  return r;\n}\nfunction Xr(e, r, t, a, n, s) {\n  return new b.Record(\"NameRecord\", [{\n    name: \"platformID\",\n    type: \"USHORT\",\n    value: e\n  }, {\n    name: \"encodingID\",\n    type: \"USHORT\",\n    value: r\n  }, {\n    name: \"languageID\",\n    type: \"USHORT\",\n    value: t\n  }, {\n    name: \"nameID\",\n    type: \"USHORT\",\n    value: a\n  }, {\n    name: \"length\",\n    type: \"USHORT\",\n    value: n\n  }, {\n    name: \"offset\",\n    type: \"USHORT\",\n    value: s\n  }]);\n}\nfunction An(e, r) {\n  var t = e.length,\n    a = r.length - t + 1;\n  e: for (var n = 0; n < a; n++) {\n    for (; n < a; n++) {\n      for (var s = 0; s < t; s++) {\n        if (r[n + s] !== e[s]) continue e;\n      }\n      return n;\n    }\n  }\n  return -1;\n}\nfunction Yr(e, r) {\n  var t = An(e, r);\n  if (t < 0) {\n    t = r.length;\n    for (var a = 0, n = e.length; a < n; ++a) {\n      r.push(e[a]);\n    }\n  }\n  return t;\n}\nfunction Bn(e, r) {\n  var t,\n    a = [],\n    n = {},\n    s = nr(Vt);\n  for (var i in e) {\n    var u = s[i];\n    if (u === void 0 && (u = i), t = parseInt(u), isNaN(t)) throw new Error('Name table entry \"' + i + '\" does not exist, see nameTableNames for complete list.');\n    n[t] = e[i], a.push(t);\n  }\n  for (var o = nr(qt), l = nr(Xt), f = [], h = [], p = 0; p < a.length; p++) {\n    t = a[p];\n    var c = n[t];\n    for (var d in c) {\n      var x = c[d],\n        m = 1,\n        y = o[d],\n        C = On[y],\n        S = Yt(m, C, y),\n        R = g.MACSTRING(x, S);\n      R === void 0 && (m = 0, y = r.indexOf(d), y < 0 && (y = r.length, r.push(d)), C = 4, R = g.UTF16(x));\n      var O = Yr(R, h);\n      f.push(Xr(m, C, y, t, R.length, O));\n      var D = l[d];\n      if (D !== void 0) {\n        var L = g.UTF16(x),\n          F = Yr(L, h);\n        f.push(Xr(3, 1, D, t, L.length, F));\n      }\n    }\n  }\n  f.sort(function (Z, j) {\n    return Z.platformID - j.platformID || Z.encodingID - j.encodingID || Z.languageID - j.languageID || Z.nameID - j.nameID;\n  });\n  for (var G = new b.Table(\"name\", [{\n      name: \"format\",\n      type: \"USHORT\",\n      value: 0\n    }, {\n      name: \"count\",\n      type: \"USHORT\",\n      value: f.length\n    }, {\n      name: \"stringOffset\",\n      type: \"USHORT\",\n      value: 6 + f.length * 12\n    }]), Y = 0; Y < f.length; Y++) {\n    G.fields.push({\n      name: \"record_\" + Y,\n      type: \"RECORD\",\n      value: f[Y]\n    });\n  }\n  return G.fields.push({\n    name: \"strings\",\n    type: \"LITERAL\",\n    value: h\n  }), G;\n}\nvar Zt = {\n    parse: Dn,\n    make: Bn\n  },\n  yr = [{\n    begin: 0,\n    end: 127\n  }, {\n    begin: 128,\n    end: 255\n  }, {\n    begin: 256,\n    end: 383\n  }, {\n    begin: 384,\n    end: 591\n  }, {\n    begin: 592,\n    end: 687\n  }, {\n    begin: 688,\n    end: 767\n  }, {\n    begin: 768,\n    end: 879\n  }, {\n    begin: 880,\n    end: 1023\n  }, {\n    begin: 11392,\n    end: 11519\n  }, {\n    begin: 1024,\n    end: 1279\n  }, {\n    begin: 1328,\n    end: 1423\n  }, {\n    begin: 1424,\n    end: 1535\n  }, {\n    begin: 42240,\n    end: 42559\n  }, {\n    begin: 1536,\n    end: 1791\n  }, {\n    begin: 1984,\n    end: 2047\n  }, {\n    begin: 2304,\n    end: 2431\n  }, {\n    begin: 2432,\n    end: 2559\n  }, {\n    begin: 2560,\n    end: 2687\n  }, {\n    begin: 2688,\n    end: 2815\n  }, {\n    begin: 2816,\n    end: 2943\n  }, {\n    begin: 2944,\n    end: 3071\n  }, {\n    begin: 3072,\n    end: 3199\n  }, {\n    begin: 3200,\n    end: 3327\n  }, {\n    begin: 3328,\n    end: 3455\n  }, {\n    begin: 3584,\n    end: 3711\n  }, {\n    begin: 3712,\n    end: 3839\n  }, {\n    begin: 4256,\n    end: 4351\n  }, {\n    begin: 6912,\n    end: 7039\n  }, {\n    begin: 4352,\n    end: 4607\n  }, {\n    begin: 7680,\n    end: 7935\n  }, {\n    begin: 7936,\n    end: 8191\n  }, {\n    begin: 8192,\n    end: 8303\n  }, {\n    begin: 8304,\n    end: 8351\n  }, {\n    begin: 8352,\n    end: 8399\n  }, {\n    begin: 8400,\n    end: 8447\n  }, {\n    begin: 8448,\n    end: 8527\n  }, {\n    begin: 8528,\n    end: 8591\n  }, {\n    begin: 8592,\n    end: 8703\n  }, {\n    begin: 8704,\n    end: 8959\n  }, {\n    begin: 8960,\n    end: 9215\n  }, {\n    begin: 9216,\n    end: 9279\n  }, {\n    begin: 9280,\n    end: 9311\n  }, {\n    begin: 9312,\n    end: 9471\n  }, {\n    begin: 9472,\n    end: 9599\n  }, {\n    begin: 9600,\n    end: 9631\n  }, {\n    begin: 9632,\n    end: 9727\n  }, {\n    begin: 9728,\n    end: 9983\n  }, {\n    begin: 9984,\n    end: 10175\n  }, {\n    begin: 12288,\n    end: 12351\n  }, {\n    begin: 12352,\n    end: 12447\n  }, {\n    begin: 12448,\n    end: 12543\n  }, {\n    begin: 12544,\n    end: 12591\n  }, {\n    begin: 12592,\n    end: 12687\n  }, {\n    begin: 43072,\n    end: 43135\n  }, {\n    begin: 12800,\n    end: 13055\n  }, {\n    begin: 13056,\n    end: 13311\n  }, {\n    begin: 44032,\n    end: 55215\n  }, {\n    begin: 55296,\n    end: 57343\n  }, {\n    begin: 67840,\n    end: 67871\n  }, {\n    begin: 19968,\n    end: 40959\n  }, {\n    begin: 57344,\n    end: 63743\n  }, {\n    begin: 12736,\n    end: 12783\n  }, {\n    begin: 64256,\n    end: 64335\n  }, {\n    begin: 64336,\n    end: 65023\n  }, {\n    begin: 65056,\n    end: 65071\n  }, {\n    begin: 65040,\n    end: 65055\n  }, {\n    begin: 65104,\n    end: 65135\n  }, {\n    begin: 65136,\n    end: 65279\n  }, {\n    begin: 65280,\n    end: 65519\n  }, {\n    begin: 65520,\n    end: 65535\n  }, {\n    begin: 3840,\n    end: 4095\n  }, {\n    begin: 1792,\n    end: 1871\n  }, {\n    begin: 1920,\n    end: 1983\n  }, {\n    begin: 3456,\n    end: 3583\n  }, {\n    begin: 4096,\n    end: 4255\n  }, {\n    begin: 4608,\n    end: 4991\n  }, {\n    begin: 5024,\n    end: 5119\n  }, {\n    begin: 5120,\n    end: 5759\n  }, {\n    begin: 5760,\n    end: 5791\n  }, {\n    begin: 5792,\n    end: 5887\n  }, {\n    begin: 6016,\n    end: 6143\n  }, {\n    begin: 6144,\n    end: 6319\n  }, {\n    begin: 10240,\n    end: 10495\n  }, {\n    begin: 40960,\n    end: 42127\n  }, {\n    begin: 5888,\n    end: 5919\n  }, {\n    begin: 66304,\n    end: 66351\n  }, {\n    begin: 66352,\n    end: 66383\n  }, {\n    begin: 66560,\n    end: 66639\n  }, {\n    begin: 118784,\n    end: 119039\n  }, {\n    begin: 119808,\n    end: 120831\n  }, {\n    begin: 1044480,\n    end: 1048573\n  }, {\n    begin: 65024,\n    end: 65039\n  }, {\n    begin: 917504,\n    end: 917631\n  }, {\n    begin: 6400,\n    end: 6479\n  }, {\n    begin: 6480,\n    end: 6527\n  }, {\n    begin: 6528,\n    end: 6623\n  }, {\n    begin: 6656,\n    end: 6687\n  }, {\n    begin: 11264,\n    end: 11359\n  }, {\n    begin: 11568,\n    end: 11647\n  }, {\n    begin: 19904,\n    end: 19967\n  }, {\n    begin: 43008,\n    end: 43055\n  }, {\n    begin: 65536,\n    end: 65663\n  }, {\n    begin: 65856,\n    end: 65935\n  }, {\n    begin: 66432,\n    end: 66463\n  }, {\n    begin: 66464,\n    end: 66527\n  }, {\n    begin: 66640,\n    end: 66687\n  }, {\n    begin: 66688,\n    end: 66735\n  }, {\n    begin: 67584,\n    end: 67647\n  }, {\n    begin: 68096,\n    end: 68191\n  }, {\n    begin: 119552,\n    end: 119647\n  }, {\n    begin: 73728,\n    end: 74751\n  }, {\n    begin: 119648,\n    end: 119679\n  }, {\n    begin: 7040,\n    end: 7103\n  }, {\n    begin: 7168,\n    end: 7247\n  }, {\n    begin: 7248,\n    end: 7295\n  }, {\n    begin: 43136,\n    end: 43231\n  }, {\n    begin: 43264,\n    end: 43311\n  }, {\n    begin: 43312,\n    end: 43359\n  }, {\n    begin: 43520,\n    end: 43615\n  }, {\n    begin: 65936,\n    end: 65999\n  }, {\n    begin: 66e3,\n    end: 66047\n  }, {\n    begin: 66208,\n    end: 66271\n  }, {\n    begin: 127024,\n    end: 127135\n  }];\nfunction In(e) {\n  for (var r = 0; r < yr.length; r += 1) {\n    var t = yr[r];\n    if (e >= t.begin && e < t.end) return r;\n  }\n  return -1;\n}\nfunction Mn(e, r) {\n  var t = {},\n    a = new k.Parser(e, r);\n  t.version = a.parseUShort(), t.xAvgCharWidth = a.parseShort(), t.usWeightClass = a.parseUShort(), t.usWidthClass = a.parseUShort(), t.fsType = a.parseUShort(), t.ySubscriptXSize = a.parseShort(), t.ySubscriptYSize = a.parseShort(), t.ySubscriptXOffset = a.parseShort(), t.ySubscriptYOffset = a.parseShort(), t.ySuperscriptXSize = a.parseShort(), t.ySuperscriptYSize = a.parseShort(), t.ySuperscriptXOffset = a.parseShort(), t.ySuperscriptYOffset = a.parseShort(), t.yStrikeoutSize = a.parseShort(), t.yStrikeoutPosition = a.parseShort(), t.sFamilyClass = a.parseShort(), t.panose = [];\n  for (var n = 0; n < 10; n++) {\n    t.panose[n] = a.parseByte();\n  }\n  return t.ulUnicodeRange1 = a.parseULong(), t.ulUnicodeRange2 = a.parseULong(), t.ulUnicodeRange3 = a.parseULong(), t.ulUnicodeRange4 = a.parseULong(), t.achVendID = String.fromCharCode(a.parseByte(), a.parseByte(), a.parseByte(), a.parseByte()), t.fsSelection = a.parseUShort(), t.usFirstCharIndex = a.parseUShort(), t.usLastCharIndex = a.parseUShort(), t.sTypoAscender = a.parseShort(), t.sTypoDescender = a.parseShort(), t.sTypoLineGap = a.parseShort(), t.usWinAscent = a.parseUShort(), t.usWinDescent = a.parseUShort(), t.version >= 1 && (t.ulCodePageRange1 = a.parseULong(), t.ulCodePageRange2 = a.parseULong()), t.version >= 2 && (t.sxHeight = a.parseShort(), t.sCapHeight = a.parseShort(), t.usDefaultChar = a.parseUShort(), t.usBreakChar = a.parseUShort(), t.usMaxContent = a.parseUShort()), t;\n}\nfunction Pn(e) {\n  return new b.Table(\"OS/2\", [{\n    name: \"version\",\n    type: \"USHORT\",\n    value: 3\n  }, {\n    name: \"xAvgCharWidth\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"usWeightClass\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"usWidthClass\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"fsType\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"ySubscriptXSize\",\n    type: \"SHORT\",\n    value: 650\n  }, {\n    name: \"ySubscriptYSize\",\n    type: \"SHORT\",\n    value: 699\n  }, {\n    name: \"ySubscriptXOffset\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"ySubscriptYOffset\",\n    type: \"SHORT\",\n    value: 140\n  }, {\n    name: \"ySuperscriptXSize\",\n    type: \"SHORT\",\n    value: 650\n  }, {\n    name: \"ySuperscriptYSize\",\n    type: \"SHORT\",\n    value: 699\n  }, {\n    name: \"ySuperscriptXOffset\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"ySuperscriptYOffset\",\n    type: \"SHORT\",\n    value: 479\n  }, {\n    name: \"yStrikeoutSize\",\n    type: \"SHORT\",\n    value: 49\n  }, {\n    name: \"yStrikeoutPosition\",\n    type: \"SHORT\",\n    value: 258\n  }, {\n    name: \"sFamilyClass\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"bFamilyType\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bSerifStyle\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bWeight\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bProportion\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bContrast\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bStrokeVariation\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bArmStyle\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bLetterform\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bMidline\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"bXHeight\",\n    type: \"BYTE\",\n    value: 0\n  }, {\n    name: \"ulUnicodeRange1\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"ulUnicodeRange2\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"ulUnicodeRange3\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"ulUnicodeRange4\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"achVendID\",\n    type: \"CHARARRAY\",\n    value: \"XXXX\"\n  }, {\n    name: \"fsSelection\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"usFirstCharIndex\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"usLastCharIndex\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"sTypoAscender\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"sTypoDescender\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"sTypoLineGap\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"usWinAscent\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"usWinDescent\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"ulCodePageRange1\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"ulCodePageRange2\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"sxHeight\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"sCapHeight\",\n    type: \"SHORT\",\n    value: 0\n  }, {\n    name: \"usDefaultChar\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"usBreakChar\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"usMaxContext\",\n    type: \"USHORT\",\n    value: 0\n  }], e);\n}\nvar xr = {\n  parse: Mn,\n  make: Pn,\n  unicodeRanges: yr,\n  getUnicodeRange: In\n};\nfunction Gn(e, r) {\n  var t = {},\n    a = new k.Parser(e, r);\n  switch (t.version = a.parseVersion(), t.italicAngle = a.parseFixed(), t.underlinePosition = a.parseShort(), t.underlineThickness = a.parseShort(), t.isFixedPitch = a.parseULong(), t.minMemType42 = a.parseULong(), t.maxMemType42 = a.parseULong(), t.minMemType1 = a.parseULong(), t.maxMemType1 = a.parseULong(), t.version) {\n    case 1:\n      t.names = xe.slice();\n      break;\n    case 2:\n      t.numberOfGlyphs = a.parseUShort(), t.glyphNameIndex = new Array(t.numberOfGlyphs);\n      for (var n = 0; n < t.numberOfGlyphs; n++) {\n        t.glyphNameIndex[n] = a.parseUShort();\n      }\n      t.names = [];\n      for (var s = 0; s < t.numberOfGlyphs; s++) {\n        if (t.glyphNameIndex[s] >= xe.length) {\n          var i = a.parseChar();\n          t.names.push(a.parseString(i));\n        }\n      }\n      break;\n    case 2.5:\n      t.numberOfGlyphs = a.parseUShort(), t.offset = new Array(t.numberOfGlyphs);\n      for (var u = 0; u < t.numberOfGlyphs; u++) {\n        t.offset[u] = a.parseChar();\n      }\n      break;\n  }\n  return t;\n}\nfunction Nn() {\n  return new b.Table(\"post\", [{\n    name: \"version\",\n    type: \"FIXED\",\n    value: 196608\n  }, {\n    name: \"italicAngle\",\n    type: \"FIXED\",\n    value: 0\n  }, {\n    name: \"underlinePosition\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"underlineThickness\",\n    type: \"FWORD\",\n    value: 0\n  }, {\n    name: \"isFixedPitch\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"minMemType42\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"maxMemType42\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"minMemType1\",\n    type: \"ULONG\",\n    value: 0\n  }, {\n    name: \"maxMemType1\",\n    type: \"ULONG\",\n    value: 0\n  }]);\n}\nvar Qt = {\n    parse: Gn,\n    make: Nn\n  },\n  ee = new Array(9);\nee[1] = function () {\n  var r = this.offset + this.relativeOffset,\n    t = this.parseUShort();\n  if (t === 1) return {\n    substFormat: 1,\n    coverage: this.parsePointer(v.coverage),\n    deltaGlyphId: this.parseUShort()\n  };\n  if (t === 2) return {\n    substFormat: 2,\n    coverage: this.parsePointer(v.coverage),\n    substitute: this.parseOffset16List()\n  };\n  U.assert(!1, \"0x\" + r.toString(16) + \": lookup type 1 format must be 1 or 2.\");\n};\nee[2] = function () {\n  var r = this.parseUShort();\n  return U.argument(r === 1, \"GSUB Multiple Substitution Subtable identifier-format must be 1\"), {\n    substFormat: r,\n    coverage: this.parsePointer(v.coverage),\n    sequences: this.parseListOfLists()\n  };\n};\nee[3] = function () {\n  var r = this.parseUShort();\n  return U.argument(r === 1, \"GSUB Alternate Substitution Subtable identifier-format must be 1\"), {\n    substFormat: r,\n    coverage: this.parsePointer(v.coverage),\n    alternateSets: this.parseListOfLists()\n  };\n};\nee[4] = function () {\n  var r = this.parseUShort();\n  return U.argument(r === 1, \"GSUB ligature table identifier-format must be 1\"), {\n    substFormat: r,\n    coverage: this.parsePointer(v.coverage),\n    ligatureSets: this.parseListOfLists(function () {\n      return {\n        ligGlyph: this.parseUShort(),\n        components: this.parseUShortList(this.parseUShort() - 1)\n      };\n    })\n  };\n};\nvar ke = {\n  sequenceIndex: v.uShort,\n  lookupListIndex: v.uShort\n};\nee[5] = function () {\n  var r = this.offset + this.relativeOffset,\n    t = this.parseUShort();\n  if (t === 1) return {\n    substFormat: t,\n    coverage: this.parsePointer(v.coverage),\n    ruleSets: this.parseListOfLists(function () {\n      var s = this.parseUShort(),\n        i = this.parseUShort();\n      return {\n        input: this.parseUShortList(s - 1),\n        lookupRecords: this.parseRecordList(i, ke)\n      };\n    })\n  };\n  if (t === 2) return {\n    substFormat: t,\n    coverage: this.parsePointer(v.coverage),\n    classDef: this.parsePointer(v.classDef),\n    classSets: this.parseListOfLists(function () {\n      var s = this.parseUShort(),\n        i = this.parseUShort();\n      return {\n        classes: this.parseUShortList(s - 1),\n        lookupRecords: this.parseRecordList(i, ke)\n      };\n    })\n  };\n  if (t === 3) {\n    var a = this.parseUShort(),\n      n = this.parseUShort();\n    return {\n      substFormat: t,\n      coverages: this.parseList(a, v.pointer(v.coverage)),\n      lookupRecords: this.parseRecordList(n, ke)\n    };\n  }\n  U.assert(!1, \"0x\" + r.toString(16) + \": lookup type 5 format must be 1, 2 or 3.\");\n};\nee[6] = function () {\n  var r = this.offset + this.relativeOffset,\n    t = this.parseUShort();\n  if (t === 1) return {\n    substFormat: 1,\n    coverage: this.parsePointer(v.coverage),\n    chainRuleSets: this.parseListOfLists(function () {\n      return {\n        backtrack: this.parseUShortList(),\n        input: this.parseUShortList(this.parseShort() - 1),\n        lookahead: this.parseUShortList(),\n        lookupRecords: this.parseRecordList(ke)\n      };\n    })\n  };\n  if (t === 2) return {\n    substFormat: 2,\n    coverage: this.parsePointer(v.coverage),\n    backtrackClassDef: this.parsePointer(v.classDef),\n    inputClassDef: this.parsePointer(v.classDef),\n    lookaheadClassDef: this.parsePointer(v.classDef),\n    chainClassSet: this.parseListOfLists(function () {\n      return {\n        backtrack: this.parseUShortList(),\n        input: this.parseUShortList(this.parseShort() - 1),\n        lookahead: this.parseUShortList(),\n        lookupRecords: this.parseRecordList(ke)\n      };\n    })\n  };\n  if (t === 3) return {\n    substFormat: 3,\n    backtrackCoverage: this.parseList(v.pointer(v.coverage)),\n    inputCoverage: this.parseList(v.pointer(v.coverage)),\n    lookaheadCoverage: this.parseList(v.pointer(v.coverage)),\n    lookupRecords: this.parseRecordList(ke)\n  };\n  U.assert(!1, \"0x\" + r.toString(16) + \": lookup type 6 format must be 1, 2 or 3.\");\n};\nee[7] = function () {\n  var r = this.parseUShort();\n  U.argument(r === 1, \"GSUB Extension Substitution subtable identifier-format must be 1\");\n  var t = this.parseUShort(),\n    a = new v(this.data, this.offset + this.parseULong());\n  return {\n    substFormat: 1,\n    lookupType: t,\n    extension: ee[t].call(a)\n  };\n};\nee[8] = function () {\n  var r = this.parseUShort();\n  return U.argument(r === 1, \"GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1\"), {\n    substFormat: r,\n    coverage: this.parsePointer(v.coverage),\n    backtrackCoverage: this.parseList(v.pointer(v.coverage)),\n    lookaheadCoverage: this.parseList(v.pointer(v.coverage)),\n    substitutes: this.parseUShortList()\n  };\n};\nfunction Hn(e, r) {\n  r = r || 0;\n  var t = new v(e, r),\n    a = t.parseVersion(1);\n  return U.argument(a === 1 || a === 1.1, \"Unsupported GSUB table version.\"), a === 1 ? {\n    version: a,\n    scripts: t.parseScriptList(),\n    features: t.parseFeatureList(),\n    lookups: t.parseLookupList(ee)\n  } : {\n    version: a,\n    scripts: t.parseScriptList(),\n    features: t.parseFeatureList(),\n    lookups: t.parseLookupList(ee),\n    variations: t.parseFeatureVariationsList()\n  };\n}\nvar Ue = new Array(9);\nUe[1] = function (r) {\n  return r.substFormat === 1 ? new b.Table(\"substitutionTable\", [{\n    name: \"substFormat\",\n    type: \"USHORT\",\n    value: 1\n  }, {\n    name: \"coverage\",\n    type: \"TABLE\",\n    value: new b.Coverage(r.coverage)\n  }, {\n    name: \"deltaGlyphID\",\n    type: \"USHORT\",\n    value: r.deltaGlyphId\n  }]) : new b.Table(\"substitutionTable\", [{\n    name: \"substFormat\",\n    type: \"USHORT\",\n    value: 2\n  }, {\n    name: \"coverage\",\n    type: \"TABLE\",\n    value: new b.Coverage(r.coverage)\n  }].concat(b.ushortList(\"substitute\", r.substitute)));\n};\nUe[2] = function (r) {\n  return U.assert(r.substFormat === 1, \"Lookup type 2 substFormat must be 1.\"), new b.Table(\"substitutionTable\", [{\n    name: \"substFormat\",\n    type: \"USHORT\",\n    value: 1\n  }, {\n    name: \"coverage\",\n    type: \"TABLE\",\n    value: new b.Coverage(r.coverage)\n  }].concat(b.tableList(\"seqSet\", r.sequences, function (t) {\n    return new b.Table(\"sequenceSetTable\", b.ushortList(\"sequence\", t));\n  })));\n};\nUe[3] = function (r) {\n  return U.assert(r.substFormat === 1, \"Lookup type 3 substFormat must be 1.\"), new b.Table(\"substitutionTable\", [{\n    name: \"substFormat\",\n    type: \"USHORT\",\n    value: 1\n  }, {\n    name: \"coverage\",\n    type: \"TABLE\",\n    value: new b.Coverage(r.coverage)\n  }].concat(b.tableList(\"altSet\", r.alternateSets, function (t) {\n    return new b.Table(\"alternateSetTable\", b.ushortList(\"alternate\", t));\n  })));\n};\nUe[4] = function (r) {\n  return U.assert(r.substFormat === 1, \"Lookup type 4 substFormat must be 1.\"), new b.Table(\"substitutionTable\", [{\n    name: \"substFormat\",\n    type: \"USHORT\",\n    value: 1\n  }, {\n    name: \"coverage\",\n    type: \"TABLE\",\n    value: new b.Coverage(r.coverage)\n  }].concat(b.tableList(\"ligSet\", r.ligatureSets, function (t) {\n    return new b.Table(\"ligatureSetTable\", b.tableList(\"ligature\", t, function (a) {\n      return new b.Table(\"ligatureTable\", [{\n        name: \"ligGlyph\",\n        type: \"USHORT\",\n        value: a.ligGlyph\n      }].concat(b.ushortList(\"component\", a.components, a.components.length + 1)));\n    }));\n  })));\n};\nUe[6] = function (r) {\n  if (r.substFormat === 1) {\n    var t = new b.Table(\"chainContextTable\", [{\n      name: \"substFormat\",\n      type: \"USHORT\",\n      value: r.substFormat\n    }, {\n      name: \"coverage\",\n      type: \"TABLE\",\n      value: new b.Coverage(r.coverage)\n    }].concat(b.tableList(\"chainRuleSet\", r.chainRuleSets, function (s) {\n      return new b.Table(\"chainRuleSetTable\", b.tableList(\"chainRule\", s, function (i) {\n        var u = b.ushortList(\"backtrackGlyph\", i.backtrack, i.backtrack.length).concat(b.ushortList(\"inputGlyph\", i.input, i.input.length + 1)).concat(b.ushortList(\"lookaheadGlyph\", i.lookahead, i.lookahead.length)).concat(b.ushortList(\"substitution\", [], i.lookupRecords.length));\n        return i.lookupRecords.forEach(function (o, l) {\n          u = u.concat({\n            name: \"sequenceIndex\" + l,\n            type: \"USHORT\",\n            value: o.sequenceIndex\n          }).concat({\n            name: \"lookupListIndex\" + l,\n            type: \"USHORT\",\n            value: o.lookupListIndex\n          });\n        }), new b.Table(\"chainRuleTable\", u);\n      }));\n    })));\n    return t;\n  } else if (r.substFormat === 2) U.assert(!1, \"lookup type 6 format 2 is not yet supported.\");else if (r.substFormat === 3) {\n    var a = [{\n      name: \"substFormat\",\n      type: \"USHORT\",\n      value: r.substFormat\n    }];\n    a.push({\n      name: \"backtrackGlyphCount\",\n      type: \"USHORT\",\n      value: r.backtrackCoverage.length\n    }), r.backtrackCoverage.forEach(function (s, i) {\n      a.push({\n        name: \"backtrackCoverage\" + i,\n        type: \"TABLE\",\n        value: new b.Coverage(s)\n      });\n    }), a.push({\n      name: \"inputGlyphCount\",\n      type: \"USHORT\",\n      value: r.inputCoverage.length\n    }), r.inputCoverage.forEach(function (s, i) {\n      a.push({\n        name: \"inputCoverage\" + i,\n        type: \"TABLE\",\n        value: new b.Coverage(s)\n      });\n    }), a.push({\n      name: \"lookaheadGlyphCount\",\n      type: \"USHORT\",\n      value: r.lookaheadCoverage.length\n    }), r.lookaheadCoverage.forEach(function (s, i) {\n      a.push({\n        name: \"lookaheadCoverage\" + i,\n        type: \"TABLE\",\n        value: new b.Coverage(s)\n      });\n    }), a.push({\n      name: \"substitutionCount\",\n      type: \"USHORT\",\n      value: r.lookupRecords.length\n    }), r.lookupRecords.forEach(function (s, i) {\n      a = a.concat({\n        name: \"sequenceIndex\" + i,\n        type: \"USHORT\",\n        value: s.sequenceIndex\n      }).concat({\n        name: \"lookupListIndex\" + i,\n        type: \"USHORT\",\n        value: s.lookupListIndex\n      });\n    });\n    var n = new b.Table(\"chainContextTable\", a);\n    return n;\n  }\n  U.assert(!1, \"lookup type 6 format must be 1, 2 or 3.\");\n};\nfunction zn(e) {\n  return new b.Table(\"GSUB\", [{\n    name: \"version\",\n    type: \"ULONG\",\n    value: 65536\n  }, {\n    name: \"scripts\",\n    type: \"TABLE\",\n    value: new b.ScriptList(e.scripts)\n  }, {\n    name: \"features\",\n    type: \"TABLE\",\n    value: new b.FeatureList(e.features)\n  }, {\n    name: \"lookups\",\n    type: \"TABLE\",\n    value: new b.LookupList(e.lookups, Ue)\n  }]);\n}\nvar Kt = {\n  parse: Hn,\n  make: zn\n};\nfunction Wn(e, r) {\n  var t = new k.Parser(e, r),\n    a = t.parseULong();\n  U.argument(a === 1, \"Unsupported META table version.\"), t.parseULong(), t.parseULong();\n  for (var n = t.parseULong(), s = {}, i = 0; i < n; i++) {\n    var u = t.parseTag(),\n      o = t.parseULong(),\n      l = t.parseULong(),\n      f = Fe.UTF8(e, r + o, l);\n    s[u] = f;\n  }\n  return s;\n}\nfunction _n(e) {\n  var r = Object.keys(e).length,\n    t = \"\",\n    a = 16 + r * 12,\n    n = new b.Table(\"meta\", [{\n      name: \"version\",\n      type: \"ULONG\",\n      value: 1\n    }, {\n      name: \"flags\",\n      type: \"ULONG\",\n      value: 0\n    }, {\n      name: \"offset\",\n      type: \"ULONG\",\n      value: a\n    }, {\n      name: \"numTags\",\n      type: \"ULONG\",\n      value: r\n    }]);\n  for (var s in e) {\n    var i = t.length;\n    t += e[s], n.fields.push({\n      name: \"tag \" + s,\n      type: \"TAG\",\n      value: s\n    }), n.fields.push({\n      name: \"offset \" + s,\n      type: \"ULONG\",\n      value: a + i\n    }), n.fields.push({\n      name: \"length \" + s,\n      type: \"ULONG\",\n      value: e[s].length\n    });\n  }\n  return n.fields.push({\n    name: \"stringPool\",\n    type: \"CHARARRAY\",\n    value: t\n  }), n;\n}\nvar Jt = {\n  parse: Wn,\n  make: _n\n};\nfunction Zr(e) {\n  return Math.log(e) / Math.log(2) | 0;\n}\nfunction Er(e) {\n  for (; e.length % 4 !== 0;) {\n    e.push(0);\n  }\n  for (var r = 0, t = 0; t < e.length; t += 4) {\n    r += (e[t] << 24) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];\n  }\n  return r %= Math.pow(2, 32), r;\n}\nfunction Qr(e, r, t, a) {\n  return new b.Record(\"Table Record\", [{\n    name: \"tag\",\n    type: \"TAG\",\n    value: e !== void 0 ? e : \"\"\n  }, {\n    name: \"checkSum\",\n    type: \"ULONG\",\n    value: r !== void 0 ? r : 0\n  }, {\n    name: \"offset\",\n    type: \"ULONG\",\n    value: t !== void 0 ? t : 0\n  }, {\n    name: \"length\",\n    type: \"ULONG\",\n    value: a !== void 0 ? a : 0\n  }]);\n}\nfunction jt(e) {\n  var r = new b.Table(\"sfnt\", [{\n    name: \"version\",\n    type: \"TAG\",\n    value: \"OTTO\"\n  }, {\n    name: \"numTables\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"searchRange\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"entrySelector\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"rangeShift\",\n    type: \"USHORT\",\n    value: 0\n  }]);\n  r.tables = e, r.numTables = e.length;\n  var t = Math.pow(2, Zr(r.numTables));\n  r.searchRange = 16 * t, r.entrySelector = Zr(t), r.rangeShift = r.numTables * 16 - r.searchRange;\n  for (var a = [], n = [], s = r.sizeOf() + Qr().sizeOf() * r.numTables; s % 4 !== 0;) {\n    s += 1, n.push({\n      name: \"padding\",\n      type: \"BYTE\",\n      value: 0\n    });\n  }\n  for (var i = 0; i < e.length; i += 1) {\n    var u = e[i];\n    U.argument(u.tableName.length === 4, \"Table name\" + u.tableName + \" is invalid.\");\n    var o = u.sizeOf(),\n      l = Qr(u.tableName, Er(u.encode()), s, o);\n    for (a.push({\n      name: l.tag + \" Table Record\",\n      type: \"RECORD\",\n      value: l\n    }), n.push({\n      name: u.tableName + \" table\",\n      type: \"RECORD\",\n      value: u\n    }), s += o, U.argument(!isNaN(s), \"Something went wrong calculating the offset.\"); s % 4 !== 0;) {\n      s += 1, n.push({\n        name: \"padding\",\n        type: \"BYTE\",\n        value: 0\n      });\n    }\n  }\n  return a.sort(function (f, h) {\n    return f.value.tag > h.value.tag ? 1 : -1;\n  }), r.fields = r.fields.concat(a), r.fields = r.fields.concat(n), r;\n}\nfunction Kr(e, r, t) {\n  for (var a = 0; a < r.length; a += 1) {\n    var n = e.charToGlyphIndex(r[a]);\n    if (n > 0) {\n      var s = e.glyphs.get(n);\n      return s.getMetrics();\n    }\n  }\n  return t;\n}\nfunction Vn(e) {\n  for (var r = 0, t = 0; t < e.length; t += 1) {\n    r += e[t];\n  }\n  return r / e.length;\n}\nfunction qn(e) {\n  for (var r = [], t = [], a = [], n = [], s = [], i = [], u = [], o, l = 0, f = 0, h = 0, p = 0, c = 0, d = 0; d < e.glyphs.length; d += 1) {\n    var x = e.glyphs.get(d),\n      m = x.unicode | 0;\n    if (isNaN(x.advanceWidth)) throw new Error(\"Glyph \" + x.name + \" (\" + d + \"): advanceWidth is not a number.\");\n    (o > m || o === void 0) && m > 0 && (o = m), l < m && (l = m);\n    var y = xr.getUnicodeRange(m);\n    if (y < 32) f |= 1 << y;else if (y < 64) h |= 1 << y - 32;else if (y < 96) p |= 1 << y - 64;else if (y < 123) c |= 1 << y - 96;else throw new Error(\"Unicode ranges bits > 123 are reserved for internal usage\");\n    if (x.name !== \".notdef\") {\n      var C = x.getMetrics();\n      r.push(C.xMin), t.push(C.yMin), a.push(C.xMax), n.push(C.yMax), i.push(C.leftSideBearing), u.push(C.rightSideBearing), s.push(x.advanceWidth);\n    }\n  }\n  var S = {\n    xMin: Math.min.apply(null, r),\n    yMin: Math.min.apply(null, t),\n    xMax: Math.max.apply(null, a),\n    yMax: Math.max.apply(null, n),\n    advanceWidthMax: Math.max.apply(null, s),\n    advanceWidthAvg: Vn(s),\n    minLeftSideBearing: Math.min.apply(null, i),\n    maxLeftSideBearing: Math.max.apply(null, i),\n    minRightSideBearing: Math.min.apply(null, u)\n  };\n  S.ascender = e.ascender, S.descender = e.descender;\n  var R = Nt.make({\n      flags: 3,\n      unitsPerEm: e.unitsPerEm,\n      xMin: S.xMin,\n      yMin: S.yMin,\n      xMax: S.xMax,\n      yMax: S.yMax,\n      lowestRecPPEM: 3,\n      createdTimestamp: e.createdTimestamp\n    }),\n    O = Ht.make({\n      ascender: S.ascender,\n      descender: S.descender,\n      advanceWidthMax: S.advanceWidthMax,\n      minLeftSideBearing: S.minLeftSideBearing,\n      minRightSideBearing: S.minRightSideBearing,\n      xMaxExtent: S.maxLeftSideBearing + (S.xMax - S.xMin),\n      numberOfHMetrics: e.glyphs.length\n    }),\n    D = _t.make(e.glyphs.length),\n    L = xr.make(Object.assign({\n      xAvgCharWidth: Math.round(S.advanceWidthAvg),\n      usFirstCharIndex: o,\n      usLastCharIndex: l,\n      ulUnicodeRange1: f,\n      ulUnicodeRange2: h,\n      ulUnicodeRange3: p,\n      ulUnicodeRange4: c,\n      sTypoAscender: S.ascender,\n      sTypoDescender: S.descender,\n      sTypoLineGap: 0,\n      usWinAscent: S.yMax,\n      usWinDescent: Math.abs(S.yMin),\n      ulCodePageRange1: 1,\n      sxHeight: Kr(e, \"xyvw\", {\n        yMax: Math.round(S.ascender / 2)\n      }).yMax,\n      sCapHeight: Kr(e, \"HIKLEFJMNTZBDPRAGOQSUVWXY\", S).yMax,\n      usDefaultChar: e.hasChar(\" \") ? 32 : 0,\n      usBreakChar: e.hasChar(\" \") ? 32 : 0\n    }, e.tables.os2)),\n    F = zt.make(e.glyphs),\n    G = Et.make(e.glyphs),\n    Y = e.getEnglishName(\"fontFamily\"),\n    Z = e.getEnglishName(\"fontSubfamily\"),\n    j = Y + \" \" + Z,\n    $ = e.getEnglishName(\"postScriptName\");\n  $ || ($ = Y.replace(/\\s/g, \"\") + \"-\" + Z);\n  var M = {};\n  for (var N in e.names) {\n    M[N] = e.names[N];\n  }\n  M.uniqueID || (M.uniqueID = {\n    en: e.getEnglishName(\"manufacturer\") + \":\" + j\n  }), M.postScriptName || (M.postScriptName = {\n    en: $\n  }), M.preferredFamily || (M.preferredFamily = e.names.fontFamily), M.preferredSubfamily || (M.preferredSubfamily = e.names.fontSubfamily);\n  var W = [],\n    _ = Zt.make(M, W),\n    V = W.length > 0 ? Wt.make(W) : void 0,\n    H = Qt.make(),\n    X = Gt.make(e.glyphs, {\n      version: e.getEnglishName(\"version\"),\n      fullName: j,\n      familyName: Y,\n      weightName: Z,\n      postScriptName: $,\n      unitsPerEm: e.unitsPerEm,\n      fontBBox: [0, S.yMin, S.ascender, S.advanceWidthMax]\n    }),\n    A = e.metas && Object.keys(e.metas).length > 0 ? Jt.make(e.metas) : void 0,\n    q = [R, O, D, L, _, G, H, X, F];\n  V && q.push(V), e.tables.gsub && q.push(Kt.make(e.tables.gsub)), A && q.push(A);\n  for (var rr = jt(q), ha = rr.encode(), ca = Er(ha), tr = rr.fields, Ar = !1, Ge = 0; Ge < tr.length; Ge += 1) {\n    if (tr[Ge].name === \"head table\") {\n      tr[Ge].value.checkSumAdjustment = 2981146554 - ca, Ar = !0;\n      break;\n    }\n  }\n  if (!Ar) throw new Error(\"Could not find head table with checkSum to adjust.\");\n  return rr;\n}\nvar Xn = {\n  make: jt,\n  fontToTable: qn,\n  computeCheckSum: Er\n};\nfunction sr(e, r) {\n  for (var t = 0, a = e.length - 1; t <= a;) {\n    var n = t + a >>> 1,\n      s = e[n].tag;\n    if (s === r) return n;\n    s < r ? t = n + 1 : a = n - 1;\n  }\n  return -t - 1;\n}\nfunction Jr(e, r) {\n  for (var t = 0, a = e.length - 1; t <= a;) {\n    var n = t + a >>> 1,\n      s = e[n];\n    if (s === r) return n;\n    s < r ? t = n + 1 : a = n - 1;\n  }\n  return -t - 1;\n}\nfunction jr(e, r) {\n  for (var t, a = 0, n = e.length - 1; a <= n;) {\n    var s = a + n >>> 1;\n    t = e[s];\n    var i = t.start;\n    if (i === r) return t;\n    i < r ? a = s + 1 : n = s - 1;\n  }\n  if (a > 0) return t = e[a - 1], r > t.end ? 0 : t;\n}\nfunction Ae(e, r) {\n  this.font = e, this.tableName = r;\n}\nAe.prototype = {\n  searchTag: sr,\n  binSearch: Jr,\n  getTable: function getTable(e) {\n    var r = this.font.tables[this.tableName];\n    return !r && e && (r = this.font.tables[this.tableName] = this.createDefaultTable()), r;\n  },\n  getScriptNames: function getScriptNames() {\n    var e = this.getTable();\n    return e ? e.scripts.map(function (r) {\n      return r.tag;\n    }) : [];\n  },\n  getDefaultScriptName: function getDefaultScriptName() {\n    var e = this.getTable();\n    if (!!e) {\n      for (var r = !1, t = 0; t < e.scripts.length; t++) {\n        var a = e.scripts[t].tag;\n        if (a === \"DFLT\") return a;\n        a === \"latn\" && (r = !0);\n      }\n      if (r) return \"latn\";\n    }\n  },\n  getScriptTable: function getScriptTable(e, r) {\n    var t = this.getTable(r);\n    if (t) {\n      e = e || \"DFLT\";\n      var a = t.scripts,\n        n = sr(t.scripts, e);\n      if (n >= 0) return a[n].script;\n      if (r) {\n        var s = {\n          tag: e,\n          script: {\n            defaultLangSys: {\n              reserved: 0,\n              reqFeatureIndex: 65535,\n              featureIndexes: []\n            },\n            langSysRecords: []\n          }\n        };\n        return a.splice(-1 - n, 0, s), s.script;\n      }\n    }\n  },\n  getLangSysTable: function getLangSysTable(e, r, t) {\n    var a = this.getScriptTable(e, t);\n    if (a) {\n      if (!r || r === \"dflt\" || r === \"DFLT\") return a.defaultLangSys;\n      var n = sr(a.langSysRecords, r);\n      if (n >= 0) return a.langSysRecords[n].langSys;\n      if (t) {\n        var s = {\n          tag: r,\n          langSys: {\n            reserved: 0,\n            reqFeatureIndex: 65535,\n            featureIndexes: []\n          }\n        };\n        return a.langSysRecords.splice(-1 - n, 0, s), s.langSys;\n      }\n    }\n  },\n  getFeatureTable: function getFeatureTable(e, r, t, a) {\n    var n = this.getLangSysTable(e, r, a);\n    if (n) {\n      for (var s, i = n.featureIndexes, u = this.font.tables[this.tableName].features, o = 0; o < i.length; o++) {\n        if (s = u[i[o]], s.tag === t) return s.feature;\n      }\n      if (a) {\n        var l = u.length;\n        return U.assert(l === 0 || t >= u[l - 1].tag, \"Features must be added in alphabetical order.\"), s = {\n          tag: t,\n          feature: {\n            params: 0,\n            lookupListIndexes: []\n          }\n        }, u.push(s), i.push(l), s.feature;\n      }\n    }\n  },\n  getLookupTables: function getLookupTables(e, r, t, a, n) {\n    var s = this.getFeatureTable(e, r, t, n),\n      i = [];\n    if (s) {\n      for (var u, o = s.lookupListIndexes, l = this.font.tables[this.tableName].lookups, f = 0; f < o.length; f++) {\n        u = l[o[f]], u.lookupType === a && i.push(u);\n      }\n      if (i.length === 0 && n) {\n        u = {\n          lookupType: a,\n          lookupFlag: 0,\n          subtables: [],\n          markFilteringSet: void 0\n        };\n        var h = l.length;\n        return l.push(u), o.push(h), [u];\n      }\n    }\n    return i;\n  },\n  getGlyphClass: function getGlyphClass(e, r) {\n    switch (e.format) {\n      case 1:\n        return e.startGlyph <= r && r < e.startGlyph + e.classes.length ? e.classes[r - e.startGlyph] : 0;\n      case 2:\n        var t = jr(e.ranges, r);\n        return t ? t.classId : 0;\n    }\n  },\n  getCoverageIndex: function getCoverageIndex(e, r) {\n    switch (e.format) {\n      case 1:\n        var t = Jr(e.glyphs, r);\n        return t >= 0 ? t : -1;\n      case 2:\n        var a = jr(e.ranges, r);\n        return a ? a.index + r - a.start : -1;\n    }\n  },\n  expandCoverage: function expandCoverage(e) {\n    if (e.format === 1) return e.glyphs;\n    for (var r = [], t = e.ranges, a = 0; a < t.length; a++) {\n      for (var n = t[a], s = n.start, i = n.end, u = s; u <= i; u++) {\n        r.push(u);\n      }\n    }\n    return r;\n  }\n};\nfunction Be(e) {\n  Ae.call(this, e, \"gpos\");\n}\nBe.prototype = Ae.prototype;\nBe.prototype.init = function () {\n  var e = this.getDefaultScriptName();\n  this.defaultKerningTables = this.getKerningTables(e);\n};\nBe.prototype.getKerningValue = function (e, r, t) {\n  for (var a = 0; a < e.length; a++) {\n    for (var n = e[a].subtables, s = 0; s < n.length; s++) {\n      var i = n[s],\n        u = this.getCoverageIndex(i.coverage, r);\n      if (!(u < 0)) switch (i.posFormat) {\n        case 1:\n          for (var o = i.pairSets[u], l = 0; l < o.length; l++) {\n            var f = o[l];\n            if (f.secondGlyph === t) return f.value1 && f.value1.xAdvance || 0;\n          }\n          break;\n        case 2:\n          var h = this.getGlyphClass(i.classDef1, r),\n            p = this.getGlyphClass(i.classDef2, t),\n            c = i.classRecords[h][p];\n          return c.value1 && c.value1.xAdvance || 0;\n      }\n    }\n  }\n  return 0;\n};\nBe.prototype.getKerningTables = function (e, r) {\n  if (this.font.tables.gpos) return this.getLookupTables(e, r, \"kern\", 2);\n};\nfunction K(e) {\n  Ae.call(this, e, \"gsub\");\n}\nfunction Yn(e, r) {\n  var t = e.length;\n  if (t !== r.length) return !1;\n  for (var a = 0; a < t; a++) {\n    if (e[a] !== r[a]) return !1;\n  }\n  return !0;\n}\nfunction Or(e, r, t) {\n  for (var a = e.subtables, n = 0; n < a.length; n++) {\n    var s = a[n];\n    if (s.substFormat === r) return s;\n  }\n  if (t) return a.push(t), t;\n}\nK.prototype = Ae.prototype;\nK.prototype.createDefaultTable = function () {\n  return {\n    version: 1,\n    scripts: [{\n      tag: \"DFLT\",\n      script: {\n        defaultLangSys: {\n          reserved: 0,\n          reqFeatureIndex: 65535,\n          featureIndexes: []\n        },\n        langSysRecords: []\n      }\n    }],\n    features: [],\n    lookups: []\n  };\n};\nK.prototype.getSingle = function (e, r, t) {\n  for (var a = [], n = this.getLookupTables(r, t, e, 1), s = 0; s < n.length; s++) {\n    for (var i = n[s].subtables, u = 0; u < i.length; u++) {\n      var o = i[u],\n        l = this.expandCoverage(o.coverage),\n        f = void 0;\n      if (o.substFormat === 1) {\n        var h = o.deltaGlyphId;\n        for (f = 0; f < l.length; f++) {\n          var p = l[f];\n          a.push({\n            sub: p,\n            by: p + h\n          });\n        }\n      } else {\n        var c = o.substitute;\n        for (f = 0; f < l.length; f++) {\n          a.push({\n            sub: l[f],\n            by: c[f]\n          });\n        }\n      }\n    }\n  }\n  return a;\n};\nK.prototype.getMultiple = function (e, r, t) {\n  for (var a = [], n = this.getLookupTables(r, t, e, 2), s = 0; s < n.length; s++) {\n    for (var i = n[s].subtables, u = 0; u < i.length; u++) {\n      var o = i[u],\n        l = this.expandCoverage(o.coverage),\n        f = void 0;\n      for (f = 0; f < l.length; f++) {\n        var h = l[f],\n          p = o.sequences[f];\n        a.push({\n          sub: h,\n          by: p\n        });\n      }\n    }\n  }\n  return a;\n};\nK.prototype.getAlternates = function (e, r, t) {\n  for (var a = [], n = this.getLookupTables(r, t, e, 3), s = 0; s < n.length; s++) {\n    for (var i = n[s].subtables, u = 0; u < i.length; u++) {\n      for (var o = i[u], l = this.expandCoverage(o.coverage), f = o.alternateSets, h = 0; h < l.length; h++) {\n        a.push({\n          sub: l[h],\n          by: f[h]\n        });\n      }\n    }\n  }\n  return a;\n};\nK.prototype.getLigatures = function (e, r, t) {\n  for (var a = [], n = this.getLookupTables(r, t, e, 4), s = 0; s < n.length; s++) {\n    for (var i = n[s].subtables, u = 0; u < i.length; u++) {\n      for (var o = i[u], l = this.expandCoverage(o.coverage), f = o.ligatureSets, h = 0; h < l.length; h++) {\n        for (var p = l[h], c = f[h], d = 0; d < c.length; d++) {\n          var x = c[d];\n          a.push({\n            sub: [p].concat(x.components),\n            by: x.ligGlyph\n          });\n        }\n      }\n    }\n  }\n  return a;\n};\nK.prototype.addSingle = function (e, r, t, a) {\n  var n = this.getLookupTables(t, a, e, 1, !0)[0],\n    s = Or(n, 2, {\n      substFormat: 2,\n      coverage: {\n        format: 1,\n        glyphs: []\n      },\n      substitute: []\n    });\n  U.assert(s.coverage.format === 1, \"Single: unable to modify coverage table format \" + s.coverage.format);\n  var i = r.sub,\n    u = this.binSearch(s.coverage.glyphs, i);\n  u < 0 && (u = -1 - u, s.coverage.glyphs.splice(u, 0, i), s.substitute.splice(u, 0, 0)), s.substitute[u] = r.by;\n};\nK.prototype.addMultiple = function (e, r, t, a) {\n  U.assert(r.by instanceof Array && r.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n  var n = this.getLookupTables(t, a, e, 2, !0)[0],\n    s = Or(n, 1, {\n      substFormat: 1,\n      coverage: {\n        format: 1,\n        glyphs: []\n      },\n      sequences: []\n    });\n  U.assert(s.coverage.format === 1, \"Multiple: unable to modify coverage table format \" + s.coverage.format);\n  var i = r.sub,\n    u = this.binSearch(s.coverage.glyphs, i);\n  u < 0 && (u = -1 - u, s.coverage.glyphs.splice(u, 0, i), s.sequences.splice(u, 0, 0)), s.sequences[u] = r.by;\n};\nK.prototype.addAlternate = function (e, r, t, a) {\n  var n = this.getLookupTables(t, a, e, 3, !0)[0],\n    s = Or(n, 1, {\n      substFormat: 1,\n      coverage: {\n        format: 1,\n        glyphs: []\n      },\n      alternateSets: []\n    });\n  U.assert(s.coverage.format === 1, \"Alternate: unable to modify coverage table format \" + s.coverage.format);\n  var i = r.sub,\n    u = this.binSearch(s.coverage.glyphs, i);\n  u < 0 && (u = -1 - u, s.coverage.glyphs.splice(u, 0, i), s.alternateSets.splice(u, 0, 0)), s.alternateSets[u] = r.by;\n};\nK.prototype.addLigature = function (e, r, t, a) {\n  var n = this.getLookupTables(t, a, e, 4, !0)[0],\n    s = n.subtables[0];\n  s || (s = {\n    substFormat: 1,\n    coverage: {\n      format: 1,\n      glyphs: []\n    },\n    ligatureSets: []\n  }, n.subtables[0] = s), U.assert(s.coverage.format === 1, \"Ligature: unable to modify coverage table format \" + s.coverage.format);\n  var i = r.sub[0],\n    u = r.sub.slice(1),\n    o = {\n      ligGlyph: r.by,\n      components: u\n    },\n    l = this.binSearch(s.coverage.glyphs, i);\n  if (l >= 0) {\n    for (var f = s.ligatureSets[l], h = 0; h < f.length; h++) {\n      if (Yn(f[h].components, u)) return;\n    }\n    f.push(o);\n  } else l = -1 - l, s.coverage.glyphs.splice(l, 0, i), s.ligatureSets.splice(l, 0, [o]);\n};\nK.prototype.getFeature = function (e, r, t) {\n  if (/ss\\d\\d/.test(e)) return this.getSingle(e, r, t);\n  switch (e) {\n    case \"aalt\":\n    case \"salt\":\n      return this.getSingle(e, r, t).concat(this.getAlternates(e, r, t));\n    case \"dlig\":\n    case \"liga\":\n    case \"rlig\":\n      return this.getLigatures(e, r, t);\n    case \"ccmp\":\n      return this.getMultiple(e, r, t).concat(this.getLigatures(e, r, t));\n    case \"stch\":\n      return this.getMultiple(e, r, t);\n  }\n};\nK.prototype.add = function (e, r, t, a) {\n  if (/ss\\d\\d/.test(e)) return this.addSingle(e, r, t, a);\n  switch (e) {\n    case \"aalt\":\n    case \"salt\":\n      return typeof r.by == \"number\" ? this.addSingle(e, r, t, a) : this.addAlternate(e, r, t, a);\n    case \"dlig\":\n    case \"liga\":\n    case \"rlig\":\n      return this.addLigature(e, r, t, a);\n    case \"ccmp\":\n      return r.by instanceof Array ? this.addMultiple(e, r, t, a) : this.addLigature(e, r, t, a);\n  }\n};\nfunction Zn() {\n  return typeof window < \"u\";\n}\nfunction $t(e) {\n  for (var r = new ArrayBuffer(e.length), t = new Uint8Array(r), a = 0; a < e.length; ++a) {\n    t[a] = e[a];\n  }\n  return r;\n}\nfunction Qn(e) {\n  for (var r = new Buffer(e.byteLength), t = new Uint8Array(e), a = 0; a < r.length; ++a) {\n    r[a] = t[a];\n  }\n  return r;\n}\nfunction Ee(e, r) {\n  if (!e) throw r;\n}\nfunction $r(e, r, t, a, n) {\n  var s;\n  return (r & a) > 0 ? (s = e.parseByte(), (r & n) === 0 && (s = -s), s = t + s) : (r & n) > 0 ? s = t : s = t + e.parseShort(), s;\n}\nfunction ea(e, r, t) {\n  var a = new k.Parser(r, t);\n  e.numberOfContours = a.parseShort(), e._xMin = a.parseShort(), e._yMin = a.parseShort(), e._xMax = a.parseShort(), e._yMax = a.parseShort();\n  var n, s;\n  if (e.numberOfContours > 0) {\n    for (var i = e.endPointIndices = [], u = 0; u < e.numberOfContours; u += 1) {\n      i.push(a.parseUShort());\n    }\n    e.instructionLength = a.parseUShort(), e.instructions = [];\n    for (var o = 0; o < e.instructionLength; o += 1) {\n      e.instructions.push(a.parseByte());\n    }\n    var l = i[i.length - 1] + 1;\n    n = [];\n    for (var f = 0; f < l; f += 1) {\n      if (s = a.parseByte(), n.push(s), (s & 8) > 0) for (var h = a.parseByte(), p = 0; p < h; p += 1) {\n        n.push(s), f += 1;\n      }\n    }\n    if (U.argument(n.length === l, \"Bad flags.\"), i.length > 0) {\n      var c = [],\n        d;\n      if (l > 0) {\n        for (var x = 0; x < l; x += 1) {\n          s = n[x], d = {}, d.onCurve = !!(s & 1), d.lastPointOfContour = i.indexOf(x) >= 0, c.push(d);\n        }\n        for (var m = 0, y = 0; y < l; y += 1) {\n          s = n[y], d = c[y], d.x = $r(a, s, m, 2, 16), m = d.x;\n        }\n        for (var C = 0, S = 0; S < l; S += 1) {\n          s = n[S], d = c[S], d.y = $r(a, s, C, 4, 32), C = d.y;\n        }\n      }\n      e.points = c;\n    } else e.points = [];\n  } else if (e.numberOfContours === 0) e.points = [];else {\n    e.isComposite = !0, e.points = [], e.components = [];\n    for (var R = !0; R;) {\n      n = a.parseUShort();\n      var O = {\n        glyphIndex: a.parseUShort(),\n        xScale: 1,\n        scale01: 0,\n        scale10: 0,\n        yScale: 1,\n        dx: 0,\n        dy: 0\n      };\n      (n & 1) > 0 ? (n & 2) > 0 ? (O.dx = a.parseShort(), O.dy = a.parseShort()) : O.matchedPoints = [a.parseUShort(), a.parseUShort()] : (n & 2) > 0 ? (O.dx = a.parseChar(), O.dy = a.parseChar()) : O.matchedPoints = [a.parseByte(), a.parseByte()], (n & 8) > 0 ? O.xScale = O.yScale = a.parseF2Dot14() : (n & 64) > 0 ? (O.xScale = a.parseF2Dot14(), O.yScale = a.parseF2Dot14()) : (n & 128) > 0 && (O.xScale = a.parseF2Dot14(), O.scale01 = a.parseF2Dot14(), O.scale10 = a.parseF2Dot14(), O.yScale = a.parseF2Dot14()), e.components.push(O), R = !!(n & 32);\n    }\n    if (n & 256) {\n      e.instructionLength = a.parseUShort(), e.instructions = [];\n      for (var D = 0; D < e.instructionLength; D += 1) {\n        e.instructions.push(a.parseByte());\n      }\n    }\n  }\n}\nfunction ir(e, r) {\n  for (var t = [], a = 0; a < e.length; a += 1) {\n    var n = e[a],\n      s = {\n        x: r.xScale * n.x + r.scale01 * n.y + r.dx,\n        y: r.scale10 * n.x + r.yScale * n.y + r.dy,\n        onCurve: n.onCurve,\n        lastPointOfContour: n.lastPointOfContour\n      };\n    t.push(s);\n  }\n  return t;\n}\nfunction Kn(e) {\n  for (var r = [], t = [], a = 0; a < e.length; a += 1) {\n    var n = e[a];\n    t.push(n), n.lastPointOfContour && (r.push(t), t = []);\n  }\n  return U.argument(t.length === 0, \"There are still points left in the current contour.\"), r;\n}\nfunction ra(e) {\n  var r = new P();\n  if (!e) return r;\n  for (var t = Kn(e), a = 0; a < t.length; ++a) {\n    var n = t[a],\n      s = null,\n      i = n[n.length - 1],\n      u = n[0];\n    if (i.onCurve) r.moveTo(i.x, i.y);else if (u.onCurve) r.moveTo(u.x, u.y);else {\n      var o = {\n        x: (i.x + u.x) * .5,\n        y: (i.y + u.y) * .5\n      };\n      r.moveTo(o.x, o.y);\n    }\n    for (var l = 0; l < n.length; ++l) {\n      if (s = i, i = u, u = n[(l + 1) % n.length], i.onCurve) r.lineTo(i.x, i.y);else {\n        var f = s,\n          h = u;\n        s.onCurve || (f = {\n          x: (i.x + s.x) * .5,\n          y: (i.y + s.y) * .5\n        }), u.onCurve || (h = {\n          x: (i.x + u.x) * .5,\n          y: (i.y + u.y) * .5\n        }), r.quadraticCurveTo(i.x, i.y, h.x, h.y);\n      }\n    }\n    r.closePath();\n  }\n  return r;\n}\nfunction ta(e, r) {\n  if (r.isComposite) for (var t = 0; t < r.components.length; t += 1) {\n    var a = r.components[t],\n      n = e.get(a.glyphIndex);\n    if (n.getPath(), n.points) {\n      var s = void 0;\n      if (a.matchedPoints === void 0) s = ir(n.points, a);else {\n        if (a.matchedPoints[0] > r.points.length - 1 || a.matchedPoints[1] > n.points.length - 1) throw Error(\"Matched points out of range in \" + r.name);\n        var i = r.points[a.matchedPoints[0]],\n          u = n.points[a.matchedPoints[1]],\n          o = {\n            xScale: a.xScale,\n            scale01: a.scale01,\n            scale10: a.scale10,\n            yScale: a.yScale,\n            dx: 0,\n            dy: 0\n          };\n        u = ir([u], o)[0], o.dx = i.x - u.x, o.dy = i.y - u.y, s = ir(n.points, o);\n      }\n      r.points = r.points.concat(s);\n    }\n  }\n  return ra(r.points);\n}\nfunction Jn(e, r, t, a) {\n  for (var n = new ue.GlyphSet(a), s = 0; s < t.length - 1; s += 1) {\n    var i = t[s],\n      u = t[s + 1];\n    i !== u ? n.push(s, ue.ttfGlyphLoader(a, s, ea, e, r + i, ta)) : n.push(s, ue.glyphLoader(a, s));\n  }\n  return n;\n}\nfunction jn(e, r, t, a) {\n  var n = new ue.GlyphSet(a);\n  return a._push = function (s) {\n    var i = t[s],\n      u = t[s + 1];\n    i !== u ? n.push(s, ue.ttfGlyphLoader(a, s, ea, e, r + i, ta)) : n.push(s, ue.glyphLoader(a, s));\n  }, n;\n}\nfunction $n(e, r, t, a, n) {\n  return n.lowMemory ? jn(e, r, t, a) : Jn(e, r, t, a);\n}\nvar aa = {\n    getPath: ra,\n    parse: $n\n  },\n  na,\n  Se,\n  sa,\n  br;\nfunction ia(e) {\n  this.font = e, this.getCommands = function (r) {\n    return aa.getPath(r).commands;\n  }, this._fpgmState = this._prepState = void 0, this._errorState = 0;\n}\nfunction es(e) {\n  return e;\n}\nfunction oa(e) {\n  return Math.sign(e) * Math.round(Math.abs(e));\n}\nfunction rs(e) {\n  return Math.sign(e) * Math.round(Math.abs(e * 2)) / 2;\n}\nfunction ts(e) {\n  return Math.sign(e) * (Math.round(Math.abs(e) + .5) - .5);\n}\nfunction as(e) {\n  return Math.sign(e) * Math.ceil(Math.abs(e));\n}\nfunction ns(e) {\n  return Math.sign(e) * Math.floor(Math.abs(e));\n}\nvar ua = function ua(e) {\n    var r = this.srPeriod,\n      t = this.srPhase,\n      a = this.srThreshold,\n      n = 1;\n    return e < 0 && (e = -e, n = -1), e += a - t, e = Math.trunc(e / r) * r, e += t, e < 0 ? t * n : e * n;\n  },\n  oe = {\n    x: 1,\n    y: 0,\n    axis: \"x\",\n    distance: function distance(e, r, t, a) {\n      return (t ? e.xo : e.x) - (a ? r.xo : r.x);\n    },\n    interpolate: function interpolate(e, r, t, a) {\n      var n, s, i, u, o, l, f;\n      if (!a || a === this) {\n        if (n = e.xo - r.xo, s = e.xo - t.xo, o = r.x - r.xo, l = t.x - t.xo, i = Math.abs(n), u = Math.abs(s), f = i + u, f === 0) {\n          e.x = e.xo + (o + l) / 2;\n          return;\n        }\n        e.x = e.xo + (o * u + l * i) / f;\n        return;\n      }\n      if (n = a.distance(e, r, !0, !0), s = a.distance(e, t, !0, !0), o = a.distance(r, r, !1, !0), l = a.distance(t, t, !1, !0), i = Math.abs(n), u = Math.abs(s), f = i + u, f === 0) {\n        oe.setRelative(e, e, (o + l) / 2, a, !0);\n        return;\n      }\n      oe.setRelative(e, e, (o * u + l * i) / f, a, !0);\n    },\n    normalSlope: Number.NEGATIVE_INFINITY,\n    setRelative: function setRelative(e, r, t, a, n) {\n      if (!a || a === this) {\n        e.x = (n ? r.xo : r.x) + t;\n        return;\n      }\n      var s = n ? r.xo : r.x,\n        i = n ? r.yo : r.y,\n        u = s + t * a.x,\n        o = i + t * a.y;\n      e.x = u + (e.y - o) / a.normalSlope;\n    },\n    slope: 0,\n    touch: function touch(e) {\n      e.xTouched = !0;\n    },\n    touched: function touched(e) {\n      return e.xTouched;\n    },\n    untouch: function untouch(e) {\n      e.xTouched = !1;\n    }\n  },\n  le = {\n    x: 0,\n    y: 1,\n    axis: \"y\",\n    distance: function distance(e, r, t, a) {\n      return (t ? e.yo : e.y) - (a ? r.yo : r.y);\n    },\n    interpolate: function interpolate(e, r, t, a) {\n      var n, s, i, u, o, l, f;\n      if (!a || a === this) {\n        if (n = e.yo - r.yo, s = e.yo - t.yo, o = r.y - r.yo, l = t.y - t.yo, i = Math.abs(n), u = Math.abs(s), f = i + u, f === 0) {\n          e.y = e.yo + (o + l) / 2;\n          return;\n        }\n        e.y = e.yo + (o * u + l * i) / f;\n        return;\n      }\n      if (n = a.distance(e, r, !0, !0), s = a.distance(e, t, !0, !0), o = a.distance(r, r, !1, !0), l = a.distance(t, t, !1, !0), i = Math.abs(n), u = Math.abs(s), f = i + u, f === 0) {\n        le.setRelative(e, e, (o + l) / 2, a, !0);\n        return;\n      }\n      le.setRelative(e, e, (o * u + l * i) / f, a, !0);\n    },\n    normalSlope: 0,\n    setRelative: function setRelative(e, r, t, a, n) {\n      if (!a || a === this) {\n        e.y = (n ? r.yo : r.y) + t;\n        return;\n      }\n      var s = n ? r.xo : r.x,\n        i = n ? r.yo : r.y,\n        u = s + t * a.x,\n        o = i + t * a.y;\n      e.y = o + a.normalSlope * (e.x - u);\n    },\n    slope: Number.POSITIVE_INFINITY,\n    touch: function touch(e) {\n      e.yTouched = !0;\n    },\n    touched: function touched(e) {\n      return e.yTouched;\n    },\n    untouch: function untouch(e) {\n      e.yTouched = !1;\n    }\n  };\nObject.freeze(oe);\nObject.freeze(le);\nfunction Ie(e, r) {\n  this.x = e, this.y = r, this.axis = void 0, this.slope = r / e, this.normalSlope = -e / r, Object.freeze(this);\n}\nIe.prototype.distance = function (e, r, t, a) {\n  return this.x * oe.distance(e, r, t, a) + this.y * le.distance(e, r, t, a);\n};\nIe.prototype.interpolate = function (e, r, t, a) {\n  var n, s, i, u, o, l, f;\n  if (i = a.distance(e, r, !0, !0), u = a.distance(e, t, !0, !0), n = a.distance(r, r, !1, !0), s = a.distance(t, t, !1, !0), o = Math.abs(i), l = Math.abs(u), f = o + l, f === 0) {\n    this.setRelative(e, e, (n + s) / 2, a, !0);\n    return;\n  }\n  this.setRelative(e, e, (n * l + s * o) / f, a, !0);\n};\nIe.prototype.setRelative = function (e, r, t, a, n) {\n  a = a || this;\n  var s = n ? r.xo : r.x,\n    i = n ? r.yo : r.y,\n    u = s + t * a.x,\n    o = i + t * a.y,\n    l = a.normalSlope,\n    f = this.slope,\n    h = e.x,\n    p = e.y;\n  e.x = (f * h - l * u + o - p) / (f - l), e.y = f * (e.x - h) + p;\n};\nIe.prototype.touch = function (e) {\n  e.xTouched = !0, e.yTouched = !0;\n};\nfunction Me(e, r) {\n  var t = Math.sqrt(e * e + r * r);\n  return e /= t, r /= t, e === 1 && r === 0 ? oe : e === 0 && r === 1 ? le : new Ie(e, r);\n}\nfunction fe(e, r, t, a) {\n  this.x = this.xo = Math.round(e * 64) / 64, this.y = this.yo = Math.round(r * 64) / 64, this.lastPointOfContour = t, this.onCurve = a, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = !1, this.yTouched = !1, Object.preventExtensions(this);\n}\nfe.prototype.nextTouched = function (e) {\n  for (var r = this.nextPointOnContour; !e.touched(r) && r !== this;) {\n    r = r.nextPointOnContour;\n  }\n  return r;\n};\nfe.prototype.prevTouched = function (e) {\n  for (var r = this.prevPointOnContour; !e.touched(r) && r !== this;) {\n    r = r.prevPointOnContour;\n  }\n  return r;\n};\nvar De = Object.freeze(new fe(0, 0)),\n  ss = {\n    cvCutIn: 17 / 16,\n    deltaBase: 9,\n    deltaShift: .125,\n    loop: 1,\n    minDis: 1,\n    autoFlip: !0\n  };\nfunction de(e, r) {\n  switch (this.env = e, this.stack = [], this.prog = r, e) {\n    case \"glyf\":\n      this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;\n    case \"prep\":\n      this.fv = this.pv = this.dpv = oe, this.round = oa;\n  }\n}\nia.prototype.exec = function (e, r) {\n  if (typeof r != \"number\") throw new Error(\"Point size is not a number!\");\n  if (!(this._errorState > 2)) {\n    var t = this.font,\n      a = this._prepState;\n    if (!a || a.ppem !== r) {\n      var n = this._fpgmState;\n      if (!n) {\n        de.prototype = ss, n = this._fpgmState = new de(\"fpgm\", t.tables.fpgm), n.funcs = [], n.font = t, exports.DEBUG && (console.log(\"---EXEC FPGM---\"), n.step = -1);\n        try {\n          Se(n);\n        } catch (l) {\n          console.log(\"Hinting error in FPGM:\" + l), this._errorState = 3;\n          return;\n        }\n      }\n      de.prototype = n, a = this._prepState = new de(\"prep\", t.tables.prep), a.ppem = r;\n      var s = t.tables.cvt;\n      if (s) for (var i = a.cvt = new Array(s.length), u = r / t.unitsPerEm, o = 0; o < s.length; o++) {\n        i[o] = s[o] * u;\n      } else a.cvt = [];\n      exports.DEBUG && (console.log(\"---EXEC PREP---\"), a.step = -1);\n      try {\n        Se(a);\n      } catch (l) {\n        this._errorState < 2 && console.log(\"Hinting error in PREP:\" + l), this._errorState = 2;\n      }\n    }\n    if (!(this._errorState > 1)) try {\n      return sa(e, a);\n    } catch (l) {\n      this._errorState < 1 && (console.log(\"Hinting error:\" + l), console.log(\"Note: further hinting errors are silenced\")), this._errorState = 1;\n      return;\n    }\n  }\n};\nsa = function sa(e, r) {\n  var t = r.ppem / r.font.unitsPerEm,\n    a = t,\n    n = e.components,\n    s,\n    i,\n    u;\n  if (de.prototype = r, !n) u = new de(\"glyf\", e.instructions), exports.DEBUG && (console.log(\"---EXEC GLYPH---\"), u.step = -1), br(e, u, t, a), i = u.gZone;else {\n    var o = r.font;\n    i = [], s = [];\n    for (var l = 0; l < n.length; l++) {\n      var f = n[l],\n        h = o.glyphs.get(f.glyphIndex);\n      u = new de(\"glyf\", h.instructions), exports.DEBUG && (console.log(\"---EXEC COMP \" + l + \"---\"), u.step = -1), br(h, u, t, a);\n      for (var p = Math.round(f.dx * t), c = Math.round(f.dy * a), d = u.gZone, x = u.contours, m = 0; m < d.length; m++) {\n        var y = d[m];\n        y.xTouched = y.yTouched = !1, y.xo = y.x = y.x + p, y.yo = y.y = y.y + c;\n      }\n      var C = i.length;\n      i.push.apply(i, d);\n      for (var S = 0; S < x.length; S++) {\n        s.push(x[S] + C);\n      }\n    }\n    e.instructions && !u.inhibitGridFit && (u = new de(\"glyf\", e.instructions), u.gZone = u.z0 = u.z1 = u.z2 = i, u.contours = s, i.push(new fe(0, 0), new fe(Math.round(e.advanceWidth * t), 0)), exports.DEBUG && (console.log(\"---EXEC COMPOSITE---\"), u.step = -1), Se(u), i.length -= 2);\n  }\n  return i;\n};\nbr = function br(e, r, t, a) {\n  for (var n = e.points || [], s = n.length, i = r.gZone = r.z0 = r.z1 = r.z2 = [], u = r.contours = [], o, l = 0; l < s; l++) {\n    o = n[l], i[l] = new fe(o.x * t, o.y * a, o.lastPointOfContour, o.onCurve);\n  }\n  for (var f, h, p = 0; p < s; p++) {\n    o = i[p], f || (f = o, u.push(p)), o.lastPointOfContour ? (o.nextPointOnContour = f, f.prevPointOnContour = o, f = void 0) : (h = i[p + 1], o.nextPointOnContour = h, h.prevPointOnContour = o);\n  }\n  if (!r.inhibitGridFit) {\n    if (exports.DEBUG) {\n      console.log(\"PROCESSING GLYPH\", r.stack);\n      for (var c = 0; c < s; c++) {\n        console.log(c, i[c].x, i[c].y);\n      }\n    }\n    if (i.push(new fe(0, 0), new fe(Math.round(e.advanceWidth * t), 0)), Se(r), i.length -= 2, exports.DEBUG) {\n      console.log(\"FINISHED GLYPH\", r.stack);\n      for (var d = 0; d < s; d++) {\n        console.log(d, i[d].x, i[d].y);\n      }\n    }\n  }\n};\nSe = function Se(e) {\n  var r = e.prog;\n  if (!!r) {\n    var t = r.length,\n      a;\n    for (e.ip = 0; e.ip < t; e.ip++) {\n      if (exports.DEBUG && e.step++, a = na[r[e.ip]], !a) throw new Error(\"unknown instruction: 0x\" + Number(r[e.ip]).toString(16));\n      a(e);\n    }\n  }\n};\nfunction $e(e) {\n  for (var r = e.tZone = new Array(e.gZone.length), t = 0; t < r.length; t++) {\n    r[t] = new fe(0, 0);\n  }\n}\nfunction la(e, r) {\n  var t = e.prog,\n    a = e.ip,\n    n = 1,\n    s;\n  do {\n    if (s = t[++a], s === 88) n++;else if (s === 89) n--;else if (s === 64) a += t[a + 1] + 1;else if (s === 65) a += 2 * t[a + 1] + 1;else if (s >= 176 && s <= 183) a += s - 176 + 1;else if (s >= 184 && s <= 191) a += (s - 184 + 1) * 2;else if (r && n === 1 && s === 27) break;\n  } while (n > 0);\n  e.ip = a;\n}\nfunction et(e, r) {\n  exports.DEBUG && console.log(r.step, \"SVTCA[\" + e.axis + \"]\"), r.fv = r.pv = r.dpv = e;\n}\nfunction rt(e, r) {\n  exports.DEBUG && console.log(r.step, \"SPVTCA[\" + e.axis + \"]\"), r.pv = r.dpv = e;\n}\nfunction tt(e, r) {\n  exports.DEBUG && console.log(r.step, \"SFVTCA[\" + e.axis + \"]\"), r.fv = e;\n}\nfunction at(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = t.pop(),\n    s = r.z2[a],\n    i = r.z1[n];\n  exports.DEBUG && console.log(\"SPVTL[\" + e + \"]\", a, n);\n  var u, o;\n  e ? (u = s.y - i.y, o = i.x - s.x) : (u = i.x - s.x, o = i.y - s.y), r.pv = r.dpv = Me(u, o);\n}\nfunction nt(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = t.pop(),\n    s = r.z2[a],\n    i = r.z1[n];\n  exports.DEBUG && console.log(\"SFVTL[\" + e + \"]\", a, n);\n  var u, o;\n  e ? (u = s.y - i.y, o = i.x - s.x) : (u = i.x - s.x, o = i.y - s.y), r.fv = Me(u, o);\n}\nfunction is(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"SPVFS[]\", t, a), e.pv = e.dpv = Me(a, t);\n}\nfunction os(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"SPVFS[]\", t, a), e.fv = Me(a, t);\n}\nfunction us(e) {\n  var r = e.stack,\n    t = e.pv;\n  exports.DEBUG && console.log(e.step, \"GPV[]\"), r.push(t.x * 16384), r.push(t.y * 16384);\n}\nfunction ls(e) {\n  var r = e.stack,\n    t = e.fv;\n  exports.DEBUG && console.log(e.step, \"GFV[]\"), r.push(t.x * 16384), r.push(t.y * 16384);\n}\nfunction fs(e) {\n  e.fv = e.pv, exports.DEBUG && console.log(e.step, \"SFVTPV[]\");\n}\nfunction ps(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop(),\n    n = r.pop(),\n    s = r.pop(),\n    i = r.pop(),\n    u = e.z0,\n    o = e.z1,\n    l = u[t],\n    f = u[a],\n    h = o[n],\n    p = o[s],\n    c = e.z2[i];\n  exports.DEBUG && console.log(\"ISECT[], \", t, a, n, s, i);\n  var d = l.x,\n    x = l.y,\n    m = f.x,\n    y = f.y,\n    C = h.x,\n    S = h.y,\n    R = p.x,\n    O = p.y,\n    D = (d - m) * (S - O) - (x - y) * (C - R),\n    L = d * y - x * m,\n    F = C * O - S * R;\n  c.x = (L * (C - R) - F * (d - m)) / D, c.y = (L * (S - O) - F * (x - y)) / D;\n}\nfunction hs(e) {\n  e.rp0 = e.stack.pop(), exports.DEBUG && console.log(e.step, \"SRP0[]\", e.rp0);\n}\nfunction cs(e) {\n  e.rp1 = e.stack.pop(), exports.DEBUG && console.log(e.step, \"SRP1[]\", e.rp1);\n}\nfunction vs(e) {\n  e.rp2 = e.stack.pop(), exports.DEBUG && console.log(e.step, \"SRP2[]\", e.rp2);\n}\nfunction ds(e) {\n  var r = e.stack.pop();\n  switch (exports.DEBUG && console.log(e.step, \"SZP0[]\", r), e.zp0 = r, r) {\n    case 0:\n      e.tZone || $e(e), e.z0 = e.tZone;\n      break;\n    case 1:\n      e.z0 = e.gZone;\n      break;\n    default:\n      throw new Error(\"Invalid zone pointer\");\n  }\n}\nfunction gs(e) {\n  var r = e.stack.pop();\n  switch (exports.DEBUG && console.log(e.step, \"SZP1[]\", r), e.zp1 = r, r) {\n    case 0:\n      e.tZone || $e(e), e.z1 = e.tZone;\n      break;\n    case 1:\n      e.z1 = e.gZone;\n      break;\n    default:\n      throw new Error(\"Invalid zone pointer\");\n  }\n}\nfunction ms(e) {\n  var r = e.stack.pop();\n  switch (exports.DEBUG && console.log(e.step, \"SZP2[]\", r), e.zp2 = r, r) {\n    case 0:\n      e.tZone || $e(e), e.z2 = e.tZone;\n      break;\n    case 1:\n      e.z2 = e.gZone;\n      break;\n    default:\n      throw new Error(\"Invalid zone pointer\");\n  }\n}\nfunction ys(e) {\n  var r = e.stack.pop();\n  switch (exports.DEBUG && console.log(e.step, \"SZPS[]\", r), e.zp0 = e.zp1 = e.zp2 = r, r) {\n    case 0:\n      e.tZone || $e(e), e.z0 = e.z1 = e.z2 = e.tZone;\n      break;\n    case 1:\n      e.z0 = e.z1 = e.z2 = e.gZone;\n      break;\n    default:\n      throw new Error(\"Invalid zone pointer\");\n  }\n}\nfunction xs(e) {\n  e.loop = e.stack.pop(), exports.DEBUG && console.log(e.step, \"SLOOP[]\", e.loop);\n}\nfunction bs(e) {\n  exports.DEBUG && console.log(e.step, \"RTG[]\"), e.round = oa;\n}\nfunction Ss(e) {\n  exports.DEBUG && console.log(e.step, \"RTHG[]\"), e.round = ts;\n}\nfunction Ts(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"SMD[]\", r), e.minDis = r / 64;\n}\nfunction ks(e) {\n  exports.DEBUG && console.log(e.step, \"ELSE[]\"), la(e, !1);\n}\nfunction Fs(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"JMPR[]\", r), e.ip += r - 1;\n}\nfunction Us(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"SCVTCI[]\", r), e.cvCutIn = r / 64;\n}\nfunction Cs(e) {\n  var r = e.stack;\n  exports.DEBUG && console.log(e.step, \"DUP[]\"), r.push(r[r.length - 1]);\n}\nfunction or(e) {\n  exports.DEBUG && console.log(e.step, \"POP[]\"), e.stack.pop();\n}\nfunction Es(e) {\n  exports.DEBUG && console.log(e.step, \"CLEAR[]\"), e.stack.length = 0;\n}\nfunction Os(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"SWAP[]\"), r.push(t), r.push(a);\n}\nfunction Ls(e) {\n  var r = e.stack;\n  exports.DEBUG && console.log(e.step, \"DEPTH[]\"), r.push(r.length);\n}\nfunction Rs(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"LOOPCALL[]\", t, a);\n  var n = e.ip,\n    s = e.prog;\n  e.prog = e.funcs[t];\n  for (var i = 0; i < a; i++) {\n    Se(e), exports.DEBUG && console.log(++e.step, i + 1 < a ? \"next loopcall\" : \"done loopcall\", i);\n  }\n  e.ip = n, e.prog = s;\n}\nfunction ws(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"CALL[]\", r);\n  var t = e.ip,\n    a = e.prog;\n  e.prog = e.funcs[r], Se(e), e.ip = t, e.prog = a, exports.DEBUG && console.log(++e.step, \"returning from\", r);\n}\nfunction Ds(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"CINDEX[]\", t), r.push(r[r.length - t]);\n}\nfunction As(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"MINDEX[]\", t), r.push(r.splice(r.length - t, 1)[0]);\n}\nfunction Bs(e) {\n  if (e.env !== \"fpgm\") throw new Error(\"FDEF not allowed here\");\n  var r = e.stack,\n    t = e.prog,\n    a = e.ip,\n    n = r.pop(),\n    s = a;\n  for (exports.DEBUG && console.log(e.step, \"FDEF[]\", n); t[++a] !== 45;) {\n    ;\n  }\n  e.ip = a, e.funcs[n] = t.slice(s + 1, a);\n}\nfunction st(e, r) {\n  var t = r.stack.pop(),\n    a = r.z0[t],\n    n = r.fv,\n    s = r.pv;\n  exports.DEBUG && console.log(r.step, \"MDAP[\" + e + \"]\", t);\n  var i = s.distance(a, De);\n  e && (i = r.round(i)), n.setRelative(a, De, i, s), n.touch(a), r.rp0 = r.rp1 = t;\n}\nfunction it(e, r) {\n  var t = r.z2,\n    a = t.length - 2,\n    n,\n    s,\n    i;\n  exports.DEBUG && console.log(r.step, \"IUP[\" + e.axis + \"]\");\n  for (var u = 0; u < a; u++) {\n    n = t[u], !e.touched(n) && (s = n.prevTouched(e), s !== n && (i = n.nextTouched(e), s === i && e.setRelative(n, n, e.distance(s, s, !1, !0), e, !0), e.interpolate(n, s, i, e)));\n  }\n}\nfunction ot(e, r) {\n  for (var t = r.stack, a = e ? r.rp1 : r.rp2, n = (e ? r.z0 : r.z1)[a], s = r.fv, i = r.pv, u = r.loop, o = r.z2; u--;) {\n    var l = t.pop(),\n      f = o[l],\n      h = i.distance(n, n, !1, !0);\n    s.setRelative(f, f, h, i), s.touch(f), exports.DEBUG && console.log(r.step, (r.loop > 1 ? \"loop \" + (r.loop - u) + \": \" : \"\") + \"SHP[\" + (e ? \"rp1\" : \"rp2\") + \"]\", l);\n  }\n  r.loop = 1;\n}\nfunction ut(e, r) {\n  var t = r.stack,\n    a = e ? r.rp1 : r.rp2,\n    n = (e ? r.z0 : r.z1)[a],\n    s = r.fv,\n    i = r.pv,\n    u = t.pop(),\n    o = r.z2[r.contours[u]],\n    l = o;\n  exports.DEBUG && console.log(r.step, \"SHC[\" + e + \"]\", u);\n  var f = i.distance(n, n, !1, !0);\n  do {\n    l !== n && s.setRelative(l, l, f, i), l = l.nextPointOnContour;\n  } while (l !== o);\n}\nfunction lt(e, r) {\n  var t = r.stack,\n    a = e ? r.rp1 : r.rp2,\n    n = (e ? r.z0 : r.z1)[a],\n    s = r.fv,\n    i = r.pv,\n    u = t.pop();\n  exports.DEBUG && console.log(r.step, \"SHZ[\" + e + \"]\", u);\n  var o;\n  switch (u) {\n    case 0:\n      o = r.tZone;\n      break;\n    case 1:\n      o = r.gZone;\n      break;\n    default:\n      throw new Error(\"Invalid zone\");\n  }\n  for (var l, f = i.distance(n, n, !1, !0), h = o.length - 2, p = 0; p < h; p++) {\n    l = o[p], s.setRelative(l, l, f, i);\n  }\n}\nfunction Is(e) {\n  for (var r = e.stack, t = e.loop, a = e.fv, n = r.pop() / 64, s = e.z2; t--;) {\n    var i = r.pop(),\n      u = s[i];\n    exports.DEBUG && console.log(e.step, (e.loop > 1 ? \"loop \" + (e.loop - t) + \": \" : \"\") + \"SHPIX[]\", i, n), a.setRelative(u, u, n), a.touch(u);\n  }\n  e.loop = 1;\n}\nfunction Ms(e) {\n  for (var r = e.stack, t = e.rp1, a = e.rp2, n = e.loop, s = e.z0[t], i = e.z1[a], u = e.fv, o = e.dpv, l = e.z2; n--;) {\n    var f = r.pop(),\n      h = l[f];\n    exports.DEBUG && console.log(e.step, (e.loop > 1 ? \"loop \" + (e.loop - n) + \": \" : \"\") + \"IP[]\", f, t, \"<->\", a), u.interpolate(h, s, i, o), u.touch(h);\n  }\n  e.loop = 1;\n}\nfunction ft(e, r) {\n  var t = r.stack,\n    a = t.pop() / 64,\n    n = t.pop(),\n    s = r.z1[n],\n    i = r.z0[r.rp0],\n    u = r.fv,\n    o = r.pv;\n  u.setRelative(s, i, a, o), u.touch(s), exports.DEBUG && console.log(r.step, \"MSIRP[\" + e + \"]\", a, n), r.rp1 = r.rp0, r.rp2 = n, e && (r.rp0 = n);\n}\nfunction Ps(e) {\n  for (var r = e.stack, t = e.rp0, a = e.z0[t], n = e.loop, s = e.fv, i = e.pv, u = e.z1; n--;) {\n    var o = r.pop(),\n      l = u[o];\n    exports.DEBUG && console.log(e.step, (e.loop > 1 ? \"loop \" + (e.loop - n) + \": \" : \"\") + \"ALIGNRP[]\", o), s.setRelative(l, a, 0, i), s.touch(l);\n  }\n  e.loop = 1;\n}\nfunction Gs(e) {\n  exports.DEBUG && console.log(e.step, \"RTDG[]\"), e.round = rs;\n}\nfunction pt(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = t.pop(),\n    s = r.z0[n],\n    i = r.fv,\n    u = r.pv,\n    o = r.cvt[a];\n  exports.DEBUG && console.log(r.step, \"MIAP[\" + e + \"]\", a, \"(\", o, \")\", n);\n  var l = u.distance(s, De);\n  e && (Math.abs(l - o) < r.cvCutIn && (l = o), l = r.round(l)), i.setRelative(s, De, l, u), r.zp0 === 0 && (s.xo = s.x, s.yo = s.y), i.touch(s), r.rp0 = r.rp1 = n;\n}\nfunction Ns(e) {\n  var r = e.prog,\n    t = e.ip,\n    a = e.stack,\n    n = r[++t];\n  exports.DEBUG && console.log(e.step, \"NPUSHB[]\", n);\n  for (var s = 0; s < n; s++) {\n    a.push(r[++t]);\n  }\n  e.ip = t;\n}\nfunction Hs(e) {\n  var r = e.ip,\n    t = e.prog,\n    a = e.stack,\n    n = t[++r];\n  exports.DEBUG && console.log(e.step, \"NPUSHW[]\", n);\n  for (var s = 0; s < n; s++) {\n    var i = t[++r] << 8 | t[++r];\n    i & 32768 && (i = -((i ^ 65535) + 1)), a.push(i);\n  }\n  e.ip = r;\n}\nfunction zs(e) {\n  var r = e.stack,\n    t = e.store;\n  t || (t = e.store = []);\n  var a = r.pop(),\n    n = r.pop();\n  exports.DEBUG && console.log(e.step, \"WS\", a, n), t[n] = a;\n}\nfunction Ws(e) {\n  var r = e.stack,\n    t = e.store,\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"RS\", a);\n  var n = t && t[a] || 0;\n  r.push(n);\n}\nfunction _s(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"WCVTP\", t, a), e.cvt[a] = t / 64;\n}\nfunction Vs(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"RCVT\", t), r.push(e.cvt[t] * 64);\n}\nfunction ht(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = r.z2[a];\n  exports.DEBUG && console.log(r.step, \"GC[\" + e + \"]\", a), t.push(r.dpv.distance(n, De, e, !1) * 64);\n}\nfunction ct(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = t.pop(),\n    s = r.z1[a],\n    i = r.z0[n],\n    u = r.dpv.distance(i, s, e, e);\n  exports.DEBUG && console.log(r.step, \"MD[\" + e + \"]\", a, n, \"->\", u), r.stack.push(Math.round(u * 64));\n}\nfunction qs(e) {\n  exports.DEBUG && console.log(e.step, \"MPPEM[]\"), e.stack.push(e.ppem);\n}\nfunction Xs(e) {\n  exports.DEBUG && console.log(e.step, \"FLIPON[]\"), e.autoFlip = !0;\n}\nfunction Ys(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"LT[]\", t, a), r.push(a < t ? 1 : 0);\n}\nfunction Zs(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"LTEQ[]\", t, a), r.push(a <= t ? 1 : 0);\n}\nfunction Qs(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"GT[]\", t, a), r.push(a > t ? 1 : 0);\n}\nfunction Ks(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"GTEQ[]\", t, a), r.push(a >= t ? 1 : 0);\n}\nfunction Js(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"EQ[]\", t, a), r.push(t === a ? 1 : 0);\n}\nfunction js(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"NEQ[]\", t, a), r.push(t !== a ? 1 : 0);\n}\nfunction $s(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"ODD[]\", t), r.push(Math.trunc(t) % 2 ? 1 : 0);\n}\nfunction ei(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"EVEN[]\", t), r.push(Math.trunc(t) % 2 ? 0 : 1);\n}\nfunction ri(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"IF[]\", r), r || (la(e, !0), exports.DEBUG && console.log(e.step, \"EIF[]\"));\n}\nfunction ti(e) {\n  exports.DEBUG && console.log(e.step, \"EIF[]\");\n}\nfunction ai(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"AND[]\", t, a), r.push(t && a ? 1 : 0);\n}\nfunction ni(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"OR[]\", t, a), r.push(t || a ? 1 : 0);\n}\nfunction si(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"NOT[]\", t), r.push(t ? 0 : 1);\n}\nfunction ur(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = r.fv,\n    s = r.pv,\n    i = r.ppem,\n    u = r.deltaBase + (e - 1) * 16,\n    o = r.deltaShift,\n    l = r.z0;\n  exports.DEBUG && console.log(r.step, \"DELTAP[\" + e + \"]\", a, t);\n  for (var f = 0; f < a; f++) {\n    var h = t.pop(),\n      p = t.pop(),\n      c = u + ((p & 240) >> 4);\n    if (c === i) {\n      var d = (p & 15) - 8;\n      d >= 0 && d++, exports.DEBUG && console.log(r.step, \"DELTAPFIX\", h, \"by\", d * o);\n      var x = l[h];\n      n.setRelative(x, x, d * o, s);\n    }\n  }\n}\nfunction ii(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"SDB[]\", t), e.deltaBase = t;\n}\nfunction oi(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"SDS[]\", t), e.deltaShift = Math.pow(.5, t);\n}\nfunction ui(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"ADD[]\", t, a), r.push(a + t);\n}\nfunction li(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"SUB[]\", t, a), r.push(a - t);\n}\nfunction fi(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"DIV[]\", t, a), r.push(a * 64 / t);\n}\nfunction pi(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"MUL[]\", t, a), r.push(a * t / 64);\n}\nfunction hi(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"ABS[]\", t), r.push(Math.abs(t));\n}\nfunction ci(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"NEG[]\", t), r.push(-t);\n}\nfunction vi(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"FLOOR[]\", t), r.push(Math.floor(t / 64) * 64);\n}\nfunction di(e) {\n  var r = e.stack,\n    t = r.pop();\n  exports.DEBUG && console.log(e.step, \"CEILING[]\", t), r.push(Math.ceil(t / 64) * 64);\n}\nfunction Ve(e, r) {\n  var t = r.stack,\n    a = t.pop();\n  exports.DEBUG && console.log(r.step, \"ROUND[]\"), t.push(r.round(a / 64) * 64);\n}\nfunction gi(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"WCVTF[]\", t, a), e.cvt[a] = t * e.ppem / e.font.unitsPerEm;\n}\nfunction lr(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = r.ppem,\n    s = r.deltaBase + (e - 1) * 16,\n    i = r.deltaShift;\n  exports.DEBUG && console.log(r.step, \"DELTAC[\" + e + \"]\", a, t);\n  for (var u = 0; u < a; u++) {\n    var o = t.pop(),\n      l = t.pop(),\n      f = s + ((l & 240) >> 4);\n    if (f === n) {\n      var h = (l & 15) - 8;\n      h >= 0 && h++;\n      var p = h * i;\n      exports.DEBUG && console.log(r.step, \"DELTACFIX\", o, \"by\", p), r.cvt[o] += p;\n    }\n  }\n}\nfunction mi(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"SROUND[]\", r), e.round = ua;\n  var t;\n  switch (r & 192) {\n    case 0:\n      t = .5;\n      break;\n    case 64:\n      t = 1;\n      break;\n    case 128:\n      t = 2;\n      break;\n    default:\n      throw new Error(\"invalid SROUND value\");\n  }\n  switch (e.srPeriod = t, r & 48) {\n    case 0:\n      e.srPhase = 0;\n      break;\n    case 16:\n      e.srPhase = .25 * t;\n      break;\n    case 32:\n      e.srPhase = .5 * t;\n      break;\n    case 48:\n      e.srPhase = .75 * t;\n      break;\n    default:\n      throw new Error(\"invalid SROUND value\");\n  }\n  r &= 15, r === 0 ? e.srThreshold = 0 : e.srThreshold = (r / 8 - .5) * t;\n}\nfunction yi(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"S45ROUND[]\", r), e.round = ua;\n  var t;\n  switch (r & 192) {\n    case 0:\n      t = Math.sqrt(2) / 2;\n      break;\n    case 64:\n      t = Math.sqrt(2);\n      break;\n    case 128:\n      t = 2 * Math.sqrt(2);\n      break;\n    default:\n      throw new Error(\"invalid S45ROUND value\");\n  }\n  switch (e.srPeriod = t, r & 48) {\n    case 0:\n      e.srPhase = 0;\n      break;\n    case 16:\n      e.srPhase = .25 * t;\n      break;\n    case 32:\n      e.srPhase = .5 * t;\n      break;\n    case 48:\n      e.srPhase = .75 * t;\n      break;\n    default:\n      throw new Error(\"invalid S45ROUND value\");\n  }\n  r &= 15, r === 0 ? e.srThreshold = 0 : e.srThreshold = (r / 8 - .5) * t;\n}\nfunction xi(e) {\n  exports.DEBUG && console.log(e.step, \"ROFF[]\"), e.round = es;\n}\nfunction bi(e) {\n  exports.DEBUG && console.log(e.step, \"RUTG[]\"), e.round = as;\n}\nfunction Si(e) {\n  exports.DEBUG && console.log(e.step, \"RDTG[]\"), e.round = ns;\n}\nfunction Ti(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"SCANCTRL[]\", r);\n}\nfunction vt(e, r) {\n  var t = r.stack,\n    a = t.pop(),\n    n = t.pop(),\n    s = r.z2[a],\n    i = r.z1[n];\n  exports.DEBUG && console.log(r.step, \"SDPVTL[\" + e + \"]\", a, n);\n  var u, o;\n  e ? (u = s.y - i.y, o = i.x - s.x) : (u = i.x - s.x, o = i.y - s.y), r.dpv = Me(u, o);\n}\nfunction ki(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = 0;\n  exports.DEBUG && console.log(e.step, \"GETINFO[]\", t), t & 1 && (a = 35), t & 32 && (a |= 4096), r.push(a);\n}\nfunction Fi(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop(),\n    n = r.pop();\n  exports.DEBUG && console.log(e.step, \"ROLL[]\"), r.push(a), r.push(t), r.push(n);\n}\nfunction Ui(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"MAX[]\", t, a), r.push(Math.max(a, t));\n}\nfunction Ci(e) {\n  var r = e.stack,\n    t = r.pop(),\n    a = r.pop();\n  exports.DEBUG && console.log(e.step, \"MIN[]\", t, a), r.push(Math.min(a, t));\n}\nfunction Ei(e) {\n  var r = e.stack.pop();\n  exports.DEBUG && console.log(e.step, \"SCANTYPE[]\", r);\n}\nfunction Oi(e) {\n  var r = e.stack.pop(),\n    t = e.stack.pop();\n  switch (exports.DEBUG && console.log(e.step, \"INSTCTRL[]\", r, t), r) {\n    case 1:\n      e.inhibitGridFit = !!t;\n      return;\n    case 2:\n      e.ignoreCvt = !!t;\n      return;\n    default:\n      throw new Error(\"invalid INSTCTRL[] selector\");\n  }\n}\nfunction he(e, r) {\n  var t = r.stack,\n    a = r.prog,\n    n = r.ip;\n  exports.DEBUG && console.log(r.step, \"PUSHB[\" + e + \"]\");\n  for (var s = 0; s < e; s++) {\n    t.push(a[++n]);\n  }\n  r.ip = n;\n}\nfunction ce(e, r) {\n  var t = r.ip,\n    a = r.prog,\n    n = r.stack;\n  exports.DEBUG && console.log(r.ip, \"PUSHW[\" + e + \"]\");\n  for (var s = 0; s < e; s++) {\n    var i = a[++t] << 8 | a[++t];\n    i & 32768 && (i = -((i ^ 65535) + 1)), n.push(i);\n  }\n  r.ip = t;\n}\nfunction T(e, r, t, a, n, s) {\n  var i = s.stack,\n    u = e && i.pop(),\n    o = i.pop(),\n    l = s.rp0,\n    f = s.z0[l],\n    h = s.z1[o],\n    p = s.minDis,\n    c = s.fv,\n    d = s.dpv,\n    x,\n    m,\n    y,\n    C;\n  m = x = d.distance(h, f, !0, !0), y = m >= 0 ? 1 : -1, m = Math.abs(m), e && (C = s.cvt[u], a && Math.abs(m - C) < s.cvCutIn && (m = C)), t && m < p && (m = p), a && (m = s.round(m)), c.setRelative(h, f, y * m, d), c.touch(h), exports.DEBUG && console.log(s.step, (e ? \"MIRP[\" : \"MDRP[\") + (r ? \"M\" : \"m\") + (t ? \">\" : \"_\") + (a ? \"R\" : \"_\") + (n === 0 ? \"Gr\" : n === 1 ? \"Bl\" : n === 2 ? \"Wh\" : \"\") + \"]\", e ? u + \"(\" + s.cvt[u] + \",\" + C + \")\" : \"\", o, \"(d =\", x, \"->\", y * m, \")\"), s.rp1 = s.rp0, s.rp2 = o, r && (s.rp0 = o);\n}\nna = [et.bind(void 0, le), et.bind(void 0, oe), rt.bind(void 0, le), rt.bind(void 0, oe), tt.bind(void 0, le), tt.bind(void 0, oe), at.bind(void 0, 0), at.bind(void 0, 1), nt.bind(void 0, 0), nt.bind(void 0, 1), is, os, us, ls, fs, ps, hs, cs, vs, ds, gs, ms, ys, xs, bs, Ss, Ts, ks, Fs, Us, void 0, void 0, Cs, or, Es, Os, Ls, Ds, As, void 0, void 0, void 0, Rs, ws, Bs, void 0, st.bind(void 0, 0), st.bind(void 0, 1), it.bind(void 0, le), it.bind(void 0, oe), ot.bind(void 0, 0), ot.bind(void 0, 1), ut.bind(void 0, 0), ut.bind(void 0, 1), lt.bind(void 0, 0), lt.bind(void 0, 1), Is, Ms, ft.bind(void 0, 0), ft.bind(void 0, 1), Ps, Gs, pt.bind(void 0, 0), pt.bind(void 0, 1), Ns, Hs, zs, Ws, _s, Vs, ht.bind(void 0, 0), ht.bind(void 0, 1), void 0, ct.bind(void 0, 0), ct.bind(void 0, 1), qs, void 0, Xs, void 0, void 0, Ys, Zs, Qs, Ks, Js, js, $s, ei, ri, ti, ai, ni, si, ur.bind(void 0, 1), ii, oi, ui, li, fi, pi, hi, ci, vi, di, Ve.bind(void 0, 0), Ve.bind(void 0, 1), Ve.bind(void 0, 2), Ve.bind(void 0, 3), void 0, void 0, void 0, void 0, gi, ur.bind(void 0, 2), ur.bind(void 0, 3), lr.bind(void 0, 1), lr.bind(void 0, 2), lr.bind(void 0, 3), mi, yi, void 0, void 0, xi, void 0, bi, Si, or, or, void 0, void 0, void 0, void 0, void 0, Ti, vt.bind(void 0, 0), vt.bind(void 0, 1), ki, void 0, Fi, Ui, Ci, Ei, Oi, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, he.bind(void 0, 1), he.bind(void 0, 2), he.bind(void 0, 3), he.bind(void 0, 4), he.bind(void 0, 5), he.bind(void 0, 6), he.bind(void 0, 7), he.bind(void 0, 8), ce.bind(void 0, 1), ce.bind(void 0, 2), ce.bind(void 0, 3), ce.bind(void 0, 4), ce.bind(void 0, 5), ce.bind(void 0, 6), ce.bind(void 0, 7), ce.bind(void 0, 8), T.bind(void 0, 0, 0, 0, 0, 0), T.bind(void 0, 0, 0, 0, 0, 1), T.bind(void 0, 0, 0, 0, 0, 2), T.bind(void 0, 0, 0, 0, 0, 3), T.bind(void 0, 0, 0, 0, 1, 0), T.bind(void 0, 0, 0, 0, 1, 1), T.bind(void 0, 0, 0, 0, 1, 2), T.bind(void 0, 0, 0, 0, 1, 3), T.bind(void 0, 0, 0, 1, 0, 0), T.bind(void 0, 0, 0, 1, 0, 1), T.bind(void 0, 0, 0, 1, 0, 2), T.bind(void 0, 0, 0, 1, 0, 3), T.bind(void 0, 0, 0, 1, 1, 0), T.bind(void 0, 0, 0, 1, 1, 1), T.bind(void 0, 0, 0, 1, 1, 2), T.bind(void 0, 0, 0, 1, 1, 3), T.bind(void 0, 0, 1, 0, 0, 0), T.bind(void 0, 0, 1, 0, 0, 1), T.bind(void 0, 0, 1, 0, 0, 2), T.bind(void 0, 0, 1, 0, 0, 3), T.bind(void 0, 0, 1, 0, 1, 0), T.bind(void 0, 0, 1, 0, 1, 1), T.bind(void 0, 0, 1, 0, 1, 2), T.bind(void 0, 0, 1, 0, 1, 3), T.bind(void 0, 0, 1, 1, 0, 0), T.bind(void 0, 0, 1, 1, 0, 1), T.bind(void 0, 0, 1, 1, 0, 2), T.bind(void 0, 0, 1, 1, 0, 3), T.bind(void 0, 0, 1, 1, 1, 0), T.bind(void 0, 0, 1, 1, 1, 1), T.bind(void 0, 0, 1, 1, 1, 2), T.bind(void 0, 0, 1, 1, 1, 3), T.bind(void 0, 1, 0, 0, 0, 0), T.bind(void 0, 1, 0, 0, 0, 1), T.bind(void 0, 1, 0, 0, 0, 2), T.bind(void 0, 1, 0, 0, 0, 3), T.bind(void 0, 1, 0, 0, 1, 0), T.bind(void 0, 1, 0, 0, 1, 1), T.bind(void 0, 1, 0, 0, 1, 2), T.bind(void 0, 1, 0, 0, 1, 3), T.bind(void 0, 1, 0, 1, 0, 0), T.bind(void 0, 1, 0, 1, 0, 1), T.bind(void 0, 1, 0, 1, 0, 2), T.bind(void 0, 1, 0, 1, 0, 3), T.bind(void 0, 1, 0, 1, 1, 0), T.bind(void 0, 1, 0, 1, 1, 1), T.bind(void 0, 1, 0, 1, 1, 2), T.bind(void 0, 1, 0, 1, 1, 3), T.bind(void 0, 1, 1, 0, 0, 0), T.bind(void 0, 1, 1, 0, 0, 1), T.bind(void 0, 1, 1, 0, 0, 2), T.bind(void 0, 1, 1, 0, 0, 3), T.bind(void 0, 1, 1, 0, 1, 0), T.bind(void 0, 1, 1, 0, 1, 1), T.bind(void 0, 1, 1, 0, 1, 2), T.bind(void 0, 1, 1, 0, 1, 3), T.bind(void 0, 1, 1, 1, 0, 0), T.bind(void 0, 1, 1, 1, 0, 1), T.bind(void 0, 1, 1, 1, 0, 2), T.bind(void 0, 1, 1, 1, 0, 3), T.bind(void 0, 1, 1, 1, 1, 0), T.bind(void 0, 1, 1, 1, 1, 1), T.bind(void 0, 1, 1, 1, 1, 2), T.bind(void 0, 1, 1, 1, 1, 3)];\nfunction Ce(e) {\n  this[\"char\"] = e, this.state = {}, this.activeState = null;\n}\nfunction Lr(e, r, t) {\n  this.contextName = t, this.startIndex = e, this.endOffset = r;\n}\nfunction Li(e, r, t) {\n  this.contextName = e, this.openRange = null, this.ranges = [], this.checkStart = r, this.checkEnd = t;\n}\nfunction re(e, r) {\n  this.context = e, this.index = r, this.length = e.length, this.current = e[r], this.backtrack = e.slice(0, r), this.lookahead = e.slice(r + 1);\n}\nfunction er(e) {\n  this.eventId = e, this.subscribers = [];\n}\nfunction Ri(e) {\n  var r = this,\n    t = [\"start\", \"end\", \"next\", \"newToken\", \"contextStart\", \"contextEnd\", \"insertToken\", \"removeToken\", \"removeRange\", \"replaceToken\", \"replaceRange\", \"composeRUD\", \"updateContextsRanges\"];\n  t.forEach(function (n) {\n    Object.defineProperty(r.events, n, {\n      value: new er(n)\n    });\n  }), e && t.forEach(function (n) {\n    var s = e[n];\n    typeof s == \"function\" && r.events[n].subscribe(s);\n  });\n  var a = [\"insertToken\", \"removeToken\", \"removeRange\", \"replaceToken\", \"replaceRange\", \"composeRUD\"];\n  a.forEach(function (n) {\n    r.events[n].subscribe(r.updateContextsRanges);\n  });\n}\nfunction B(e) {\n  this.tokens = [], this.registeredContexts = {}, this.contextCheckers = [], this.events = {}, this.registeredModifiers = [], Ri.call(this, e);\n}\nCe.prototype.setState = function (e, r) {\n  return this.state[e] = r, this.activeState = {\n    key: e,\n    value: this.state[e]\n  }, this.activeState;\n};\nCe.prototype.getState = function (e) {\n  return this.state[e] || null;\n};\nB.prototype.inboundIndex = function (e) {\n  return e >= 0 && e < this.tokens.length;\n};\nB.prototype.composeRUD = function (e) {\n  var r = this,\n    t = !0,\n    a = e.map(function (s) {\n      return r[s[0]].apply(r, s.slice(1).concat(t));\n    }),\n    n = function n(s) {\n      return typeof s == \"object\" && s.hasOwnProperty(\"FAIL\");\n    };\n  if (a.every(n)) return {\n    FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n    report: a.filter(n)\n  };\n  this.dispatch(\"composeRUD\", [a.filter(function (s) {\n    return !n(s);\n  })]);\n};\nB.prototype.replaceRange = function (e, r, t, a) {\n  r = r !== null ? r : this.tokens.length;\n  var n = t.every(function (i) {\n    return i instanceof Ce;\n  });\n  if (!isNaN(e) && this.inboundIndex(e) && n) {\n    var s = this.tokens.splice.apply(this.tokens, [e, r].concat(t));\n    return a || this.dispatch(\"replaceToken\", [e, r, t]), [s, t];\n  } else return {\n    FAIL: \"replaceRange: invalid tokens or startIndex.\"\n  };\n};\nB.prototype.replaceToken = function (e, r, t) {\n  if (!isNaN(e) && this.inboundIndex(e) && r instanceof Ce) {\n    var a = this.tokens.splice(e, 1, r);\n    return t || this.dispatch(\"replaceToken\", [e, r]), [a[0], r];\n  } else return {\n    FAIL: \"replaceToken: invalid token or index.\"\n  };\n};\nB.prototype.removeRange = function (e, r, t) {\n  r = isNaN(r) ? this.tokens.length : r;\n  var a = this.tokens.splice(e, r);\n  return t || this.dispatch(\"removeRange\", [a, e, r]), a;\n};\nB.prototype.removeToken = function (e, r) {\n  if (!isNaN(e) && this.inboundIndex(e)) {\n    var t = this.tokens.splice(e, 1);\n    return r || this.dispatch(\"removeToken\", [t, e]), t;\n  } else return {\n    FAIL: \"removeToken: invalid token index.\"\n  };\n};\nB.prototype.insertToken = function (e, r, t) {\n  var a = e.every(function (n) {\n    return n instanceof Ce;\n  });\n  return a ? (this.tokens.splice.apply(this.tokens, [r, 0].concat(e)), t || this.dispatch(\"insertToken\", [e, r]), e) : {\n    FAIL: \"insertToken: invalid token(s).\"\n  };\n};\nB.prototype.registerModifier = function (e, r, t) {\n  this.events.newToken.subscribe(function (a, n) {\n    var s = [a, n],\n      i = r === null || r.apply(this, s) === !0,\n      u = [a, n];\n    if (i) {\n      var o = t.apply(this, u);\n      a.setState(e, o);\n    }\n  }), this.registeredModifiers.push(e);\n};\ner.prototype.subscribe = function (e) {\n  return typeof e == \"function\" ? this.subscribers.push(e) - 1 : {\n    FAIL: \"invalid '\" + this.eventId + \"' event handler\"\n  };\n};\ner.prototype.unsubscribe = function (e) {\n  this.subscribers.splice(e, 1);\n};\nre.prototype.setCurrentIndex = function (e) {\n  this.index = e, this.current = this.context[e], this.backtrack = this.context.slice(0, e), this.lookahead = this.context.slice(e + 1);\n};\nre.prototype.get = function (e) {\n  switch (!0) {\n    case e === 0:\n      return this.current;\n    case e < 0 && Math.abs(e) <= this.backtrack.length:\n      return this.backtrack.slice(e)[0];\n    case e > 0 && e <= this.lookahead.length:\n      return this.lookahead[e - 1];\n    default:\n      return null;\n  }\n};\nB.prototype.rangeToText = function (e) {\n  if (e instanceof Lr) return this.getRangeTokens(e).map(function (r) {\n    return r[\"char\"];\n  }).join(\"\");\n};\nB.prototype.getText = function () {\n  return this.tokens.map(function (e) {\n    return e[\"char\"];\n  }).join(\"\");\n};\nB.prototype.getContext = function (e) {\n  var r = this.registeredContexts[e];\n  return r || null;\n};\nB.prototype.on = function (e, r) {\n  var t = this.events[e];\n  return t ? t.subscribe(r) : null;\n};\nB.prototype.dispatch = function (e, r) {\n  var t = this,\n    a = this.events[e];\n  a instanceof er && a.subscribers.forEach(function (n) {\n    n.apply(t, r || []);\n  });\n};\nB.prototype.registerContextChecker = function (e, r, t) {\n  if (this.getContext(e)) return {\n    FAIL: \"context name '\" + e + \"' is already registered.\"\n  };\n  if (typeof r != \"function\") return {\n    FAIL: \"missing context start check.\"\n  };\n  if (typeof t != \"function\") return {\n    FAIL: \"missing context end check.\"\n  };\n  var a = new Li(e, r, t);\n  return this.registeredContexts[e] = a, this.contextCheckers.push(a), a;\n};\nB.prototype.getRangeTokens = function (e) {\n  var r = e.startIndex + e.endOffset;\n  return [].concat(this.tokens.slice(e.startIndex, r));\n};\nB.prototype.getContextRanges = function (e) {\n  var r = this.getContext(e);\n  return r ? r.ranges : {\n    FAIL: \"context checker '\" + e + \"' is not registered.\"\n  };\n};\nB.prototype.resetContextsRanges = function () {\n  var e = this.registeredContexts;\n  for (var r in e) {\n    if (e.hasOwnProperty(r)) {\n      var t = e[r];\n      t.ranges = [];\n    }\n  }\n};\nB.prototype.updateContextsRanges = function () {\n  this.resetContextsRanges();\n  for (var e = this.tokens.map(function (a) {\n      return a[\"char\"];\n    }), r = 0; r < e.length; r++) {\n    var t = new re(e, r);\n    this.runContextCheck(t);\n  }\n  this.dispatch(\"updateContextsRanges\", [this.registeredContexts]);\n};\nB.prototype.setEndOffset = function (e, r) {\n  var t = this.getContext(r).openRange.startIndex,\n    a = new Lr(t, e, r),\n    n = this.getContext(r).ranges;\n  return a.rangeId = r + \".\" + n.length, n.push(a), this.getContext(r).openRange = null, a;\n};\nB.prototype.runContextCheck = function (e) {\n  var r = this,\n    t = e.index;\n  this.contextCheckers.forEach(function (a) {\n    var n = a.contextName,\n      s = r.getContext(n).openRange;\n    if (!s && a.checkStart(e) && (s = new Lr(t, null, n), r.getContext(n).openRange = s, r.dispatch(\"contextStart\", [n, t])), !!s && a.checkEnd(e)) {\n      var i = t - s.startIndex + 1,\n        u = r.setEndOffset(i, n);\n      r.dispatch(\"contextEnd\", [n, u]);\n    }\n  });\n};\nB.prototype.tokenize = function (e) {\n  this.tokens = [], this.resetContextsRanges();\n  var r = Array.from(e);\n  this.dispatch(\"start\");\n  for (var t = 0; t < r.length; t++) {\n    var a = r[t],\n      n = new re(r, t);\n    this.dispatch(\"next\", [n]), this.runContextCheck(n);\n    var s = new Ce(a);\n    this.tokens.push(s), this.dispatch(\"newToken\", [s, n]);\n  }\n  return this.dispatch(\"end\", [this.tokens]), this.tokens;\n};\nfunction ge(e) {\n  return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(e);\n}\nfunction fa(e) {\n  return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(e);\n}\nfunction me(e) {\n  return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(e);\n}\nfunction Xe(e) {\n  return /[A-z]/.test(e);\n}\nfunction wi(e) {\n  return /\\s/.test(e);\n}\nfunction J(e) {\n  this.font = e, this.features = {};\n}\nfunction be(e) {\n  this.id = e.id, this.tag = e.tag, this.substitution = e.substitution;\n}\nfunction Pe(e, r) {\n  if (!e) return -1;\n  switch (r.format) {\n    case 1:\n      return r.glyphs.indexOf(e);\n    case 2:\n      for (var t = r.ranges, a = 0; a < t.length; a++) {\n        var n = t[a];\n        if (e >= n.start && e <= n.end) {\n          var s = e - n.start;\n          return n.index + s;\n        }\n      }\n      break;\n    default:\n      return -1;\n  }\n  return -1;\n}\nfunction Di(e, r) {\n  var t = Pe(e, r.coverage);\n  return t === -1 ? null : e + r.deltaGlyphId;\n}\nfunction Ai(e, r) {\n  var t = Pe(e, r.coverage);\n  return t === -1 ? null : r.substitute[t];\n}\nfunction fr(e, r) {\n  for (var t = [], a = 0; a < e.length; a++) {\n    var n = e[a],\n      s = r.current;\n    s = Array.isArray(s) ? s[0] : s;\n    var i = Pe(s, n);\n    i !== -1 && t.push(i);\n  }\n  return t.length !== e.length ? -1 : t;\n}\nfunction Bi(e, r) {\n  var t = r.inputCoverage.length + r.lookaheadCoverage.length + r.backtrackCoverage.length;\n  if (e.context.length < t) return [];\n  var a = fr(r.inputCoverage, e);\n  if (a === -1) return [];\n  var n = r.inputCoverage.length - 1;\n  if (e.lookahead.length < r.lookaheadCoverage.length) return [];\n  for (var s = e.lookahead.slice(n); s.length && me(s[0][\"char\"]);) {\n    s.shift();\n  }\n  var i = new re(s, 0),\n    u = fr(r.lookaheadCoverage, i),\n    o = [].concat(e.backtrack);\n  for (o.reverse(); o.length && me(o[0][\"char\"]);) {\n    o.shift();\n  }\n  if (o.length < r.backtrackCoverage.length) return [];\n  var l = new re(o, 0),\n    f = fr(r.backtrackCoverage, l),\n    h = a.length === r.inputCoverage.length && u.length === r.lookaheadCoverage.length && f.length === r.backtrackCoverage.length,\n    p = [];\n  if (h) for (var c = 0; c < r.lookupRecords.length; c++) {\n    for (var d = r.lookupRecords[c], x = d.lookupListIndex, m = this.getLookupByIndex(x), y = 0; y < m.subtables.length; y++) {\n      var C = m.subtables[y],\n        S = this.getLookupMethod(m, C),\n        R = this.getSubstitutionType(m, C);\n      if (R === \"12\") for (var O = 0; O < a.length; O++) {\n        var D = e.get(O),\n          L = S(D);\n        L && p.push(L);\n      }\n    }\n  }\n  return p;\n}\nfunction Ii(e, r) {\n  var t = e.current,\n    a = Pe(t, r.coverage);\n  if (a === -1) return null;\n  for (var n, s = r.ligatureSets[a], i = 0; i < s.length; i++) {\n    n = s[i];\n    for (var u = 0; u < n.components.length; u++) {\n      var o = e.lookahead[u],\n        l = n.components[u];\n      if (o !== l) break;\n      if (u === n.components.length - 1) return n;\n    }\n  }\n  return null;\n}\nfunction Mi(e, r) {\n  var t = Pe(e, r.coverage);\n  return t === -1 ? null : r.sequences[t];\n}\nJ.prototype.getDefaultScriptFeaturesIndexes = function () {\n  for (var e = this.font.tables.gsub.scripts, r = 0; r < e.length; r++) {\n    var t = e[r];\n    if (t.tag === \"DFLT\") return t.script.defaultLangSys.featureIndexes;\n  }\n  return [];\n};\nJ.prototype.getScriptFeaturesIndexes = function (e) {\n  var r = this.font.tables;\n  if (!r.gsub) return [];\n  if (!e) return this.getDefaultScriptFeaturesIndexes();\n  for (var t = this.font.tables.gsub.scripts, a = 0; a < t.length; a++) {\n    var n = t[a];\n    if (n.tag === e && n.script.defaultLangSys) return n.script.defaultLangSys.featureIndexes;\n    var s = n.langSysRecords;\n    if (s) for (var i = 0; i < s.length; i++) {\n      var u = s[i];\n      if (u.tag === e) {\n        var o = u.langSys;\n        return o.featureIndexes;\n      }\n    }\n  }\n  return this.getDefaultScriptFeaturesIndexes();\n};\nJ.prototype.mapTagsToFeatures = function (e, r) {\n  for (var t = {}, a = 0; a < e.length; a++) {\n    var n = e[a].tag,\n      s = e[a].feature;\n    t[n] = s;\n  }\n  this.features[r].tags = t;\n};\nJ.prototype.getScriptFeatures = function (e) {\n  var r = this.features[e];\n  if (this.features.hasOwnProperty(e)) return r;\n  var t = this.getScriptFeaturesIndexes(e);\n  if (!t) return null;\n  var a = this.font.tables.gsub;\n  return r = t.map(function (n) {\n    return a.features[n];\n  }), this.features[e] = r, this.mapTagsToFeatures(r, e), r;\n};\nJ.prototype.getSubstitutionType = function (e, r) {\n  var t = e.lookupType.toString(),\n    a = r.substFormat.toString();\n  return t + a;\n};\nJ.prototype.getLookupMethod = function (e, r) {\n  var t = this,\n    a = this.getSubstitutionType(e, r);\n  switch (a) {\n    case \"11\":\n      return function (n) {\n        return Di.apply(t, [n, r]);\n      };\n    case \"12\":\n      return function (n) {\n        return Ai.apply(t, [n, r]);\n      };\n    case \"63\":\n      return function (n) {\n        return Bi.apply(t, [n, r]);\n      };\n    case \"41\":\n      return function (n) {\n        return Ii.apply(t, [n, r]);\n      };\n    case \"21\":\n      return function (n) {\n        return Mi.apply(t, [n, r]);\n      };\n    default:\n      throw new Error(\"lookupType: \" + e.lookupType + \" - substFormat: \" + r.substFormat + \" is not yet supported\");\n  }\n};\nJ.prototype.lookupFeature = function (e) {\n  var r = e.contextParams,\n    t = r.index,\n    a = this.getFeature({\n      tag: e.tag,\n      script: e.script\n    });\n  if (!a) return new Error(\"font '\" + this.font.names.fullName.en + \"' doesn't support feature '\" + e.tag + \"' for script '\" + e.script + \"'.\");\n  for (var n = this.getFeatureLookups(a), s = [].concat(r.context), i = 0; i < n.length; i++) {\n    for (var u = n[i], o = this.getLookupSubtables(u), l = 0; l < o.length; l++) {\n      var f = o[l],\n        h = this.getSubstitutionType(u, f),\n        p = this.getLookupMethod(u, f),\n        c = void 0;\n      switch (h) {\n        case \"11\":\n          c = p(r.current), c && s.splice(t, 1, new be({\n            id: 11,\n            tag: e.tag,\n            substitution: c\n          }));\n          break;\n        case \"12\":\n          c = p(r.current), c && s.splice(t, 1, new be({\n            id: 12,\n            tag: e.tag,\n            substitution: c\n          }));\n          break;\n        case \"63\":\n          c = p(r), Array.isArray(c) && c.length && s.splice(t, 1, new be({\n            id: 63,\n            tag: e.tag,\n            substitution: c\n          }));\n          break;\n        case \"41\":\n          c = p(r), c && s.splice(t, 1, new be({\n            id: 41,\n            tag: e.tag,\n            substitution: c\n          }));\n          break;\n        case \"21\":\n          c = p(r.current), c && s.splice(t, 1, new be({\n            id: 21,\n            tag: e.tag,\n            substitution: c\n          }));\n          break;\n      }\n      r = new re(s, t), !(Array.isArray(c) && !c.length) && (c = null);\n    }\n  }\n  return s.length ? s : null;\n};\nJ.prototype.supports = function (e) {\n  if (!e.script) return !1;\n  this.getScriptFeatures(e.script);\n  var r = this.features.hasOwnProperty(e.script);\n  if (!e.tag) return r;\n  var t = this.features[e.script].some(function (a) {\n    return a.tag === e.tag;\n  });\n  return r && t;\n};\nJ.prototype.getLookupSubtables = function (e) {\n  return e.subtables || null;\n};\nJ.prototype.getLookupByIndex = function (e) {\n  var r = this.font.tables.gsub.lookups;\n  return r[e] || null;\n};\nJ.prototype.getFeatureLookups = function (e) {\n  return e.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\nJ.prototype.getFeature = function (r) {\n  if (!this.font) return {\n    FAIL: \"No font was found\"\n  };\n  this.features.hasOwnProperty(r.script) || this.getScriptFeatures(r.script);\n  var t = this.features[r.script];\n  return t ? t.tags[r.tag] ? this.features[r.script].tags[r.tag] : null : {\n    FAIL: \"No feature for script \" + r.script\n  };\n};\nfunction Pi(e) {\n  var r = e.current,\n    t = e.get(-1);\n  return t === null && ge(r) || !ge(t) && ge(r);\n}\nfunction Gi(e) {\n  var r = e.get(1);\n  return r === null || !ge(r);\n}\nvar Ni = {\n  startCheck: Pi,\n  endCheck: Gi\n};\nfunction Hi(e) {\n  var r = e.current,\n    t = e.get(-1);\n  return (ge(r) || me(r)) && !ge(t);\n}\nfunction zi(e) {\n  var r = e.get(1);\n  switch (!0) {\n    case r === null:\n      return !0;\n    case !ge(r) && !me(r):\n      var t = wi(r);\n      if (!t) return !0;\n      if (t) {\n        var a = !1;\n        if (a = e.lookahead.some(function (n) {\n          return ge(n) || me(n);\n        }), !a) return !0;\n      }\n      break;\n    default:\n      return !1;\n  }\n}\nvar Wi = {\n  startCheck: Hi,\n  endCheck: zi\n};\nfunction _i(e, r, t) {\n  r[t].setState(e.tag, e.substitution);\n}\nfunction Vi(e, r, t) {\n  r[t].setState(e.tag, e.substitution);\n}\nfunction qi(e, r, t) {\n  e.substitution.forEach(function (a, n) {\n    var s = r[t + n];\n    s.setState(e.tag, a);\n  });\n}\nfunction Xi(e, r, t) {\n  var a = r[t];\n  a.setState(e.tag, e.substitution.ligGlyph);\n  for (var n = e.substitution.components.length, s = 0; s < n; s++) {\n    a = r[t + s + 1], a.setState(\"deleted\", !0);\n  }\n}\nvar dt = {\n  11: _i,\n  12: Vi,\n  63: qi,\n  41: Xi\n};\nfunction Rr(e, r, t) {\n  e instanceof be && dt[e.id] && dt[e.id](e, r, t);\n}\nfunction Yi(e) {\n  for (var r = [].concat(e.backtrack), t = r.length - 1; t >= 0; t--) {\n    var a = r[t],\n      n = fa(a),\n      s = me(a);\n    if (!n && !s) return !0;\n    if (n) return !1;\n  }\n  return !1;\n}\nfunction Zi(e) {\n  if (fa(e.current)) return !1;\n  for (var r = 0; r < e.lookahead.length; r++) {\n    var t = e.lookahead[r],\n      a = me(t);\n    if (!a) return !0;\n  }\n  return !1;\n}\nfunction Qi(e) {\n  var r = this,\n    t = \"arab\",\n    a = this.featuresTags[t],\n    n = this.tokenizer.getRangeTokens(e);\n  if (n.length !== 1) {\n    var s = new re(n.map(function (u) {\n        return u.getState(\"glyphIndex\");\n      }), 0),\n      i = new re(n.map(function (u) {\n        return u[\"char\"];\n      }), 0);\n    n.forEach(function (u, o) {\n      if (!me(u[\"char\"])) {\n        s.setCurrentIndex(o), i.setCurrentIndex(o);\n        var l = 0;\n        Yi(i) && (l |= 1), Zi(i) && (l |= 2);\n        var f;\n        switch (l) {\n          case 1:\n            f = \"fina\";\n            break;\n          case 2:\n            f = \"init\";\n            break;\n          case 3:\n            f = \"medi\";\n            break;\n        }\n        if (a.indexOf(f) !== -1) {\n          var h = r.query.lookupFeature({\n            tag: f,\n            script: t,\n            contextParams: s\n          });\n          if (h instanceof Error) return console.info(h.message);\n          h.forEach(function (p, c) {\n            p instanceof be && (Rr(p, n, c), s.context[c] = p.substitution);\n          });\n        }\n      }\n    });\n  }\n}\nfunction gt(e, r) {\n  var t = e.map(function (a) {\n    return a.activeState.value;\n  });\n  return new re(t, r || 0);\n}\nfunction Ki(e) {\n  var r = this,\n    t = \"arab\",\n    a = this.tokenizer.getRangeTokens(e),\n    n = gt(a);\n  n.context.forEach(function (s, i) {\n    n.setCurrentIndex(i);\n    var u = r.query.lookupFeature({\n      tag: \"rlig\",\n      script: t,\n      contextParams: n\n    });\n    u.length && (u.forEach(function (o) {\n      return Rr(o, a, i);\n    }), n = gt(a));\n  });\n}\nfunction Ji(e) {\n  var r = e.current,\n    t = e.get(-1);\n  return t === null && Xe(r) || !Xe(t) && Xe(r);\n}\nfunction ji(e) {\n  var r = e.get(1);\n  return r === null || !Xe(r);\n}\nvar $i = {\n  startCheck: Ji,\n  endCheck: ji\n};\nfunction mt(e, r) {\n  var t = e.map(function (a) {\n    return a.activeState.value;\n  });\n  return new re(t, r || 0);\n}\nfunction eo(e) {\n  var r = this,\n    t = \"latn\",\n    a = this.tokenizer.getRangeTokens(e),\n    n = mt(a);\n  n.context.forEach(function (s, i) {\n    n.setCurrentIndex(i);\n    var u = r.query.lookupFeature({\n      tag: \"liga\",\n      script: t,\n      contextParams: n\n    });\n    u.length && (u.forEach(function (o) {\n      return Rr(o, a, i);\n    }), n = mt(a));\n  });\n}\nfunction ne(e) {\n  this.baseDir = e || \"ltr\", this.tokenizer = new B(), this.featuresTags = {};\n}\nne.prototype.setText = function (e) {\n  this.text = e;\n};\nne.prototype.contextChecks = {\n  latinWordCheck: $i,\n  arabicWordCheck: Ni,\n  arabicSentenceCheck: Wi\n};\nfunction pr(e) {\n  var r = this.contextChecks[e + \"Check\"];\n  return this.tokenizer.registerContextChecker(e, r.startCheck, r.endCheck);\n}\nfunction ro() {\n  return pr.call(this, \"latinWord\"), pr.call(this, \"arabicWord\"), pr.call(this, \"arabicSentence\"), this.tokenizer.tokenize(this.text);\n}\nfunction to() {\n  var e = this,\n    r = this.tokenizer.getContextRanges(\"arabicSentence\");\n  r.forEach(function (t) {\n    var a = e.tokenizer.getRangeTokens(t);\n    e.tokenizer.replaceRange(t.startIndex, t.endOffset, a.reverse());\n  });\n}\nne.prototype.registerFeatures = function (e, r) {\n  var t = this,\n    a = r.filter(function (n) {\n      return t.query.supports({\n        script: e,\n        tag: n\n      });\n    });\n  this.featuresTags.hasOwnProperty(e) ? this.featuresTags[e] = this.featuresTags[e].concat(a) : this.featuresTags[e] = a;\n};\nne.prototype.applyFeatures = function (e, r) {\n  if (!e) throw new Error(\"No valid font was provided to apply features\");\n  this.query || (this.query = new J(e));\n  for (var t = 0; t < r.length; t++) {\n    var a = r[t];\n    !this.query.supports({\n      script: a.script\n    }) || this.registerFeatures(a.script, a.tags);\n  }\n};\nne.prototype.registerModifier = function (e, r, t) {\n  this.tokenizer.registerModifier(e, r, t);\n};\nfunction wr() {\n  if (this.tokenizer.registeredModifiers.indexOf(\"glyphIndex\") === -1) throw new Error(\"glyphIndex modifier is required to apply arabic presentation features.\");\n}\nfunction ao() {\n  var e = this,\n    r = \"arab\";\n  if (!!this.featuresTags.hasOwnProperty(r)) {\n    wr.call(this);\n    var t = this.tokenizer.getContextRanges(\"arabicWord\");\n    t.forEach(function (a) {\n      Qi.call(e, a);\n    });\n  }\n}\nfunction no() {\n  var e = this,\n    r = \"arab\";\n  if (!!this.featuresTags.hasOwnProperty(r)) {\n    var t = this.featuresTags[r];\n    if (t.indexOf(\"rlig\") !== -1) {\n      wr.call(this);\n      var a = this.tokenizer.getContextRanges(\"arabicWord\");\n      a.forEach(function (n) {\n        Ki.call(e, n);\n      });\n    }\n  }\n}\nfunction so() {\n  var e = this,\n    r = \"latn\";\n  if (!!this.featuresTags.hasOwnProperty(r)) {\n    var t = this.featuresTags[r];\n    if (t.indexOf(\"liga\") !== -1) {\n      wr.call(this);\n      var a = this.tokenizer.getContextRanges(\"latinWord\");\n      a.forEach(function (n) {\n        eo.call(e, n);\n      });\n    }\n  }\n}\nne.prototype.checkContextReady = function (e) {\n  return !!this.tokenizer.getContext(e);\n};\nne.prototype.applyFeaturesToContexts = function () {\n  this.checkContextReady(\"arabicWord\") && (ao.call(this), no.call(this)), this.checkContextReady(\"latinWord\") && so.call(this), this.checkContextReady(\"arabicSentence\") && to.call(this);\n};\nne.prototype.processText = function (e) {\n  (!this.text || this.text !== e) && (this.setText(e), ro.call(this), this.applyFeaturesToContexts());\n};\nne.prototype.getBidiText = function (e) {\n  return this.processText(e), this.tokenizer.getText();\n};\nne.prototype.getTextGlyphs = function (e) {\n  this.processText(e);\n  for (var r = [], t = 0; t < this.tokenizer.tokens.length; t++) {\n    var a = this.tokenizer.tokens[t];\n    if (!a.state.deleted) {\n      var n = a.activeState.value;\n      r.push(Array.isArray(n) ? n[0] : n);\n    }\n  }\n  return r;\n};\nfunction w(e) {\n  e = e || {}, e.tables = e.tables || {}, e.empty || (Ee(e.familyName, \"When creating a new Font object, familyName is required.\"), Ee(e.styleName, \"When creating a new Font object, styleName is required.\"), Ee(e.unitsPerEm, \"When creating a new Font object, unitsPerEm is required.\"), Ee(e.ascender, \"When creating a new Font object, ascender is required.\"), Ee(e.descender <= 0, \"When creating a new Font object, negative descender value is required.\"), this.names = {\n    fontFamily: {\n      en: e.familyName || \" \"\n    },\n    fontSubfamily: {\n      en: e.styleName || \" \"\n    },\n    fullName: {\n      en: e.fullName || e.familyName + \" \" + e.styleName\n    },\n    postScriptName: {\n      en: e.postScriptName || (e.familyName + e.styleName).replace(/\\s/g, \"\")\n    },\n    designer: {\n      en: e.designer || \" \"\n    },\n    designerURL: {\n      en: e.designerURL || \" \"\n    },\n    manufacturer: {\n      en: e.manufacturer || \" \"\n    },\n    manufacturerURL: {\n      en: e.manufacturerURL || \" \"\n    },\n    license: {\n      en: e.license || \" \"\n    },\n    licenseURL: {\n      en: e.licenseURL || \" \"\n    },\n    version: {\n      en: e.version || \"Version 0.1\"\n    },\n    description: {\n      en: e.description || \" \"\n    },\n    copyright: {\n      en: e.copyright || \" \"\n    },\n    trademark: {\n      en: e.trademark || \" \"\n    }\n  }, this.unitsPerEm = e.unitsPerEm || 1e3, this.ascender = e.ascender, this.descender = e.descender, this.createdTimestamp = e.createdTimestamp, this.tables = Object.assign(e.tables, {\n    os2: Object.assign({\n      usWeightClass: e.weightClass || this.usWeightClasses.MEDIUM,\n      usWidthClass: e.widthClass || this.usWidthClasses.MEDIUM,\n      fsSelection: e.fsSelection || this.fsSelectionValues.REGULAR\n    }, e.tables.os2)\n  })), this.supported = !0, this.glyphs = new ue.GlyphSet(this, e.glyphs || []), this.encoding = new Ot(this), this.position = new Be(this), this.substitution = new K(this), this.tables = this.tables || {}, this._push = null, this._hmtxTableData = {}, Object.defineProperty(this, \"hinting\", {\n    get: function get() {\n      if (this._hinting) return this._hinting;\n      if (this.outlinesFormat === \"truetype\") return this._hinting = new ia(this);\n    }\n  });\n}\nw.prototype.hasChar = function (e) {\n  return this.encoding.charToGlyphIndex(e) !== null;\n};\nw.prototype.charToGlyphIndex = function (e) {\n  return this.encoding.charToGlyphIndex(e);\n};\nw.prototype.charToGlyph = function (e) {\n  var r = this.charToGlyphIndex(e),\n    t = this.glyphs.get(r);\n  return t || (t = this.glyphs.get(0)), t;\n};\nw.prototype.updateFeatures = function (e) {\n  return this.defaultRenderOptions.features.map(function (r) {\n    return r.script === \"latn\" ? {\n      script: \"latn\",\n      tags: r.tags.filter(function (t) {\n        return e[t];\n      })\n    } : r;\n  });\n};\nw.prototype.stringToGlyphs = function (e, r) {\n  var t = this,\n    a = new ne(),\n    n = function n(h) {\n      return t.charToGlyphIndex(h[\"char\"]);\n    };\n  a.registerModifier(\"glyphIndex\", null, n);\n  var s = r ? this.updateFeatures(r.features) : this.defaultRenderOptions.features;\n  a.applyFeatures(this, s);\n  for (var i = a.getTextGlyphs(e), u = i.length, o = new Array(u), l = this.glyphs.get(0), f = 0; f < u; f += 1) {\n    o[f] = this.glyphs.get(i[f]) || l;\n  }\n  return o;\n};\nw.prototype.nameToGlyphIndex = function (e) {\n  return this.glyphNames.nameToGlyphIndex(e);\n};\nw.prototype.nameToGlyph = function (e) {\n  var r = this.nameToGlyphIndex(e),\n    t = this.glyphs.get(r);\n  return t || (t = this.glyphs.get(0)), t;\n};\nw.prototype.glyphIndexToName = function (e) {\n  return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e) : \"\";\n};\nw.prototype.getKerningValue = function (e, r) {\n  e = e.index || e, r = r.index || r;\n  var t = this.position.defaultKerningTables;\n  return t ? this.position.getKerningValue(t, e, r) : this.kerningPairs[e + \",\" + r] || 0;\n};\nw.prototype.defaultRenderOptions = {\n  kerning: !0,\n  features: [{\n    script: \"arab\",\n    tags: [\"init\", \"medi\", \"fina\", \"rlig\"]\n  }, {\n    script: \"latn\",\n    tags: [\"liga\", \"rlig\"]\n  }]\n};\nw.prototype.forEachGlyph = function (e, r, t, a, n, s) {\n  r = r !== void 0 ? r : 0, t = t !== void 0 ? t : 0, a = a !== void 0 ? a : 72, n = Object.assign({}, this.defaultRenderOptions, n);\n  var i = 1 / this.unitsPerEm * a,\n    u = this.stringToGlyphs(e, n),\n    o;\n  if (n.kerning) {\n    var l = n.script || this.position.getDefaultScriptName();\n    o = this.position.getKerningTables(l, n.language);\n  }\n  for (var f = 0; f < u.length; f += 1) {\n    var h = u[f];\n    if (s.call(this, h, r, t, a, n), h.advanceWidth && (r += h.advanceWidth * i), n.kerning && f < u.length - 1) {\n      var p = o ? this.position.getKerningValue(o, h.index, u[f + 1].index) : this.getKerningValue(h, u[f + 1]);\n      r += p * i;\n    }\n    n.letterSpacing ? r += n.letterSpacing * a : n.tracking && (r += n.tracking / 1e3 * a);\n  }\n  return r;\n};\nw.prototype.getPath = function (e, r, t, a, n) {\n  var s = new P();\n  return this.forEachGlyph(e, r, t, a, n, function (i, u, o, l) {\n    var f = i.getPath(u, o, l, n, this);\n    s.extend(f);\n  }), s;\n};\nw.prototype.getPaths = function (e, r, t, a, n) {\n  var s = [];\n  return this.forEachGlyph(e, r, t, a, n, function (i, u, o, l) {\n    var f = i.getPath(u, o, l, n, this);\n    s.push(f);\n  }), s;\n};\nw.prototype.getAdvanceWidth = function (e, r, t) {\n  return this.forEachGlyph(e, 0, 0, r, t, function () {});\n};\nw.prototype.draw = function (e, r, t, a, n, s) {\n  this.getPath(r, t, a, n, s).draw(e);\n};\nw.prototype.drawPoints = function (e, r, t, a, n, s) {\n  this.forEachGlyph(r, t, a, n, s, function (i, u, o, l) {\n    i.drawPoints(e, u, o, l);\n  });\n};\nw.prototype.drawMetrics = function (e, r, t, a, n, s) {\n  this.forEachGlyph(r, t, a, n, s, function (i, u, o, l) {\n    i.drawMetrics(e, u, o, l);\n  });\n};\nw.prototype.getEnglishName = function (e) {\n  var r = this.names[e];\n  if (r) return r.en;\n};\nw.prototype.validate = function () {\n  var e = this;\n  function r(a, n) {}\n  function t(a) {\n    var n = e.getEnglishName(a);\n    n && n.trim().length > 0;\n  }\n  t(\"fontFamily\"), t(\"weightName\"), t(\"manufacturer\"), t(\"copyright\"), t(\"version\"), this.unitsPerEm > 0;\n};\nw.prototype.toTables = function () {\n  return Xn.fontToTable(this);\n};\nw.prototype.toBuffer = function () {\n  return console.warn(\"Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\"), this.toArrayBuffer();\n};\nw.prototype.toArrayBuffer = function () {\n  for (var e = this.toTables(), r = e.encode(), t = new ArrayBuffer(r.length), a = new Uint8Array(t), n = 0; n < r.length; n++) {\n    a[n] = r[n];\n  }\n  return t;\n};\nw.prototype.download = function (e) {\n  var r = this.getEnglishName(\"fontFamily\"),\n    t = this.getEnglishName(\"fontSubfamily\");\n  e = e || r.replace(/\\s/g, \"\") + \"-\" + t + \".otf\";\n  var a = this.toArrayBuffer();\n  if (Zn()) {\n    if (window.URL = window.URL || window.webkitURL, window.URL) {\n      var n = new DataView(a),\n        s = new Blob([n], {\n          type: \"font/opentype\"\n        }),\n        i = document.createElement(\"a\");\n      i.href = window.URL.createObjectURL(s), i.download = e;\n      var u = document.createEvent(\"MouseEvents\");\n      u.initEvent(\"click\", !0, !1), i.dispatchEvent(u);\n    } else console.warn(\"Font file could not be downloaded. Try using a different browser.\");\n  } else {\n    var o = Ne(),\n      l = Qn(a);\n    o.writeFileSync(e, l);\n  }\n};\nw.prototype.fsSelectionValues = {\n  ITALIC: 1,\n  UNDERSCORE: 2,\n  NEGATIVE: 4,\n  OUTLINED: 8,\n  STRIKEOUT: 16,\n  BOLD: 32,\n  REGULAR: 64,\n  USER_TYPO_METRICS: 128,\n  WWS: 256,\n  OBLIQUE: 512\n};\nw.prototype.usWidthClasses = {\n  ULTRA_CONDENSED: 1,\n  EXTRA_CONDENSED: 2,\n  CONDENSED: 3,\n  SEMI_CONDENSED: 4,\n  MEDIUM: 5,\n  SEMI_EXPANDED: 6,\n  EXPANDED: 7,\n  EXTRA_EXPANDED: 8,\n  ULTRA_EXPANDED: 9\n};\nw.prototype.usWeightClasses = {\n  THIN: 100,\n  EXTRA_LIGHT: 200,\n  LIGHT: 300,\n  NORMAL: 400,\n  MEDIUM: 500,\n  SEMI_BOLD: 600,\n  BOLD: 700,\n  EXTRA_BOLD: 800,\n  BLACK: 900\n};\nfunction pa(e, r) {\n  var t = JSON.stringify(e),\n    a = 256;\n  for (var n in r) {\n    var s = parseInt(n);\n    if (!(!s || s < 256)) {\n      if (JSON.stringify(r[n]) === t) return s;\n      a <= s && (a = s + 1);\n    }\n  }\n  return r[a] = e, a;\n}\nfunction io(e, r, t) {\n  var a = pa(r.name, t);\n  return [{\n    name: \"tag_\" + e,\n    type: \"TAG\",\n    value: r.tag\n  }, {\n    name: \"minValue_\" + e,\n    type: \"FIXED\",\n    value: r.minValue << 16\n  }, {\n    name: \"defaultValue_\" + e,\n    type: \"FIXED\",\n    value: r.defaultValue << 16\n  }, {\n    name: \"maxValue_\" + e,\n    type: \"FIXED\",\n    value: r.maxValue << 16\n  }, {\n    name: \"flags_\" + e,\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"nameID_\" + e,\n    type: \"USHORT\",\n    value: a\n  }];\n}\nfunction oo(e, r, t) {\n  var a = {},\n    n = new k.Parser(e, r);\n  return a.tag = n.parseTag(), a.minValue = n.parseFixed(), a.defaultValue = n.parseFixed(), a.maxValue = n.parseFixed(), n.skip(\"uShort\", 1), a.name = t[n.parseUShort()] || {}, a;\n}\nfunction uo(e, r, t, a) {\n  for (var n = pa(r.name, a), s = [{\n      name: \"nameID_\" + e,\n      type: \"USHORT\",\n      value: n\n    }, {\n      name: \"flags_\" + e,\n      type: \"USHORT\",\n      value: 0\n    }], i = 0; i < t.length; ++i) {\n    var u = t[i].tag;\n    s.push({\n      name: \"axis_\" + e + \" \" + u,\n      type: \"FIXED\",\n      value: r.coordinates[u] << 16\n    });\n  }\n  return s;\n}\nfunction lo(e, r, t, a) {\n  var n = {},\n    s = new k.Parser(e, r);\n  n.name = a[s.parseUShort()] || {}, s.skip(\"uShort\", 1), n.coordinates = {};\n  for (var i = 0; i < t.length; ++i) {\n    n.coordinates[t[i].tag] = s.parseFixed();\n  }\n  return n;\n}\nfunction fo(e, r) {\n  var t = new b.Table(\"fvar\", [{\n    name: \"version\",\n    type: \"ULONG\",\n    value: 65536\n  }, {\n    name: \"offsetToData\",\n    type: \"USHORT\",\n    value: 0\n  }, {\n    name: \"countSizePairs\",\n    type: \"USHORT\",\n    value: 2\n  }, {\n    name: \"axisCount\",\n    type: \"USHORT\",\n    value: e.axes.length\n  }, {\n    name: \"axisSize\",\n    type: \"USHORT\",\n    value: 20\n  }, {\n    name: \"instanceCount\",\n    type: \"USHORT\",\n    value: e.instances.length\n  }, {\n    name: \"instanceSize\",\n    type: \"USHORT\",\n    value: 4 + e.axes.length * 4\n  }]);\n  t.offsetToData = t.sizeOf();\n  for (var a = 0; a < e.axes.length; a++) {\n    t.fields = t.fields.concat(io(a, e.axes[a], r));\n  }\n  for (var n = 0; n < e.instances.length; n++) {\n    t.fields = t.fields.concat(uo(n, e.instances[n], e.axes, r));\n  }\n  return t;\n}\nfunction po(e, r, t) {\n  var a = new k.Parser(e, r),\n    n = a.parseULong();\n  U.argument(n === 65536, \"Unsupported fvar table version.\");\n  var s = a.parseOffset16();\n  a.skip(\"uShort\", 1);\n  for (var i = a.parseUShort(), u = a.parseUShort(), o = a.parseUShort(), l = a.parseUShort(), f = [], h = 0; h < i; h++) {\n    f.push(oo(e, r + s + h * u, t));\n  }\n  for (var p = [], c = r + s + i * u, d = 0; d < o; d++) {\n    p.push(lo(e, c + d * l, f, t));\n  }\n  return {\n    axes: f,\n    instances: p\n  };\n}\nvar ho = {\n    make: fo,\n    parse: po\n  },\n  co = function co() {\n    return {\n      coverage: this.parsePointer(v.coverage),\n      attachPoints: this.parseList(v.pointer(v.uShortList))\n    };\n  },\n  vo = function vo() {\n    var e = this.parseUShort();\n    if (U.argument(e === 1 || e === 2 || e === 3, \"Unsupported CaretValue table version.\"), e === 1) return {\n      coordinate: this.parseShort()\n    };\n    if (e === 2) return {\n      pointindex: this.parseShort()\n    };\n    if (e === 3) return {\n      coordinate: this.parseShort()\n    };\n  },\n  go = function go() {\n    return this.parseList(v.pointer(vo));\n  },\n  mo = function mo() {\n    return {\n      coverage: this.parsePointer(v.coverage),\n      ligGlyphs: this.parseList(v.pointer(go))\n    };\n  },\n  yo = function yo() {\n    return this.parseUShort(), this.parseList(v.pointer(v.coverage));\n  };\nfunction xo(e, r) {\n  r = r || 0;\n  var t = new v(e, r),\n    a = t.parseVersion(1);\n  U.argument(a === 1 || a === 1.2 || a === 1.3, \"Unsupported GDEF table version.\");\n  var n = {\n    version: a,\n    classDef: t.parsePointer(v.classDef),\n    attachList: t.parsePointer(co),\n    ligCaretList: t.parsePointer(mo),\n    markAttachClassDef: t.parsePointer(v.classDef)\n  };\n  return a >= 1.2 && (n.markGlyphSets = t.parsePointer(yo)), n;\n}\nvar bo = {\n    parse: xo\n  },\n  te = new Array(10);\nte[1] = function () {\n  var r = this.offset + this.relativeOffset,\n    t = this.parseUShort();\n  if (t === 1) return {\n    posFormat: 1,\n    coverage: this.parsePointer(v.coverage),\n    value: this.parseValueRecord()\n  };\n  if (t === 2) return {\n    posFormat: 2,\n    coverage: this.parsePointer(v.coverage),\n    values: this.parseValueRecordList()\n  };\n  U.assert(!1, \"0x\" + r.toString(16) + \": GPOS lookup type 1 format must be 1 or 2.\");\n};\nte[2] = function () {\n  var r = this.offset + this.relativeOffset,\n    t = this.parseUShort();\n  U.assert(t === 1 || t === 2, \"0x\" + r.toString(16) + \": GPOS lookup type 2 format must be 1 or 2.\");\n  var a = this.parsePointer(v.coverage),\n    n = this.parseUShort(),\n    s = this.parseUShort();\n  if (t === 1) return {\n    posFormat: t,\n    coverage: a,\n    valueFormat1: n,\n    valueFormat2: s,\n    pairSets: this.parseList(v.pointer(v.list(function () {\n      return {\n        secondGlyph: this.parseUShort(),\n        value1: this.parseValueRecord(n),\n        value2: this.parseValueRecord(s)\n      };\n    })))\n  };\n  if (t === 2) {\n    var i = this.parsePointer(v.classDef),\n      u = this.parsePointer(v.classDef),\n      o = this.parseUShort(),\n      l = this.parseUShort();\n    return {\n      posFormat: t,\n      coverage: a,\n      valueFormat1: n,\n      valueFormat2: s,\n      classDef1: i,\n      classDef2: u,\n      class1Count: o,\n      class2Count: l,\n      classRecords: this.parseList(o, v.list(l, function () {\n        return {\n          value1: this.parseValueRecord(n),\n          value2: this.parseValueRecord(s)\n        };\n      }))\n    };\n  }\n};\nte[3] = function () {\n  return {\n    error: \"GPOS Lookup 3 not supported\"\n  };\n};\nte[4] = function () {\n  return {\n    error: \"GPOS Lookup 4 not supported\"\n  };\n};\nte[5] = function () {\n  return {\n    error: \"GPOS Lookup 5 not supported\"\n  };\n};\nte[6] = function () {\n  return {\n    error: \"GPOS Lookup 6 not supported\"\n  };\n};\nte[7] = function () {\n  return {\n    error: \"GPOS Lookup 7 not supported\"\n  };\n};\nte[8] = function () {\n  return {\n    error: \"GPOS Lookup 8 not supported\"\n  };\n};\nte[9] = function () {\n  return {\n    error: \"GPOS Lookup 9 not supported\"\n  };\n};\nfunction So(e, r) {\n  r = r || 0;\n  var t = new v(e, r),\n    a = t.parseVersion(1);\n  return U.argument(a === 1 || a === 1.1, \"Unsupported GPOS table version \" + a), a === 1 ? {\n    version: a,\n    scripts: t.parseScriptList(),\n    features: t.parseFeatureList(),\n    lookups: t.parseLookupList(te)\n  } : {\n    version: a,\n    scripts: t.parseScriptList(),\n    features: t.parseFeatureList(),\n    lookups: t.parseLookupList(te),\n    variations: t.parseFeatureVariationsList()\n  };\n}\nvar To = new Array(10);\nfunction ko(e) {\n  return new b.Table(\"GPOS\", [{\n    name: \"version\",\n    type: \"ULONG\",\n    value: 65536\n  }, {\n    name: \"scripts\",\n    type: \"TABLE\",\n    value: new b.ScriptList(e.scripts)\n  }, {\n    name: \"features\",\n    type: \"TABLE\",\n    value: new b.FeatureList(e.features)\n  }, {\n    name: \"lookups\",\n    type: \"TABLE\",\n    value: new b.LookupList(e.lookups, To)\n  }]);\n}\nvar Fo = {\n  parse: So,\n  make: ko\n};\nfunction Uo(e) {\n  var r = {};\n  e.skip(\"uShort\");\n  var t = e.parseUShort();\n  U.argument(t === 0, \"Unsupported kern sub-table version.\"), e.skip(\"uShort\", 2);\n  var a = e.parseUShort();\n  e.skip(\"uShort\", 3);\n  for (var n = 0; n < a; n += 1) {\n    var s = e.parseUShort(),\n      i = e.parseUShort(),\n      u = e.parseShort();\n    r[s + \",\" + i] = u;\n  }\n  return r;\n}\nfunction Co(e) {\n  var r = {};\n  e.skip(\"uShort\");\n  var t = e.parseULong();\n  t > 1 && console.warn(\"Only the first kern subtable is supported.\"), e.skip(\"uLong\");\n  var a = e.parseUShort(),\n    n = a & 255;\n  if (e.skip(\"uShort\"), n === 0) {\n    var s = e.parseUShort();\n    e.skip(\"uShort\", 3);\n    for (var i = 0; i < s; i += 1) {\n      var u = e.parseUShort(),\n        o = e.parseUShort(),\n        l = e.parseShort();\n      r[u + \",\" + o] = l;\n    }\n  }\n  return r;\n}\nfunction Eo(e, r) {\n  var t = new k.Parser(e, r),\n    a = t.parseUShort();\n  if (a === 0) return Uo(t);\n  if (a === 1) return Co(t);\n  throw new Error(\"Unsupported kern table version (\" + a + \").\");\n}\nvar Oo = {\n  parse: Eo\n};\nfunction Lo(e, r, t, a) {\n  for (var n = new k.Parser(e, r), s = a ? n.parseUShort : n.parseULong, i = [], u = 0; u < t + 1; u += 1) {\n    var o = s.call(n);\n    a && (o *= 2), i.push(o);\n  }\n  return i;\n}\nvar Ro = {\n  parse: Lo\n};\nfunction wo(e, r) {\n  var t = Ne();\n  t.readFile(e, function (a, n) {\n    if (a) return r(a.message);\n    r(null, $t(n));\n  });\n}\nfunction Do(e, r) {\n  var t = new XMLHttpRequest();\n  t.open(\"get\", e, !0), t.responseType = \"arraybuffer\", t.onload = function () {\n    return t.response ? r(null, t.response) : r(\"Font could not be loaded: \" + t.statusText);\n  }, t.onerror = function () {\n    r(\"Font could not be loaded\");\n  }, t.send();\n}\nfunction yt(e, r) {\n  for (var t = [], a = 12, n = 0; n < r; n += 1) {\n    var s = k.getTag(e, a),\n      i = k.getULong(e, a + 4),\n      u = k.getULong(e, a + 8),\n      o = k.getULong(e, a + 12);\n    t.push({\n      tag: s,\n      checksum: i,\n      offset: u,\n      length: o,\n      compression: !1\n    }), a += 16;\n  }\n  return t;\n}\nfunction Ao(e, r) {\n  for (var t = [], a = 44, n = 0; n < r; n += 1) {\n    var s = k.getTag(e, a),\n      i = k.getULong(e, a + 4),\n      u = k.getULong(e, a + 8),\n      o = k.getULong(e, a + 12),\n      l = void 0;\n    u < o ? l = \"WOFF\" : l = !1, t.push({\n      tag: s,\n      offset: i,\n      compression: l,\n      compressedLength: u,\n      length: o\n    }), a += 20;\n  }\n  return t;\n}\nfunction I(e, r) {\n  if (r.compression === \"WOFF\") {\n    var t = new Uint8Array(e.buffer, r.offset + 2, r.compressedLength - 2),\n      a = new Uint8Array(r.length);\n    if (Ta(t, a), a.byteLength !== r.length) throw new Error(\"Decompression error: \" + r.tag + \" decompressed length doesn't match recorded length\");\n    var n = new DataView(a.buffer, 0);\n    return {\n      data: n,\n      offset: 0\n    };\n  } else return {\n    data: e,\n    offset: r.offset\n  };\n}\nfunction Dr(e, r) {\n  var _r2;\n  r = (_r2 = r) !== null && _r2 !== void 0 ? _r2 : {};\n  var t,\n    a,\n    n = new w({\n      empty: !0\n    }),\n    s = new DataView(e, 0),\n    i,\n    u = [],\n    o = k.getTag(s, 0);\n  if (o === String.fromCharCode(0, 1, 0, 0) || o === \"true\" || o === \"typ1\") n.outlinesFormat = \"truetype\", i = k.getUShort(s, 4), u = yt(s, i);else if (o === \"OTTO\") n.outlinesFormat = \"cff\", i = k.getUShort(s, 4), u = yt(s, i);else if (o === \"wOFF\") {\n    var l = k.getTag(s, 4);\n    if (l === String.fromCharCode(0, 1, 0, 0)) n.outlinesFormat = \"truetype\";else if (l === \"OTTO\") n.outlinesFormat = \"cff\";else throw new Error(\"Unsupported OpenType flavor \" + o);\n    i = k.getUShort(s, 12), u = Ao(s, i);\n  } else throw new Error(\"Unsupported OpenType signature \" + o);\n  for (var f, h, p, c, d, x, m, y, C, S, R, O, D = 0; D < i; D += 1) {\n    var L = u[D],\n      F = void 0;\n    switch (L.tag) {\n      case \"cmap\":\n        F = I(s, L), n.tables.cmap = Et.parse(F.data, F.offset), n.encoding = new Lt(n.tables.cmap);\n        break;\n      case \"cvt \":\n        F = I(s, L), O = new k.Parser(F.data, F.offset), n.tables.cvt = O.parseShortList(L.length / 2);\n        break;\n      case \"fvar\":\n        h = L;\n        break;\n      case \"fpgm\":\n        F = I(s, L), O = new k.Parser(F.data, F.offset), n.tables.fpgm = O.parseByteList(L.length);\n        break;\n      case \"head\":\n        F = I(s, L), n.tables.head = Nt.parse(F.data, F.offset), n.unitsPerEm = n.tables.head.unitsPerEm, t = n.tables.head.indexToLocFormat;\n        break;\n      case \"hhea\":\n        F = I(s, L), n.tables.hhea = Ht.parse(F.data, F.offset), n.ascender = n.tables.hhea.ascender, n.descender = n.tables.hhea.descender, n.numberOfHMetrics = n.tables.hhea.numberOfHMetrics;\n        break;\n      case \"hmtx\":\n        m = L;\n        break;\n      case \"ltag\":\n        F = I(s, L), a = Wt.parse(F.data, F.offset);\n        break;\n      case \"maxp\":\n        F = I(s, L), n.tables.maxp = _t.parse(F.data, F.offset), n.numGlyphs = n.tables.maxp.numGlyphs;\n        break;\n      case \"name\":\n        S = L;\n        break;\n      case \"OS/2\":\n        F = I(s, L), n.tables.os2 = xr.parse(F.data, F.offset);\n        break;\n      case \"post\":\n        F = I(s, L), n.tables.post = Qt.parse(F.data, F.offset), n.glyphNames = new Ur(n.tables.post);\n        break;\n      case \"prep\":\n        F = I(s, L), O = new k.Parser(F.data, F.offset), n.tables.prep = O.parseByteList(L.length);\n        break;\n      case \"glyf\":\n        p = L;\n        break;\n      case \"loca\":\n        C = L;\n        break;\n      case \"CFF \":\n        f = L;\n        break;\n      case \"kern\":\n        y = L;\n        break;\n      case \"GDEF\":\n        c = L;\n        break;\n      case \"GPOS\":\n        d = L;\n        break;\n      case \"GSUB\":\n        x = L;\n        break;\n      case \"meta\":\n        R = L;\n        break;\n    }\n  }\n  var G = I(s, S);\n  if (n.tables.name = Zt.parse(G.data, G.offset, a), n.names = n.tables.name, p && C) {\n    var Y = t === 0,\n      Z = I(s, C),\n      j = Ro.parse(Z.data, Z.offset, n.numGlyphs, Y),\n      $ = I(s, p);\n    n.glyphs = aa.parse($.data, $.offset, j, n, r);\n  } else if (f) {\n    var M = I(s, f);\n    Gt.parse(M.data, M.offset, n, r);\n  } else throw new Error(\"Font doesn't contain TrueType or CFF outlines.\");\n  var N = I(s, m);\n  if (zt.parse(n, N.data, N.offset, n.numberOfHMetrics, n.numGlyphs, n.glyphs, r), _a(n, r), y) {\n    var W = I(s, y);\n    n.kerningPairs = Oo.parse(W.data, W.offset);\n  } else n.kerningPairs = {};\n  if (c) {\n    var _ = I(s, c);\n    n.tables.gdef = bo.parse(_.data, _.offset);\n  }\n  if (d) {\n    var V = I(s, d);\n    n.tables.gpos = Fo.parse(V.data, V.offset), n.position.init();\n  }\n  if (x) {\n    var H = I(s, x);\n    n.tables.gsub = Kt.parse(H.data, H.offset);\n  }\n  if (h) {\n    var X = I(s, h);\n    n.tables.fvar = ho.parse(X.data, X.offset, n.names);\n  }\n  if (R) {\n    var A = I(s, R);\n    n.tables.meta = Jt.parse(A.data, A.offset), n.metas = n.tables.meta;\n  }\n  return n;\n}\nfunction Bo(e, r, t) {\n  var _t2;\n  t = (_t2 = t) !== null && _t2 !== void 0 ? _t2 : {};\n  var a = typeof window > \"u\",\n    n = a && !t.isUrl ? wo : Do;\n  return new Promise(function (s, i) {\n    n(e, function (u, o) {\n      if (u) {\n        if (r) return r(u);\n        i(u);\n      }\n      var l;\n      try {\n        l = Dr(o, t);\n      } catch (f) {\n        if (r) return r(f, null);\n        i(f);\n      }\n      if (r) return r(null, l);\n      s(l);\n    });\n  });\n}\nfunction Io(e, r) {\n  var t = Ne(),\n    a = t.readFileSync(e);\n  return Dr($t(a), r);\n}\nvar Mo = Object.freeze({\n    __proto__: null,\n    Font: w,\n    Glyph: Q,\n    Path: P,\n    BoundingBox: pe,\n    _parse: k,\n    parse: Dr,\n    load: Bo,\n    loadSync: Io\n  }),\n  Ho = Mo;\nexport { ne as Bidi, pe as BoundingBox, w as Font, Q as Glyph, P as Path, k as _parse, Ho as default, Bo as load, Io as loadSync, Dr as parse };","map":null,"metadata":{},"sourceType":"module"}