{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{199:function(r,e,t){\"use strict\";t.r(e);var n=function(){var r=\"undefined\"!==typeof document&&document.currentScript?document.currentScript.src:void 0;return function(e){var t,n;(e=\"undefined\"!==typeof(e=e||{})?e:{}).ready=new Promise((function(r,e){t=r,n=e}));var o,i={};for(o in e)e.hasOwnProperty(o)&&(i[o]=e[o]);var a,s,u,c=[],f=\"./this.program\",l=\"\";\"undefined\"!==typeof document&&document.currentScript&&(l=document.currentScript.src),r&&(l=r),l=0!==l.indexOf(\"blob:\")?l.substr(0,l.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",a=function(r){var e=new XMLHttpRequest;return e.open(\"GET\",r,!1),e.send(null),e.responseText},s=function(r,e,t){var n=new XMLHttpRequest;n.open(\"GET\",r,!0),n.responseType=\"arraybuffer\",n.onload=function(){200==n.status||0==n.status&&n.response?e(n.response):t()},n.onerror=t,n.send(null)};var d=e.print||console.log.bind(console),p=e.printErr||console.warn.bind(console);for(o in i)i.hasOwnProperty(o)&&(e[o]=i[o]);i=null,e.arguments&&(c=e.arguments),e.thisProgram&&(f=e.thisProgram),e.quit&&e.quit;var h;e.wasmBinary&&(h=e.wasmBinary);var m;e.noExitRuntime;\"object\"!==typeof WebAssembly&&K(\"no native wasm support detected\");var v=!1;function y(r,e){r||K(\"Assertion failed: \"+e)}var w=\"undefined\"!==typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function g(r,e,t){for(var n=e+t,o=e;r[o]&&!(o>=n);)++o;if(o-e>16&&r.subarray&&w)return w.decode(r.subarray(e,o));for(var i=\"\";e<o;){var a=r[e++];if(128&a){var s=63&r[e++];if(192!=(224&a)){var u=63&r[e++];if((a=224==(240&a)?(15&a)<<12|s<<6|u:(7&a)<<18|s<<12|u<<6|63&r[e++])<65536)i+=String.fromCharCode(a);else{var c=a-65536;i+=String.fromCharCode(55296|c>>10,56320|1023&c)}}else i+=String.fromCharCode((31&a)<<6|s)}else i+=String.fromCharCode(a)}return i}function E(r,e){return r?g(D,r,e):\"\"}function _(r,e,t,n){if(!(n>0))return 0;for(var o=t,i=t+n-1,a=0;a<r.length;++a){var s=r.charCodeAt(a);if(s>=55296&&s<=57343)s=65536+((1023&s)<<10)|1023&r.charCodeAt(++a);if(s<=127){if(t>=i)break;e[t++]=s}else if(s<=2047){if(t+1>=i)break;e[t++]=192|s>>6,e[t++]=128|63&s}else if(s<=65535){if(t+2>=i)break;e[t++]=224|s>>12,e[t++]=128|s>>6&63,e[t++]=128|63&s}else{if(t+3>=i)break;e[t++]=240|s>>18,e[t++]=128|s>>12&63,e[t++]=128|s>>6&63,e[t++]=128|63&s}}return e[t]=0,t-o}function b(r,e,t){return _(r,D,e,t)}function k(r){for(var e=0,t=0;t<r.length;++t){var n=r.charCodeAt(t);n>=55296&&n<=57343&&(n=65536+((1023&n)<<10)|1023&r.charCodeAt(++t)),n<=127?++e:e+=n<=2047?2:n<=65535?3:4}return e}var P,T,D,C,A,F,S,$,M,O=\"undefined\"!==typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0;function R(r,e){for(var t=r,n=t>>1,o=n+e/2;!(n>=o)&&A[n];)++n;if((t=n<<1)-r>32&&O)return O.decode(D.subarray(r,t));for(var i=\"\",a=0;!(a>=e/2);++a){var s=C[r+2*a>>1];if(0==s)break;i+=String.fromCharCode(s)}return i}function j(r,e,t){if(void 0===t&&(t=2147483647),t<2)return 0;for(var n=e,o=(t-=2)<2*r.length?t/2:r.length,i=0;i<o;++i){var a=r.charCodeAt(i);C[e>>1]=a,e+=2}return C[e>>1]=0,e-n}function x(r){return 2*r.length}function W(r,e){for(var t=0,n=\"\";!(t>=e/4);){var o=F[r+4*t>>2];if(0==o)break;if(++t,o>=65536){var i=o-65536;n+=String.fromCharCode(55296|i>>10,56320|1023&i)}else n+=String.fromCharCode(o)}return n}function B(r,e,t){if(void 0===t&&(t=2147483647),t<4)return 0;for(var n=e,o=n+t-4,i=0;i<r.length;++i){var a=r.charCodeAt(i);if(a>=55296&&a<=57343)a=65536+((1023&a)<<10)|1023&r.charCodeAt(++i);if(F[e>>2]=a,(e+=4)+4>o)break}return F[e>>2]=0,e-n}function N(r){for(var e=0,t=0;t<r.length;++t){var n=r.charCodeAt(t);n>=55296&&n<=57343&&++t,e+=4}return e}function z(r,e){T.set(r,e)}function I(r){P=r,e.HEAP8=T=new Int8Array(r),e.HEAP16=C=new Int16Array(r),e.HEAP32=F=new Int32Array(r),e.HEAPU8=D=new Uint8Array(r),e.HEAPU16=A=new Uint16Array(r),e.HEAPU32=S=new Uint32Array(r),e.HEAPF32=$=new Float32Array(r),e.HEAPF64=M=new Float64Array(r)}e.INITIAL_MEMORY;var U,H=[],L=[],V=[];var Y=0,q=null,X=null;function G(r){Y++,e.monitorRunDependencies&&e.monitorRunDependencies(Y)}function J(r){if(Y--,e.monitorRunDependencies&&e.monitorRunDependencies(Y),0==Y&&(null!==q&&(clearInterval(q),q=null),X)){var t=X;X=null,t()}}function K(r){e.onAbort&&e.onAbort(r),p(r=\"Aborted(\"+r+\")\"),v=!0,1,r+=\". Build with -s ASSERTIONS=1 for more info.\";var t=new WebAssembly.RuntimeError(r);throw n(t),t}e.preloadedImages={},e.preloadedAudios={};var Z,Q,rr,er;function tr(r){return r.startsWith(\"data:application/octet-stream;base64,\")}function nr(r){try{if(r==Z&&h)return new Uint8Array(h);if(u)return u(r);throw\"both async and sync fetching of the wasm failed\"}catch(p){K(p)}}function or(r){for(;r.length>0;){var t=r.shift();if(\"function\"!=typeof t){var n=t.func;\"number\"===typeof n?void 0===t.arg?ar(n)():ar(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(e)}}tr(Z=\"process.wasm\")||(Q=Z,Z=e.locateFile?e.locateFile(Q,l):l+Q);var ir=[];function ar(r){var e=ir[r];return e||(r>=ir.length&&(ir.length=r+1),ir[r]=e=U.get(r)),e}function sr(r){this.excPtr=r,this.ptr=r-16,this.set_type=function(r){F[this.ptr+4>>2]=r},this.get_type=function(){return F[this.ptr+4>>2]},this.set_destructor=function(r){F[this.ptr+8>>2]=r},this.get_destructor=function(){return F[this.ptr+8>>2]},this.set_refcount=function(r){F[this.ptr>>2]=r},this.set_caught=function(r){r=r?1:0,T[this.ptr+12>>0]=r},this.get_caught=function(){return 0!=T[this.ptr+12>>0]},this.set_rethrown=function(r){r=r?1:0,T[this.ptr+13>>0]=r},this.get_rethrown=function(){return 0!=T[this.ptr+13>>0]},this.init=function(r,e){this.set_type(r),this.set_destructor(e),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var r=F[this.ptr>>2];F[this.ptr>>2]=r+1},this.release_ref=function(){var r=F[this.ptr>>2];return F[this.ptr>>2]=r-1,1===r}}var ur={};function cr(r){for(;r.length;){var e=r.pop();r.pop()(e)}}function fr(r){return this.fromWireType(S[r>>2])}var lr={},dr={},pr={};function hr(r){if(void 0===r)return\"_unknown\";var e=(r=r.replace(/[^a-zA-Z0-9_]/g,\"$\")).charCodeAt(0);return e>=48&&e<=57?\"_\"+r:r}function mr(r,e){return r=hr(r),new Function(\"body\",\"return function \"+r+'() {\\n    \"use strict\";    return body.apply(this, arguments);\\n};\\n')(e)}function vr(r,e){var t=mr(e,(function(r){this.name=e,this.message=r;var t=new Error(r).stack;void 0!==t&&(this.stack=this.toString()+\"\\n\"+t.replace(/^Error(:[^\\n]*)?\\n/,\"\"))}));return t.prototype=Object.create(r.prototype),t.prototype.constructor=t,t.prototype.toString=function(){return void 0===this.message?this.name:this.name+\": \"+this.message},t}var yr=void 0;function wr(r){throw new yr(r)}function gr(r,e,t){function n(e){var n=t(e);n.length!==r.length&&wr(\"Mismatched type converter count\");for(var o=0;o<r.length;++o)Dr(r[o],n[o])}r.forEach((function(r){pr[r]=e}));var o=new Array(e.length),i=[],a=0;e.forEach((function(r,e){dr.hasOwnProperty(r)?o[e]=dr[r]:(i.push(r),lr.hasOwnProperty(r)||(lr[r]=[]),lr[r].push((function(){o[e]=dr[r],++a===i.length&&n(o)})))})),0===i.length&&n(o)}var Er={};function _r(r){switch(r){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+r)}}var br=void 0;function kr(r){for(var e=\"\",t=r;D[t];)e+=br[D[t++]];return e}var Pr=void 0;function Tr(r){throw new Pr(r)}function Dr(r,e,t){if(t=t||{},!(\"argPackAdvance\"in e))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");var n=e.name;if(r||Tr('type \"'+n+'\" must have a positive integer typeid pointer'),dr.hasOwnProperty(r)){if(t.ignoreDuplicateRegistrations)return;Tr(\"Cannot register type '\"+n+\"' twice\")}if(dr[r]=e,delete pr[r],lr.hasOwnProperty(r)){var o=lr[r];delete lr[r],o.forEach((function(r){r()}))}}function Cr(r){if(!(this instanceof zr))return!1;if(!(r instanceof zr))return!1;for(var e=this.$$.ptrType.registeredClass,t=this.$$.ptr,n=r.$$.ptrType.registeredClass,o=r.$$.ptr;e.baseClass;)t=e.upcast(t),e=e.baseClass;for(;n.baseClass;)o=n.upcast(o),n=n.baseClass;return e===n&&t===o}function Ar(r){Tr(r.$$.ptrType.registeredClass.name+\" instance already deleted\")}var Fr=!1;function Sr(r){}function $r(r){r.count.value-=1,0===r.count.value&&function(r){r.smartPtr?r.smartPtrType.rawDestructor(r.smartPtr):r.ptrType.registeredClass.rawDestructor(r.ptr)}(r)}function Mr(r){return\"undefined\"===typeof FinalizationRegistry?(Mr=function(r){return r},r):(Fr=new FinalizationRegistry((function(r){$r(r.$$)})),Mr=function(r){var e={$$:r.$$};return Fr.register(r,e,r),r},Sr=function(r){Fr.unregister(r)},Mr(r))}function Or(){if(this.$$.ptr||Ar(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var r,e=Mr(Object.create(Object.getPrototypeOf(this),{$$:{value:(r=this.$$,{count:r.count,deleteScheduled:r.deleteScheduled,preservePointerOnDelete:r.preservePointerOnDelete,ptr:r.ptr,ptrType:r.ptrType,smartPtr:r.smartPtr,smartPtrType:r.smartPtrType})}}));return e.$$.count.value+=1,e.$$.deleteScheduled=!1,e}function Rr(){this.$$.ptr||Ar(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Tr(\"Object already scheduled for deletion\"),Sr(this),$r(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function jr(){return!this.$$.ptr}var xr=void 0,Wr=[];function Br(){for(;Wr.length;){var r=Wr.pop();r.$$.deleteScheduled=!1,r.delete()}}function Nr(){return this.$$.ptr||Ar(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Tr(\"Object already scheduled for deletion\"),Wr.push(this),1===Wr.length&&xr&&xr(Br),this.$$.deleteScheduled=!0,this}function zr(){}var Ir={};function Ur(r,e,t){if(void 0===r[e].overloadTable){var n=r[e];r[e]=function(){return r[e].overloadTable.hasOwnProperty(arguments.length)||Tr(\"Function '\"+t+\"' called with an invalid number of arguments (\"+arguments.length+\") - expects one of (\"+r[e].overloadTable+\")!\"),r[e].overloadTable[arguments.length].apply(this,arguments)},r[e].overloadTable=[],r[e].overloadTable[n.argCount]=n}}function Hr(r,t,n){e.hasOwnProperty(r)?((void 0===n||void 0!==e[r].overloadTable&&void 0!==e[r].overloadTable[n])&&Tr(\"Cannot register public name '\"+r+\"' twice\"),Ur(e,r,r),e.hasOwnProperty(n)&&Tr(\"Cannot register multiple overloads of a function with the same number of arguments (\"+n+\")!\"),e[r].overloadTable[n]=t):(e[r]=t,void 0!==n&&(e[r].numArguments=n))}function Lr(r,e,t,n,o,i,a,s){this.name=r,this.constructor=e,this.instancePrototype=t,this.rawDestructor=n,this.baseClass=o,this.getActualType=i,this.upcast=a,this.downcast=s,this.pureVirtualFunctions=[]}function Vr(r,e,t){for(;e!==t;)e.upcast||Tr(\"Expected null or instance of \"+t.name+\", got an instance of \"+e.name),r=e.upcast(r),e=e.baseClass;return r}function Yr(r,e){if(null===e)return this.isReference&&Tr(\"null is not a valid \"+this.name),0;e.$$||Tr('Cannot pass \"'+Pe(e)+'\" as a '+this.name),e.$$.ptr||Tr(\"Cannot pass deleted object as a pointer of type \"+this.name);var t=e.$$.ptrType.registeredClass;return Vr(e.$$.ptr,t,this.registeredClass)}function qr(r,e){var t;if(null===e)return this.isReference&&Tr(\"null is not a valid \"+this.name),this.isSmartPointer?(t=this.rawConstructor(),null!==r&&r.push(this.rawDestructor,t),t):0;e.$$||Tr('Cannot pass \"'+Pe(e)+'\" as a '+this.name),e.$$.ptr||Tr(\"Cannot pass deleted object as a pointer of type \"+this.name),!this.isConst&&e.$$.ptrType.isConst&&Tr(\"Cannot convert argument of type \"+(e.$$.smartPtrType?e.$$.smartPtrType.name:e.$$.ptrType.name)+\" to parameter type \"+this.name);var n=e.$$.ptrType.registeredClass;if(t=Vr(e.$$.ptr,n,this.registeredClass),this.isSmartPointer)switch(void 0===e.$$.smartPtr&&Tr(\"Passing raw pointer to smart pointer is illegal\"),this.sharingPolicy){case 0:e.$$.smartPtrType===this?t=e.$$.smartPtr:Tr(\"Cannot convert argument of type \"+(e.$$.smartPtrType?e.$$.smartPtrType.name:e.$$.ptrType.name)+\" to parameter type \"+this.name);break;case 1:t=e.$$.smartPtr;break;case 2:if(e.$$.smartPtrType===this)t=e.$$.smartPtr;else{var o=e.clone();t=this.rawShare(t,_e.toHandle((function(){o.delete()}))),null!==r&&r.push(this.rawDestructor,t)}break;default:Tr(\"Unsupporting sharing policy\")}return t}function Xr(r,e){if(null===e)return this.isReference&&Tr(\"null is not a valid \"+this.name),0;e.$$||Tr('Cannot pass \"'+Pe(e)+'\" as a '+this.name),e.$$.ptr||Tr(\"Cannot pass deleted object as a pointer of type \"+this.name),e.$$.ptrType.isConst&&Tr(\"Cannot convert argument of type \"+e.$$.ptrType.name+\" to parameter type \"+this.name);var t=e.$$.ptrType.registeredClass;return Vr(e.$$.ptr,t,this.registeredClass)}function Gr(r){return this.rawGetPointee&&(r=this.rawGetPointee(r)),r}function Jr(r){this.rawDestructor&&this.rawDestructor(r)}function Kr(r){null!==r&&r.delete()}function Zr(r,e,t){if(e===t)return r;if(void 0===t.baseClass)return null;var n=Zr(r,e,t.baseClass);return null===n?null:t.downcast(n)}function Qr(){return Object.keys(te).length}function re(){var r=[];for(var e in te)te.hasOwnProperty(e)&&r.push(te[e]);return r}function ee(r){xr=r,Wr.length&&xr&&xr(Br)}var te={};function ne(r,e){return e=function(r,e){for(void 0===e&&Tr(\"ptr should not be undefined\");r.baseClass;)e=r.upcast(e),r=r.baseClass;return e}(r,e),te[e]}function oe(r,e){return e.ptrType&&e.ptr||wr(\"makeClassHandle requires ptr and ptrType\"),!!e.smartPtrType!==!!e.smartPtr&&wr(\"Both smartPtrType and smartPtr must be specified\"),e.count={value:1},Mr(Object.create(r,{$$:{value:e}}))}function ie(r){var e=this.getPointee(r);if(!e)return this.destructor(r),null;var t=ne(this.registeredClass,e);if(void 0!==t){if(0===t.$$.count.value)return t.$$.ptr=e,t.$$.smartPtr=r,t.clone();var n=t.clone();return this.destructor(r),n}function o(){return this.isSmartPointer?oe(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:e,smartPtrType:this,smartPtr:r}):oe(this.registeredClass.instancePrototype,{ptrType:this,ptr:r})}var i,a=this.registeredClass.getActualType(e),s=Ir[a];if(!s)return o.call(this);i=this.isConst?s.constPointerType:s.pointerType;var u=Zr(e,this.registeredClass,i.registeredClass);return null===u?o.call(this):this.isSmartPointer?oe(i.registeredClass.instancePrototype,{ptrType:i,ptr:u,smartPtrType:this,smartPtr:r}):oe(i.registeredClass.instancePrototype,{ptrType:i,ptr:u})}function ae(r,e,t,n,o,i,a,s,u,c,f){this.name=r,this.registeredClass=e,this.isReference=t,this.isConst=n,this.isSmartPointer=o,this.pointeeType=i,this.sharingPolicy=a,this.rawGetPointee=s,this.rawConstructor=u,this.rawShare=c,this.rawDestructor=f,o||void 0!==e.baseClass?this.toWireType=qr:n?(this.toWireType=Yr,this.destructorFunction=null):(this.toWireType=Xr,this.destructorFunction=null)}function se(r,t,n){e.hasOwnProperty(r)||wr(\"Replacing nonexistant public symbol\"),void 0!==e[r].overloadTable&&void 0!==n?e[r].overloadTable[n]=t:(e[r]=t,e[r].argCount=n)}function ue(r,t,n){return r.includes(\"j\")?function(r,t,n){var o=e[\"dynCall_\"+r];return n&&n.length?o.apply(null,[t].concat(n)):o.call(null,t)}(r,t,n):ar(t).apply(null,n)}function ce(r,e){var t=(r=kr(r)).includes(\"j\")?function(r,e){var t=[];return function(){t.length=arguments.length;for(var n=0;n<arguments.length;n++)t[n]=arguments[n];return ue(r,e,t)}}(r,e):ar(e);return\"function\"!==typeof t&&Tr(\"unknown function pointer with signature \"+r+\": \"+e),t}var fe=void 0;function le(r){var e=Ge(r),t=kr(e);return Xe(e),t}function de(r,e){var t=[],n={};throw e.forEach((function r(e){n[e]||dr[e]||(pr[e]?pr[e].forEach(r):(t.push(e),n[e]=!0))})),new fe(r+\": \"+t.map(le).join([\", \"]))}function pe(r,e){for(var t=[],n=0;n<r;n++)t.push(F[(e>>2)+n]);return t}function he(r,e,t,n,o){var i=e.length;i<2&&Tr(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");for(var a=null!==e[1]&&null!==t,s=!1,u=1;u<e.length;++u)if(null!==e[u]&&void 0===e[u].destructorFunction){s=!0;break}var c=\"void\"!==e[0].name,f=\"\",l=\"\";for(u=0;u<i-2;++u)f+=(0!==u?\", \":\"\")+\"arg\"+u,l+=(0!==u?\", \":\"\")+\"arg\"+u+\"Wired\";var d=\"return function \"+hr(r)+\"(\"+f+\") {\\nif (arguments.length !== \"+(i-2)+\") {\\nthrowBindingError('function \"+r+\" called with ' + arguments.length + ' arguments, expected \"+(i-2)+\" args!');\\n}\\n\";s&&(d+=\"var destructors = [];\\n\");var p=s?\"destructors\":\"null\",h=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"],m=[Tr,n,o,cr,e[0],e[1]];a&&(d+=\"var thisWired = classParam.toWireType(\"+p+\", this);\\n\");for(u=0;u<i-2;++u)d+=\"var arg\"+u+\"Wired = argType\"+u+\".toWireType(\"+p+\", arg\"+u+\"); // \"+e[u+2].name+\"\\n\",h.push(\"argType\"+u),m.push(e[u+2]);if(a&&(l=\"thisWired\"+(l.length>0?\", \":\"\")+l),d+=(c?\"var rv = \":\"\")+\"invoker(fn\"+(l.length>0?\", \":\"\")+l+\");\\n\",s)d+=\"runDestructors(destructors);\\n\";else for(u=a?1:2;u<e.length;++u){var v=1===u?\"thisWired\":\"arg\"+(u-2)+\"Wired\";null!==e[u].destructorFunction&&(d+=v+\"_dtor(\"+v+\"); // \"+e[u].name+\"\\n\",h.push(v+\"_dtor\"),m.push(e[u].destructorFunction))}return c&&(d+=\"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\"),d+=\"}\\n\",h.push(d),function(r,e){if(!(r instanceof Function))throw new TypeError(\"new_ called with constructor type \"+typeof r+\" which is not a function\");var t=mr(r.name||\"unknownFunctionName\",(function(){}));t.prototype=r.prototype;var n=new t,o=r.apply(n,e);return o instanceof Object?o:n}(Function,h).apply(null,m)}function me(r,e,t){return r instanceof Object||Tr(t+' with invalid \"this\": '+r),r instanceof e.registeredClass.constructor||Tr(t+' incompatible with \"this\" of type '+r.constructor.name),r.$$.ptr||Tr(\"cannot call emscripten binding method \"+t+\" on deleted object\"),Vr(r.$$.ptr,r.$$.ptrType.registeredClass,e.registeredClass)}var ve=[],ye=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function we(r){r>4&&0===--ye[r].refcount&&(ye[r]=void 0,ve.push(r))}function ge(){for(var r=0,e=5;e<ye.length;++e)void 0!==ye[e]&&++r;return r}function Ee(){for(var r=5;r<ye.length;++r)if(void 0!==ye[r])return ye[r];return null}var _e={toValue:function(r){return r||Tr(\"Cannot use deleted val. handle = \"+r),ye[r].value},toHandle:function(r){switch(r){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:var e=ve.length?ve.pop():ye.length;return ye[e]={refcount:1,value:r},e}}};function be(r,e,t){switch(e){case 0:return function(r){var e=t?T:D;return this.fromWireType(e[r])};case 1:return function(r){var e=t?C:A;return this.fromWireType(e[r>>1])};case 2:return function(r){var e=t?F:S;return this.fromWireType(e[r>>2])};default:throw new TypeError(\"Unknown integer type: \"+r)}}function ke(r,e){var t=dr[r];return void 0===t&&Tr(e+\" has unknown type \"+le(r)),t}function Pe(r){if(null===r)return\"null\";var e=typeof r;return\"object\"===e||\"array\"===e||\"function\"===e?r.toString():\"\"+r}function Te(r,e){switch(e){case 2:return function(r){return this.fromWireType($[r>>2])};case 3:return function(r){return this.fromWireType(M[r>>3])};default:throw new TypeError(\"Unknown float type: \"+r)}}function De(r,e,t){switch(e){case 0:return t?function(r){return T[r]}:function(r){return D[r]};case 1:return t?function(r){return C[r>>1]}:function(r){return A[r>>1]};case 2:return t?function(r){return F[r>>2]}:function(r){return S[r>>2]};default:throw new TypeError(\"Unknown integer type: \"+r)}}function Ce(r){try{return m.grow(r-P.byteLength+65535>>>16),I(m.buffer),1}catch(e){}}var Ae={};function Fe(){if(!Fe.strings){var r={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"===typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:f||\"./this.program\"};for(var e in Ae)void 0===Ae[e]?delete r[e]:r[e]=Ae[e];var t=[];for(var e in r)t.push(e+\"=\"+r[e]);Fe.strings=t}return Fe.strings}var Se={splitPath:function(r){return/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/.exec(r).slice(1)},normalizeArray:function(r,e){for(var t=0,n=r.length-1;n>=0;n--){var o=r[n];\".\"===o?r.splice(n,1):\"..\"===o?(r.splice(n,1),t++):t&&(r.splice(n,1),t--)}if(e)for(;t;t--)r.unshift(\"..\");return r},normalize:function(r){var e=\"/\"===r.charAt(0),t=\"/\"===r.substr(-1);return(r=Se.normalizeArray(r.split(\"/\").filter((function(r){return!!r})),!e).join(\"/\"))||e||(r=\".\"),r&&t&&(r+=\"/\"),(e?\"/\":\"\")+r},dirname:function(r){var e=Se.splitPath(r),t=e[0],n=e[1];return t||n?(n&&(n=n.substr(0,n.length-1)),t+n):\".\"},basename:function(r){if(\"/\"===r)return\"/\";var e=(r=(r=Se.normalize(r)).replace(/\\/$/,\"\")).lastIndexOf(\"/\");return-1===e?r:r.substr(e+1)},extname:function(r){return Se.splitPath(r)[3]},join:function(){var r=Array.prototype.slice.call(arguments,0);return Se.normalize(r.join(\"/\"))},join2:function(r,e){return Se.normalize(r+\"/\"+e)}};var $e={resolve:function(){for(var r=\"\",e=!1,t=arguments.length-1;t>=-1&&!e;t--){var n=t>=0?arguments[t]:Re.cwd();if(\"string\"!==typeof n)throw new TypeError(\"Arguments to path.resolve must be strings\");if(!n)return\"\";r=n+\"/\"+r,e=\"/\"===n.charAt(0)}return(e?\"/\":\"\")+(r=Se.normalizeArray(r.split(\"/\").filter((function(r){return!!r})),!e).join(\"/\"))||\".\"},relative:function(r,e){function t(r){for(var e=0;e<r.length&&\"\"===r[e];e++);for(var t=r.length-1;t>=0&&\"\"===r[t];t--);return e>t?[]:r.slice(e,t-e+1)}r=$e.resolve(r).substr(1),e=$e.resolve(e).substr(1);for(var n=t(r.split(\"/\")),o=t(e.split(\"/\")),i=Math.min(n.length,o.length),a=i,s=0;s<i;s++)if(n[s]!==o[s]){a=s;break}var u=[];for(s=a;s<n.length;s++)u.push(\"..\");return(u=u.concat(o.slice(a))).join(\"/\")}},Me={ttys:[],init:function(){},shutdown:function(){},register:function(r,e){Me.ttys[r]={input:[],output:[],ops:e},Re.registerDevice(r,Me.stream_ops)},stream_ops:{open:function(r){var e=Me.ttys[r.node.rdev];if(!e)throw new Re.ErrnoError(43);r.tty=e,r.seekable=!1},close:function(r){r.tty.ops.flush(r.tty)},flush:function(r){r.tty.ops.flush(r.tty)},read:function(r,e,t,n,o){if(!r.tty||!r.tty.ops.get_char)throw new Re.ErrnoError(60);for(var i=0,a=0;a<n;a++){var s;try{s=r.tty.ops.get_char(r.tty)}catch(u){throw new Re.ErrnoError(29)}if(void 0===s&&0===i)throw new Re.ErrnoError(6);if(null===s||void 0===s)break;i++,e[t+a]=s}return i&&(r.node.timestamp=Date.now()),i},write:function(r,e,t,n,o){if(!r.tty||!r.tty.ops.put_char)throw new Re.ErrnoError(60);try{for(var i=0;i<n;i++)r.tty.ops.put_char(r.tty,e[t+i])}catch(a){throw new Re.ErrnoError(29)}return n&&(r.node.timestamp=Date.now()),i}},default_tty_ops:{get_char:function(r){if(!r.input.length){var e=null;if(\"undefined\"!=typeof window&&\"function\"==typeof window.prompt?null!==(e=window.prompt(\"Input: \"))&&(e+=\"\\n\"):\"function\"==typeof readline&&null!==(e=readline())&&(e+=\"\\n\"),!e)return null;r.input=Le(e,!0)}return r.input.shift()},put_char:function(r,e){null===e||10===e?(d(g(r.output,0)),r.output=[]):0!=e&&r.output.push(e)},flush:function(r){r.output&&r.output.length>0&&(d(g(r.output,0)),r.output=[])}},default_tty1_ops:{put_char:function(r,e){null===e||10===e?(p(g(r.output,0)),r.output=[]):0!=e&&r.output.push(e)},flush:function(r){r.output&&r.output.length>0&&(p(g(r.output,0)),r.output=[])}}};var Oe={ops_table:null,mount:function(r){return Oe.createNode(null,\"/\",16895,0)},createNode:function(r,e,t,n){if(Re.isBlkdev(t)||Re.isFIFO(t))throw new Re.ErrnoError(63);Oe.ops_table||(Oe.ops_table={dir:{node:{getattr:Oe.node_ops.getattr,setattr:Oe.node_ops.setattr,lookup:Oe.node_ops.lookup,mknod:Oe.node_ops.mknod,rename:Oe.node_ops.rename,unlink:Oe.node_ops.unlink,rmdir:Oe.node_ops.rmdir,readdir:Oe.node_ops.readdir,symlink:Oe.node_ops.symlink},stream:{llseek:Oe.stream_ops.llseek}},file:{node:{getattr:Oe.node_ops.getattr,setattr:Oe.node_ops.setattr},stream:{llseek:Oe.stream_ops.llseek,read:Oe.stream_ops.read,write:Oe.stream_ops.write,allocate:Oe.stream_ops.allocate,mmap:Oe.stream_ops.mmap,msync:Oe.stream_ops.msync}},link:{node:{getattr:Oe.node_ops.getattr,setattr:Oe.node_ops.setattr,readlink:Oe.node_ops.readlink},stream:{}},chrdev:{node:{getattr:Oe.node_ops.getattr,setattr:Oe.node_ops.setattr},stream:Re.chrdev_stream_ops}});var o=Re.createNode(r,e,t,n);return Re.isDir(o.mode)?(o.node_ops=Oe.ops_table.dir.node,o.stream_ops=Oe.ops_table.dir.stream,o.contents={}):Re.isFile(o.mode)?(o.node_ops=Oe.ops_table.file.node,o.stream_ops=Oe.ops_table.file.stream,o.usedBytes=0,o.contents=null):Re.isLink(o.mode)?(o.node_ops=Oe.ops_table.link.node,o.stream_ops=Oe.ops_table.link.stream):Re.isChrdev(o.mode)&&(o.node_ops=Oe.ops_table.chrdev.node,o.stream_ops=Oe.ops_table.chrdev.stream),o.timestamp=Date.now(),r&&(r.contents[e]=o,r.timestamp=o.timestamp),o},getFileDataAsTypedArray:function(r){return r.contents?r.contents.subarray?r.contents.subarray(0,r.usedBytes):new Uint8Array(r.contents):new Uint8Array(0)},expandFileStorage:function(r,e){var t=r.contents?r.contents.length:0;if(!(t>=e)){e=Math.max(e,t*(t<1048576?2:1.125)>>>0),0!=t&&(e=Math.max(e,256));var n=r.contents;r.contents=new Uint8Array(e),r.usedBytes>0&&r.contents.set(n.subarray(0,r.usedBytes),0)}},resizeFileStorage:function(r,e){if(r.usedBytes!=e)if(0==e)r.contents=null,r.usedBytes=0;else{var t=r.contents;r.contents=new Uint8Array(e),t&&r.contents.set(t.subarray(0,Math.min(e,r.usedBytes))),r.usedBytes=e}},node_ops:{getattr:function(r){var e={};return e.dev=Re.isChrdev(r.mode)?r.id:1,e.ino=r.id,e.mode=r.mode,e.nlink=1,e.uid=0,e.gid=0,e.rdev=r.rdev,Re.isDir(r.mode)?e.size=4096:Re.isFile(r.mode)?e.size=r.usedBytes:Re.isLink(r.mode)?e.size=r.link.length:e.size=0,e.atime=new Date(r.timestamp),e.mtime=new Date(r.timestamp),e.ctime=new Date(r.timestamp),e.blksize=4096,e.blocks=Math.ceil(e.size/e.blksize),e},setattr:function(r,e){void 0!==e.mode&&(r.mode=e.mode),void 0!==e.timestamp&&(r.timestamp=e.timestamp),void 0!==e.size&&Oe.resizeFileStorage(r,e.size)},lookup:function(r,e){throw Re.genericErrors[44]},mknod:function(r,e,t,n){return Oe.createNode(r,e,t,n)},rename:function(r,e,t){if(Re.isDir(r.mode)){var n;try{n=Re.lookupNode(e,t)}catch(i){}if(n)for(var o in n.contents)throw new Re.ErrnoError(55)}delete r.parent.contents[r.name],r.parent.timestamp=Date.now(),r.name=t,e.contents[t]=r,e.timestamp=r.parent.timestamp,r.parent=e},unlink:function(r,e){delete r.contents[e],r.timestamp=Date.now()},rmdir:function(r,e){var t=Re.lookupNode(r,e);for(var n in t.contents)throw new Re.ErrnoError(55);delete r.contents[e],r.timestamp=Date.now()},readdir:function(r){var e=[\".\",\"..\"];for(var t in r.contents)r.contents.hasOwnProperty(t)&&e.push(t);return e},symlink:function(r,e,t){var n=Oe.createNode(r,e,41471,0);return n.link=t,n},readlink:function(r){if(!Re.isLink(r.mode))throw new Re.ErrnoError(28);return r.link}},stream_ops:{read:function(r,e,t,n,o){var i=r.node.contents;if(o>=r.node.usedBytes)return 0;var a=Math.min(r.node.usedBytes-o,n);if(a>8&&i.subarray)e.set(i.subarray(o,o+a),t);else for(var s=0;s<a;s++)e[t+s]=i[o+s];return a},write:function(r,e,t,n,o,i){if(e.buffer===T.buffer&&(i=!1),!n)return 0;var a=r.node;if(a.timestamp=Date.now(),e.subarray&&(!a.contents||a.contents.subarray)){if(i)return a.contents=e.subarray(t,t+n),a.usedBytes=n,n;if(0===a.usedBytes&&0===o)return a.contents=e.slice(t,t+n),a.usedBytes=n,n;if(o+n<=a.usedBytes)return a.contents.set(e.subarray(t,t+n),o),n}if(Oe.expandFileStorage(a,o+n),a.contents.subarray&&e.subarray)a.contents.set(e.subarray(t,t+n),o);else for(var s=0;s<n;s++)a.contents[o+s]=e[t+s];return a.usedBytes=Math.max(a.usedBytes,o+n),n},llseek:function(r,e,t){var n=e;if(1===t?n+=r.position:2===t&&Re.isFile(r.node.mode)&&(n+=r.node.usedBytes),n<0)throw new Re.ErrnoError(28);return n},allocate:function(r,e,t){Oe.expandFileStorage(r.node,e+t),r.node.usedBytes=Math.max(r.node.usedBytes,e+t)},mmap:function(r,e,t,n,o,i){if(0!==e)throw new Re.ErrnoError(28);if(!Re.isFile(r.node.mode))throw new Re.ErrnoError(43);var a,s,u=r.node.contents;if(2&i||u.buffer!==P){if((n>0||n+t<u.length)&&(u=u.subarray?u.subarray(n,n+t):Array.prototype.slice.call(u,n,n+t)),s=!0,!(a=void K()))throw new Re.ErrnoError(48);T.set(u,a)}else s=!1,a=u.byteOffset;return{ptr:a,allocated:s}},msync:function(r,e,t,n,o){if(!Re.isFile(r.node.mode))throw new Re.ErrnoError(43);if(2&o)return 0;Oe.stream_ops.write(r,e,0,n,t,!1);return 0}}};var Re={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:!1,ignorePermissions:!0,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:function(r,e){if(e=e||{},!(r=$e.resolve(Re.cwd(),r)))return{path:\"\",node:null};var t={follow_mount:!0,recurse_count:0};for(var n in t)void 0===e[n]&&(e[n]=t[n]);if(e.recurse_count>8)throw new Re.ErrnoError(32);for(var o=Se.normalizeArray(r.split(\"/\").filter((function(r){return!!r})),!1),i=Re.root,a=\"/\",s=0;s<o.length;s++){var u=s===o.length-1;if(u&&e.parent)break;if(i=Re.lookupNode(i,o[s]),a=Se.join2(a,o[s]),Re.isMountpoint(i)&&(!u||u&&e.follow_mount)&&(i=i.mounted.root),!u||e.follow)for(var c=0;Re.isLink(i.mode);){var f=Re.readlink(a);if(a=$e.resolve(Se.dirname(a),f),i=Re.lookupPath(a,{recurse_count:e.recurse_count}).node,c++>40)throw new Re.ErrnoError(32)}}return{path:a,node:i}},getPath:function(r){for(var e;;){if(Re.isRoot(r)){var t=r.mount.mountpoint;return e?\"/\"!==t[t.length-1]?t+\"/\"+e:t+e:t}e=e?r.name+\"/\"+e:r.name,r=r.parent}},hashName:function(r,e){for(var t=0,n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n)|0;return(r+t>>>0)%Re.nameTable.length},hashAddNode:function(r){var e=Re.hashName(r.parent.id,r.name);r.name_next=Re.nameTable[e],Re.nameTable[e]=r},hashRemoveNode:function(r){var e=Re.hashName(r.parent.id,r.name);if(Re.nameTable[e]===r)Re.nameTable[e]=r.name_next;else for(var t=Re.nameTable[e];t;){if(t.name_next===r){t.name_next=r.name_next;break}t=t.name_next}},lookupNode:function(r,e){var t=Re.mayLookup(r);if(t)throw new Re.ErrnoError(t,r);for(var n=Re.hashName(r.id,e),o=Re.nameTable[n];o;o=o.name_next){var i=o.name;if(o.parent.id===r.id&&i===e)return o}return Re.lookup(r,e)},createNode:function(r,e,t,n){var o=new Re.FSNode(r,e,t,n);return Re.hashAddNode(o),o},destroyNode:function(r){Re.hashRemoveNode(r)},isRoot:function(r){return r===r.parent},isMountpoint:function(r){return!!r.mounted},isFile:function(r){return 32768===(61440&r)},isDir:function(r){return 16384===(61440&r)},isLink:function(r){return 40960===(61440&r)},isChrdev:function(r){return 8192===(61440&r)},isBlkdev:function(r){return 24576===(61440&r)},isFIFO:function(r){return 4096===(61440&r)},isSocket:function(r){return 49152===(49152&r)},flagModes:{r:0,\"r+\":2,w:577,\"w+\":578,a:1089,\"a+\":1090},modeStringToFlags:function(r){var e=Re.flagModes[r];if(\"undefined\"===typeof e)throw new Error(\"Unknown file open mode: \"+r);return e},flagsToPermissionString:function(r){var e=[\"r\",\"w\",\"rw\"][3&r];return 512&r&&(e+=\"w\"),e},nodePermissions:function(r,e){return Re.ignorePermissions||(!e.includes(\"r\")||292&r.mode)&&(!e.includes(\"w\")||146&r.mode)&&(!e.includes(\"x\")||73&r.mode)?0:2},mayLookup:function(r){var e=Re.nodePermissions(r,\"x\");return e||(r.node_ops.lookup?0:2)},mayCreate:function(r,e){try{Re.lookupNode(r,e);return 20}catch(t){}return Re.nodePermissions(r,\"wx\")},mayDelete:function(r,e,t){var n;try{n=Re.lookupNode(r,e)}catch(i){return i.errno}var o=Re.nodePermissions(r,\"wx\");if(o)return o;if(t){if(!Re.isDir(n.mode))return 54;if(Re.isRoot(n)||Re.getPath(n)===Re.cwd())return 10}else if(Re.isDir(n.mode))return 31;return 0},mayOpen:function(r,e){return r?Re.isLink(r.mode)?32:Re.isDir(r.mode)&&(\"r\"!==Re.flagsToPermissionString(e)||512&e)?31:Re.nodePermissions(r,Re.flagsToPermissionString(e)):44},MAX_OPEN_FDS:4096,nextfd:function(r,e){r=r||0,e=e||Re.MAX_OPEN_FDS;for(var t=r;t<=e;t++)if(!Re.streams[t])return t;throw new Re.ErrnoError(33)},getStream:function(r){return Re.streams[r]},createStream:function(r,e,t){Re.FSStream||(Re.FSStream=function(){},Re.FSStream.prototype={object:{get:function(){return this.node},set:function(r){this.node=r}},isRead:{get:function(){return 1!==(2097155&this.flags)}},isWrite:{get:function(){return 0!==(2097155&this.flags)}},isAppend:{get:function(){return 1024&this.flags}}});var n=new Re.FSStream;for(var o in r)n[o]=r[o];r=n;var i=Re.nextfd(e,t);return r.fd=i,Re.streams[i]=r,r},closeStream:function(r){Re.streams[r]=null},chrdev_stream_ops:{open:function(r){var e=Re.getDevice(r.node.rdev);r.stream_ops=e.stream_ops,r.stream_ops.open&&r.stream_ops.open(r)},llseek:function(){throw new Re.ErrnoError(70)}},major:function(r){return r>>8},minor:function(r){return 255&r},makedev:function(r,e){return r<<8|e},registerDevice:function(r,e){Re.devices[r]={stream_ops:e}},getDevice:function(r){return Re.devices[r]},getMounts:function(r){for(var e=[],t=[r];t.length;){var n=t.pop();e.push(n),t.push.apply(t,n.mounts)}return e},syncfs:function(r,e){\"function\"===typeof r&&(e=r,r=!1),Re.syncFSRequests++,Re.syncFSRequests>1&&p(\"warning: \"+Re.syncFSRequests+\" FS.syncfs operations in flight at once, probably just doing extra work\");var t=Re.getMounts(Re.root.mount),n=0;function o(r){return Re.syncFSRequests--,e(r)}function i(r){if(r)return i.errored?void 0:(i.errored=!0,o(r));++n>=t.length&&o(null)}t.forEach((function(e){if(!e.type.syncfs)return i(null);e.type.syncfs(e,r,i)}))},mount:function(r,e,t){var n,o=\"/\"===t,i=!t;if(o&&Re.root)throw new Re.ErrnoError(10);if(!o&&!i){var a=Re.lookupPath(t,{follow_mount:!1});if(t=a.path,n=a.node,Re.isMountpoint(n))throw new Re.ErrnoError(10);if(!Re.isDir(n.mode))throw new Re.ErrnoError(54)}var s={type:r,opts:e,mountpoint:t,mounts:[]},u=r.mount(s);return u.mount=s,s.root=u,o?Re.root=u:n&&(n.mounted=s,n.mount&&n.mount.mounts.push(s)),u},unmount:function(r){var e=Re.lookupPath(r,{follow_mount:!1});if(!Re.isMountpoint(e.node))throw new Re.ErrnoError(28);var t=e.node,n=t.mounted,o=Re.getMounts(n);Object.keys(Re.nameTable).forEach((function(r){for(var e=Re.nameTable[r];e;){var t=e.name_next;o.includes(e.mount)&&Re.destroyNode(e),e=t}})),t.mounted=null;var i=t.mount.mounts.indexOf(n);t.mount.mounts.splice(i,1)},lookup:function(r,e){return r.node_ops.lookup(r,e)},mknod:function(r,e,t){var n=Re.lookupPath(r,{parent:!0}).node,o=Se.basename(r);if(!o||\".\"===o||\"..\"===o)throw new Re.ErrnoError(28);var i=Re.mayCreate(n,o);if(i)throw new Re.ErrnoError(i);if(!n.node_ops.mknod)throw new Re.ErrnoError(63);return n.node_ops.mknod(n,o,e,t)},create:function(r,e){return e=void 0!==e?e:438,e&=4095,e|=32768,Re.mknod(r,e,0)},mkdir:function(r,e){return e=void 0!==e?e:511,e&=1023,e|=16384,Re.mknod(r,e,0)},mkdirTree:function(r,e){for(var t=r.split(\"/\"),n=\"\",o=0;o<t.length;++o)if(t[o]){n+=\"/\"+t[o];try{Re.mkdir(n,e)}catch(i){if(20!=i.errno)throw i}}},mkdev:function(r,e,t){return\"undefined\"===typeof t&&(t=e,e=438),e|=8192,Re.mknod(r,e,t)},symlink:function(r,e){if(!$e.resolve(r))throw new Re.ErrnoError(44);var t=Re.lookupPath(e,{parent:!0}).node;if(!t)throw new Re.ErrnoError(44);var n=Se.basename(e),o=Re.mayCreate(t,n);if(o)throw new Re.ErrnoError(o);if(!t.node_ops.symlink)throw new Re.ErrnoError(63);return t.node_ops.symlink(t,n,r)},rename:function(r,e){var t,n,o=Se.dirname(r),i=Se.dirname(e),a=Se.basename(r),s=Se.basename(e);if(t=Re.lookupPath(r,{parent:!0}).node,n=Re.lookupPath(e,{parent:!0}).node,!t||!n)throw new Re.ErrnoError(44);if(t.mount!==n.mount)throw new Re.ErrnoError(75);var u,c=Re.lookupNode(t,a),f=$e.relative(r,i);if(\".\"!==f.charAt(0))throw new Re.ErrnoError(28);if(\".\"!==(f=$e.relative(e,o)).charAt(0))throw new Re.ErrnoError(55);try{u=Re.lookupNode(n,s)}catch(p){}if(c!==u){var l=Re.isDir(c.mode),d=Re.mayDelete(t,a,l);if(d)throw new Re.ErrnoError(d);if(d=u?Re.mayDelete(n,s,l):Re.mayCreate(n,s))throw new Re.ErrnoError(d);if(!t.node_ops.rename)throw new Re.ErrnoError(63);if(Re.isMountpoint(c)||u&&Re.isMountpoint(u))throw new Re.ErrnoError(10);if(n!==t&&(d=Re.nodePermissions(t,\"w\")))throw new Re.ErrnoError(d);Re.hashRemoveNode(c);try{t.node_ops.rename(c,n,s)}catch(p){throw p}finally{Re.hashAddNode(c)}}},rmdir:function(r){var e=Re.lookupPath(r,{parent:!0}).node,t=Se.basename(r),n=Re.lookupNode(e,t),o=Re.mayDelete(e,t,!0);if(o)throw new Re.ErrnoError(o);if(!e.node_ops.rmdir)throw new Re.ErrnoError(63);if(Re.isMountpoint(n))throw new Re.ErrnoError(10);e.node_ops.rmdir(e,t),Re.destroyNode(n)},readdir:function(r){var e=Re.lookupPath(r,{follow:!0}).node;if(!e.node_ops.readdir)throw new Re.ErrnoError(54);return e.node_ops.readdir(e)},unlink:function(r){var e=Re.lookupPath(r,{parent:!0}).node,t=Se.basename(r),n=Re.lookupNode(e,t),o=Re.mayDelete(e,t,!1);if(o)throw new Re.ErrnoError(o);if(!e.node_ops.unlink)throw new Re.ErrnoError(63);if(Re.isMountpoint(n))throw new Re.ErrnoError(10);e.node_ops.unlink(e,t),Re.destroyNode(n)},readlink:function(r){var e=Re.lookupPath(r).node;if(!e)throw new Re.ErrnoError(44);if(!e.node_ops.readlink)throw new Re.ErrnoError(28);return $e.resolve(Re.getPath(e.parent),e.node_ops.readlink(e))},stat:function(r,e){var t=Re.lookupPath(r,{follow:!e}).node;if(!t)throw new Re.ErrnoError(44);if(!t.node_ops.getattr)throw new Re.ErrnoError(63);return t.node_ops.getattr(t)},lstat:function(r){return Re.stat(r,!0)},chmod:function(r,e,t){var n;\"string\"===typeof r?n=Re.lookupPath(r,{follow:!t}).node:n=r;if(!n.node_ops.setattr)throw new Re.ErrnoError(63);n.node_ops.setattr(n,{mode:4095&e|-4096&n.mode,timestamp:Date.now()})},lchmod:function(r,e){Re.chmod(r,e,!0)},fchmod:function(r,e){var t=Re.getStream(r);if(!t)throw new Re.ErrnoError(8);Re.chmod(t.node,e)},chown:function(r,e,t,n){var o;\"string\"===typeof r?o=Re.lookupPath(r,{follow:!n}).node:o=r;if(!o.node_ops.setattr)throw new Re.ErrnoError(63);o.node_ops.setattr(o,{timestamp:Date.now()})},lchown:function(r,e,t){Re.chown(r,e,t,!0)},fchown:function(r,e,t){var n=Re.getStream(r);if(!n)throw new Re.ErrnoError(8);Re.chown(n.node,e,t)},truncate:function(r,e){if(e<0)throw new Re.ErrnoError(28);var t;\"string\"===typeof r?t=Re.lookupPath(r,{follow:!0}).node:t=r;if(!t.node_ops.setattr)throw new Re.ErrnoError(63);if(Re.isDir(t.mode))throw new Re.ErrnoError(31);if(!Re.isFile(t.mode))throw new Re.ErrnoError(28);var n=Re.nodePermissions(t,\"w\");if(n)throw new Re.ErrnoError(n);t.node_ops.setattr(t,{size:e,timestamp:Date.now()})},ftruncate:function(r,e){var t=Re.getStream(r);if(!t)throw new Re.ErrnoError(8);if(0===(2097155&t.flags))throw new Re.ErrnoError(28);Re.truncate(t.node,e)},utime:function(r,e,t){var n=Re.lookupPath(r,{follow:!0}).node;n.node_ops.setattr(n,{timestamp:Math.max(e,t)})},open:function(r,t,n,o,i){if(\"\"===r)throw new Re.ErrnoError(44);var a;if(n=\"undefined\"===typeof n?438:n,n=64&(t=\"string\"===typeof t?Re.modeStringToFlags(t):t)?4095&n|32768:0,\"object\"===typeof r)a=r;else{r=Se.normalize(r);try{a=Re.lookupPath(r,{follow:!(131072&t)}).node}catch(f){}}var s=!1;if(64&t)if(a){if(128&t)throw new Re.ErrnoError(20)}else a=Re.mknod(r,n,0),s=!0;if(!a)throw new Re.ErrnoError(44);if(Re.isChrdev(a.mode)&&(t&=-513),65536&t&&!Re.isDir(a.mode))throw new Re.ErrnoError(54);if(!s){var u=Re.mayOpen(a,t);if(u)throw new Re.ErrnoError(u)}512&t&&Re.truncate(a,0),t&=-131713;var c=Re.createStream({node:a,path:Re.getPath(a),id:a.id,flags:t,mode:a.mode,seekable:!0,position:0,stream_ops:a.stream_ops,node_ops:a.node_ops,ungotten:[],error:!1},o,i);return c.stream_ops.open&&c.stream_ops.open(c),!e.logReadFiles||1&t||(Re.readFiles||(Re.readFiles={}),r in Re.readFiles||(Re.readFiles[r]=1)),c},close:function(r){if(Re.isClosed(r))throw new Re.ErrnoError(8);r.getdents&&(r.getdents=null);try{r.stream_ops.close&&r.stream_ops.close(r)}catch(e){throw e}finally{Re.closeStream(r.fd)}r.fd=null},isClosed:function(r){return null===r.fd},llseek:function(r,e,t){if(Re.isClosed(r))throw new Re.ErrnoError(8);if(!r.seekable||!r.stream_ops.llseek)throw new Re.ErrnoError(70);if(0!=t&&1!=t&&2!=t)throw new Re.ErrnoError(28);return r.position=r.stream_ops.llseek(r,e,t),r.ungotten=[],r.position},read:function(r,e,t,n,o){if(n<0||o<0)throw new Re.ErrnoError(28);if(Re.isClosed(r))throw new Re.ErrnoError(8);if(1===(2097155&r.flags))throw new Re.ErrnoError(8);if(Re.isDir(r.node.mode))throw new Re.ErrnoError(31);if(!r.stream_ops.read)throw new Re.ErrnoError(28);var i=\"undefined\"!==typeof o;if(i){if(!r.seekable)throw new Re.ErrnoError(70)}else o=r.position;var a=r.stream_ops.read(r,e,t,n,o);return i||(r.position+=a),a},write:function(r,e,t,n,o,i){if(n<0||o<0)throw new Re.ErrnoError(28);if(Re.isClosed(r))throw new Re.ErrnoError(8);if(0===(2097155&r.flags))throw new Re.ErrnoError(8);if(Re.isDir(r.node.mode))throw new Re.ErrnoError(31);if(!r.stream_ops.write)throw new Re.ErrnoError(28);r.seekable&&1024&r.flags&&Re.llseek(r,0,2);var a=\"undefined\"!==typeof o;if(a){if(!r.seekable)throw new Re.ErrnoError(70)}else o=r.position;var s=r.stream_ops.write(r,e,t,n,o,i);return a||(r.position+=s),s},allocate:function(r,e,t){if(Re.isClosed(r))throw new Re.ErrnoError(8);if(e<0||t<=0)throw new Re.ErrnoError(28);if(0===(2097155&r.flags))throw new Re.ErrnoError(8);if(!Re.isFile(r.node.mode)&&!Re.isDir(r.node.mode))throw new Re.ErrnoError(43);if(!r.stream_ops.allocate)throw new Re.ErrnoError(138);r.stream_ops.allocate(r,e,t)},mmap:function(r,e,t,n,o,i){if(0!==(2&o)&&0===(2&i)&&2!==(2097155&r.flags))throw new Re.ErrnoError(2);if(1===(2097155&r.flags))throw new Re.ErrnoError(2);if(!r.stream_ops.mmap)throw new Re.ErrnoError(43);return r.stream_ops.mmap(r,e,t,n,o,i)},msync:function(r,e,t,n,o){return r&&r.stream_ops.msync?r.stream_ops.msync(r,e,t,n,o):0},munmap:function(r){return 0},ioctl:function(r,e,t){if(!r.stream_ops.ioctl)throw new Re.ErrnoError(59);return r.stream_ops.ioctl(r,e,t)},readFile:function(r,e){if((e=e||{}).flags=e.flags||0,e.encoding=e.encoding||\"binary\",\"utf8\"!==e.encoding&&\"binary\"!==e.encoding)throw new Error('Invalid encoding type \"'+e.encoding+'\"');var t,n=Re.open(r,e.flags),o=Re.stat(r).size,i=new Uint8Array(o);return Re.read(n,i,0,o,0),\"utf8\"===e.encoding?t=g(i,0):\"binary\"===e.encoding&&(t=i),Re.close(n),t},writeFile:function(r,e,t){(t=t||{}).flags=t.flags||577;var n=Re.open(r,t.flags,t.mode);if(\"string\"===typeof e){var o=new Uint8Array(k(e)+1),i=_(e,o,0,o.length);Re.write(n,o,0,i,void 0,t.canOwn)}else{if(!ArrayBuffer.isView(e))throw new Error(\"Unsupported data type\");Re.write(n,e,0,e.byteLength,void 0,t.canOwn)}Re.close(n)},cwd:function(){return Re.currentPath},chdir:function(r){var e=Re.lookupPath(r,{follow:!0});if(null===e.node)throw new Re.ErrnoError(44);if(!Re.isDir(e.node.mode))throw new Re.ErrnoError(54);var t=Re.nodePermissions(e.node,\"x\");if(t)throw new Re.ErrnoError(t);Re.currentPath=e.path},createDefaultDirectories:function(){Re.mkdir(\"/tmp\"),Re.mkdir(\"/home\"),Re.mkdir(\"/home/web_user\")},createDefaultDevices:function(){Re.mkdir(\"/dev\"),Re.registerDevice(Re.makedev(1,3),{read:function(){return 0},write:function(r,e,t,n,o){return n}}),Re.mkdev(\"/dev/null\",Re.makedev(1,3)),Me.register(Re.makedev(5,0),Me.default_tty_ops),Me.register(Re.makedev(6,0),Me.default_tty1_ops),Re.mkdev(\"/dev/tty\",Re.makedev(5,0)),Re.mkdev(\"/dev/tty1\",Re.makedev(6,0));var r=function(){if(\"object\"===typeof crypto&&\"function\"===typeof crypto.getRandomValues){var r=new Uint8Array(1);return function(){return crypto.getRandomValues(r),r[0]}}return function(){K(\"randomDevice\")}}();Re.createDevice(\"/dev\",\"random\",r),Re.createDevice(\"/dev\",\"urandom\",r),Re.mkdir(\"/dev/shm\"),Re.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories:function(){Re.mkdir(\"/proc\");var r=Re.mkdir(\"/proc/self\");Re.mkdir(\"/proc/self/fd\"),Re.mount({mount:function(){var e=Re.createNode(r,\"fd\",16895,73);return e.node_ops={lookup:function(r,e){var t=+e,n=Re.getStream(t);if(!n)throw new Re.ErrnoError(8);var o={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:function(){return n.path}}};return o.parent=o,o}},e}},{},\"/proc/self/fd\")},createStandardStreams:function(){e.stdin?Re.createDevice(\"/dev\",\"stdin\",e.stdin):Re.symlink(\"/dev/tty\",\"/dev/stdin\"),e.stdout?Re.createDevice(\"/dev\",\"stdout\",null,e.stdout):Re.symlink(\"/dev/tty\",\"/dev/stdout\"),e.stderr?Re.createDevice(\"/dev\",\"stderr\",null,e.stderr):Re.symlink(\"/dev/tty1\",\"/dev/stderr\");Re.open(\"/dev/stdin\",0),Re.open(\"/dev/stdout\",1),Re.open(\"/dev/stderr\",1)},ensureErrnoError:function(){Re.ErrnoError||(Re.ErrnoError=function(r,e){this.node=e,this.setErrno=function(r){this.errno=r},this.setErrno(r),this.message=\"FS error\"},Re.ErrnoError.prototype=new Error,Re.ErrnoError.prototype.constructor=Re.ErrnoError,[44].forEach((function(r){Re.genericErrors[r]=new Re.ErrnoError(r),Re.genericErrors[r].stack=\"<generic error, no stack>\"})))},staticInit:function(){Re.ensureErrnoError(),Re.nameTable=new Array(4096),Re.mount(Oe,{},\"/\"),Re.createDefaultDirectories(),Re.createDefaultDevices(),Re.createSpecialDirectories(),Re.filesystems={MEMFS:Oe}},init:function(r,t,n){Re.init.initialized=!0,Re.ensureErrnoError(),e.stdin=r||e.stdin,e.stdout=t||e.stdout,e.stderr=n||e.stderr,Re.createStandardStreams()},quit:function(){Re.init.initialized=!1;var r=e._fflush;r&&r(0);for(var t=0;t<Re.streams.length;t++){var n=Re.streams[t];n&&Re.close(n)}},getMode:function(r,e){var t=0;return r&&(t|=365),e&&(t|=146),t},findObject:function(r,e){var t=Re.analyzePath(r,e);return t.exists?t.object:null},analyzePath:function(r,e){try{r=(n=Re.lookupPath(r,{follow:!e})).path}catch(o){}var t={isRoot:!1,exists:!1,error:0,name:null,path:null,object:null,parentExists:!1,parentPath:null,parentObject:null};try{var n=Re.lookupPath(r,{parent:!0});t.parentExists=!0,t.parentPath=n.path,t.parentObject=n.node,t.name=Se.basename(r),n=Re.lookupPath(r,{follow:!e}),t.exists=!0,t.path=n.path,t.object=n.node,t.name=n.node.name,t.isRoot=\"/\"===n.path}catch(o){t.error=o.errno}return t},createPath:function(r,e,t,n){r=\"string\"===typeof r?r:Re.getPath(r);for(var o=e.split(\"/\").reverse();o.length;){var i=o.pop();if(i){var a=Se.join2(r,i);try{Re.mkdir(a)}catch(s){}r=a}}return a},createFile:function(r,e,t,n,o){var i=Se.join2(\"string\"===typeof r?r:Re.getPath(r),e),a=Re.getMode(n,o);return Re.create(i,a)},createDataFile:function(r,e,t,n,o,i){var a=e?Se.join2(\"string\"===typeof r?r:Re.getPath(r),e):r,s=Re.getMode(n,o),u=Re.create(a,s);if(t){if(\"string\"===typeof t){for(var c=new Array(t.length),f=0,l=t.length;f<l;++f)c[f]=t.charCodeAt(f);t=c}Re.chmod(u,146|s);var d=Re.open(u,577);Re.write(d,t,0,t.length,0,i),Re.close(d),Re.chmod(u,s)}return u},createDevice:function(r,e,t,n){var o=Se.join2(\"string\"===typeof r?r:Re.getPath(r),e),i=Re.getMode(!!t,!!n);Re.createDevice.major||(Re.createDevice.major=64);var a=Re.makedev(Re.createDevice.major++,0);return Re.registerDevice(a,{open:function(r){r.seekable=!1},close:function(r){n&&n.buffer&&n.buffer.length&&n(10)},read:function(r,e,n,o,i){for(var a=0,s=0;s<o;s++){var u;try{u=t()}catch(c){throw new Re.ErrnoError(29)}if(void 0===u&&0===a)throw new Re.ErrnoError(6);if(null===u||void 0===u)break;a++,e[n+s]=u}return a&&(r.node.timestamp=Date.now()),a},write:function(r,e,t,o,i){for(var a=0;a<o;a++)try{n(e[t+a])}catch(s){throw new Re.ErrnoError(29)}return o&&(r.node.timestamp=Date.now()),a}}),Re.mkdev(o,i,a)},forceLoadFile:function(r){if(r.isDevice||r.isFolder||r.link||r.contents)return!0;if(\"undefined\"!==typeof XMLHttpRequest)throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");if(!a)throw new Error(\"Cannot load without read() or XMLHttpRequest.\");try{r.contents=Le(a(r.url),!0),r.usedBytes=r.contents.length}catch(e){throw new Re.ErrnoError(29)}},createLazyFile:function(r,e,t,n,o){function i(){this.lengthKnown=!1,this.chunks=[]}if(i.prototype.get=function(r){if(!(r>this.length-1||r<0)){var e=r%this.chunkSize,t=r/this.chunkSize|0;return this.getter(t)[e]}},i.prototype.setDataGetter=function(r){this.getter=r},i.prototype.cacheLength=function(){var r=new XMLHttpRequest;if(r.open(\"HEAD\",t,!1),r.send(null),!(r.status>=200&&r.status<300||304===r.status))throw new Error(\"Couldn't load \"+t+\". Status: \"+r.status);var e,n=Number(r.getResponseHeader(\"Content-length\")),o=(e=r.getResponseHeader(\"Accept-Ranges\"))&&\"bytes\"===e,i=(e=r.getResponseHeader(\"Content-Encoding\"))&&\"gzip\"===e,a=1048576;o||(a=n);var s=this;s.setDataGetter((function(r){var e=r*a,o=(r+1)*a-1;if(o=Math.min(o,n-1),\"undefined\"===typeof s.chunks[r]&&(s.chunks[r]=function(r,e){if(r>e)throw new Error(\"invalid range (\"+r+\", \"+e+\") or no bytes requested!\");if(e>n-1)throw new Error(\"only \"+n+\" bytes available! programmer error!\");var o=new XMLHttpRequest;if(o.open(\"GET\",t,!1),n!==a&&o.setRequestHeader(\"Range\",\"bytes=\"+r+\"-\"+e),\"undefined\"!=typeof Uint8Array&&(o.responseType=\"arraybuffer\"),o.overrideMimeType&&o.overrideMimeType(\"text/plain; charset=x-user-defined\"),o.send(null),!(o.status>=200&&o.status<300||304===o.status))throw new Error(\"Couldn't load \"+t+\". Status: \"+o.status);return void 0!==o.response?new Uint8Array(o.response||[]):Le(o.responseText||\"\",!0)}(e,o)),\"undefined\"===typeof s.chunks[r])throw new Error(\"doXHR failed!\");return s.chunks[r]})),!i&&n||(a=n=1,n=this.getter(0).length,a=n,d(\"LazyFiles on gzip forces download of the whole file when length is accessed\")),this._length=n,this._chunkSize=a,this.lengthKnown=!0},\"undefined\"!==typeof XMLHttpRequest)throw\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";var a={isDevice:!1,url:t},s=Re.createFile(r,e,a,n,o);a.contents?s.contents=a.contents:a.url&&(s.contents=null,s.url=a.url),Object.defineProperties(s,{usedBytes:{get:function(){return this.contents.length}}});var u={};return Object.keys(s.stream_ops).forEach((function(r){var e=s.stream_ops[r];u[r]=function(){return Re.forceLoadFile(s),e.apply(null,arguments)}})),u.read=function(r,e,t,n,o){Re.forceLoadFile(s);var i=r.node.contents;if(o>=i.length)return 0;var a=Math.min(i.length-o,n);if(i.slice)for(var u=0;u<a;u++)e[t+u]=i[o+u];else for(u=0;u<a;u++)e[t+u]=i.get(o+u);return a},s.stream_ops=u,s},createPreloadedFile:function(r,t,n,o,i,a,u,c,f,l){Browser.init();var d=t?$e.resolve(Se.join2(r,t)):r;function p(n){function s(e){l&&l(),c||Re.createDataFile(r,t,e,o,i,f),a&&a(),J()}var p=!1;e.preloadPlugins.forEach((function(r){p||r.canHandle(d)&&(r.handle(n,d,s,(function(){u&&u(),J()})),p=!0)})),p||s(n)}G(),\"string\"==typeof n?function(r,e,t,n){var o=n?\"\":\"al \"+r;s(r,(function(t){y(t,'Loading data file \"'+r+'\" failed (no arrayBuffer).'),e(new Uint8Array(t)),o&&J()}),(function(e){if(!t)throw'Loading data file \"'+r+'\" failed.';t()})),o&&G()}(n,(function(r){p(r)}),u):p(n)},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return\"EM_FS_\"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:function(r,e,t){e=e||function(){},t=t||function(){};var n=Re.indexedDB();try{var o=n.open(Re.DB_NAME(),Re.DB_VERSION)}catch(i){return t(i)}o.onupgradeneeded=function(){d(\"creating db\"),o.result.createObjectStore(Re.DB_STORE_NAME)},o.onsuccess=function(){var n=o.result.transaction([Re.DB_STORE_NAME],\"readwrite\"),i=n.objectStore(Re.DB_STORE_NAME),a=0,s=0,u=r.length;function c(){0==s?e():t()}r.forEach((function(r){var e=i.put(Re.analyzePath(r).object.contents,r);e.onsuccess=function(){++a+s==u&&c()},e.onerror=function(){s++,a+s==u&&c()}})),n.onerror=t},o.onerror=t},loadFilesFromDB:function(r,e,t){e=e||function(){},t=t||function(){};var n=Re.indexedDB();try{var o=n.open(Re.DB_NAME(),Re.DB_VERSION)}catch(i){return t(i)}o.onupgradeneeded=t,o.onsuccess=function(){var n=o.result;try{var a=n.transaction([Re.DB_STORE_NAME],\"readonly\")}catch(i){return void t(i)}var s=a.objectStore(Re.DB_STORE_NAME),u=0,c=0,f=r.length;function l(){0==c?e():t()}r.forEach((function(r){var e=s.get(r);e.onsuccess=function(){Re.analyzePath(r).exists&&Re.unlink(r),Re.createDataFile(Se.dirname(r),Se.basename(r),e.result,!0,!0,!0),++u+c==f&&l()},e.onerror=function(){c++,u+c==f&&l()}})),a.onerror=t},o.onerror=t}},je={mappings:{},DEFAULT_POLLMASK:5,calculateAt:function(r,e,t){if(\"/\"===e[0])return e;var n;if(-100===r)n=Re.cwd();else{var o=Re.getStream(r);if(!o)throw new Re.ErrnoError(8);n=o.path}if(0==e.length){if(!t)throw new Re.ErrnoError(44);return n}return Se.join2(n,e)},doStat:function(r,e,t){try{var n=r(e)}catch(o){if(o&&o.node&&Se.normalize(e)!==Se.normalize(Re.getPath(o.node)))return-54;throw o}return F[t>>2]=n.dev,F[t+4>>2]=0,F[t+8>>2]=n.ino,F[t+12>>2]=n.mode,F[t+16>>2]=n.nlink,F[t+20>>2]=n.uid,F[t+24>>2]=n.gid,F[t+28>>2]=n.rdev,F[t+32>>2]=0,er=[n.size>>>0,(rr=n.size,+Math.abs(rr)>=1?rr>0?(0|Math.min(+Math.floor(rr/4294967296),4294967295))>>>0:~~+Math.ceil((rr-+(~~rr>>>0))/4294967296)>>>0:0)],F[t+40>>2]=er[0],F[t+44>>2]=er[1],F[t+48>>2]=4096,F[t+52>>2]=n.blocks,F[t+56>>2]=n.atime.getTime()/1e3|0,F[t+60>>2]=0,F[t+64>>2]=n.mtime.getTime()/1e3|0,F[t+68>>2]=0,F[t+72>>2]=n.ctime.getTime()/1e3|0,F[t+76>>2]=0,er=[n.ino>>>0,(rr=n.ino,+Math.abs(rr)>=1?rr>0?(0|Math.min(+Math.floor(rr/4294967296),4294967295))>>>0:~~+Math.ceil((rr-+(~~rr>>>0))/4294967296)>>>0:0)],F[t+80>>2]=er[0],F[t+84>>2]=er[1],0},doMsync:function(r,e,t,n,o){var i=D.slice(r,r+t);Re.msync(e,i,o,t,n)},doMkdir:function(r,e){return\"/\"===(r=Se.normalize(r))[r.length-1]&&(r=r.substr(0,r.length-1)),Re.mkdir(r,e,0),0},doMknod:function(r,e,t){switch(61440&e){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28}return Re.mknod(r,e,t),0},doReadlink:function(r,e,t){if(t<=0)return-28;var n=Re.readlink(r),o=Math.min(t,k(n)),i=T[e+o];return b(n,e,t+1),T[e+o]=i,o},doAccess:function(r,e){if(-8&e)return-28;var t;if(!(t=Re.lookupPath(r,{follow:!0}).node))return-44;var n=\"\";return 4&e&&(n+=\"r\"),2&e&&(n+=\"w\"),1&e&&(n+=\"x\"),n&&Re.nodePermissions(t,n)?-2:0},doDup:function(r,e,t){var n=Re.getStream(t);return n&&Re.close(n),Re.open(r,e,0,t,t).fd},doReadv:function(r,e,t,n){for(var o=0,i=0;i<t;i++){var a=F[e+8*i>>2],s=F[e+(8*i+4)>>2],u=Re.read(r,T,a,s,n);if(u<0)return-1;if(o+=u,u<s)break}return o},doWritev:function(r,e,t,n){for(var o=0,i=0;i<t;i++){var a=F[e+8*i>>2],s=F[e+(8*i+4)>>2],u=Re.write(r,T,a,s,n);if(u<0)return-1;o+=u}return o},varargs:void 0,get:function(){return je.varargs+=4,F[je.varargs-4>>2]},getStr:function(r){return E(r)},getStreamFromFD:function(r){var e=Re.getStream(r);if(!e)throw new Re.ErrnoError(8);return e},get64:function(r,e){return r}};function xe(r){return r%4===0&&(r%100!==0||r%400===0)}function We(r,e){for(var t=0,n=0;n<=e;t+=r[n++]);return t}var Be=[31,29,31,30,31,30,31,31,30,31,30,31],Ne=[31,28,31,30,31,30,31,31,30,31,30,31];function ze(r,e){for(var t=new Date(r.getTime());e>0;){var n=xe(t.getFullYear()),o=t.getMonth(),i=(n?Be:Ne)[o];if(!(e>i-t.getDate()))return t.setDate(t.getDate()+e),t;e-=i-t.getDate()+1,t.setDate(1),o<11?t.setMonth(o+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return t}yr=e.InternalError=vr(Error,\"InternalError\"),function(){for(var r=new Array(256),e=0;e<256;++e)r[e]=String.fromCharCode(e);br=r}(),Pr=e.BindingError=vr(Error,\"BindingError\"),zr.prototype.isAliasOf=Cr,zr.prototype.clone=Or,zr.prototype.delete=Rr,zr.prototype.isDeleted=jr,zr.prototype.deleteLater=Nr,ae.prototype.getPointee=Gr,ae.prototype.destructor=Jr,ae.prototype.argPackAdvance=8,ae.prototype.readValueFromPointer=fr,ae.prototype.deleteObject=Kr,ae.prototype.fromWireType=ie,e.getInheritedInstanceCount=Qr,e.getLiveInheritedInstances=re,e.flushPendingDeletes=Br,e.setDelayFunction=ee,fe=e.UnboundTypeError=vr(Error,\"UnboundTypeError\"),e.count_emval_handles=ge,e.get_first_emval=Ee;var Ie=function(r,e,t,n){r||(r=this),this.parent=r,this.mount=r.mount,this.mounted=null,this.id=Re.nextInode++,this.name=e,this.mode=t,this.node_ops={},this.stream_ops={},this.rdev=n},Ue=365,He=146;function Le(r,e,t){var n=t>0?t:k(r)+1,o=new Array(n),i=_(r,o,0,o.length);return e&&(o.length=i),o}Object.defineProperties(Ie.prototype,{read:{get:function(){return(this.mode&Ue)===Ue},set:function(r){r?this.mode|=Ue:this.mode&=-366}},write:{get:function(){return(this.mode&He)===He},set:function(r){r?this.mode|=He:this.mode&=-147}},isFolder:{get:function(){return Re.isDir(this.mode)}},isDevice:{get:function(){return Re.isChrdev(this.mode)}}}),Re.FSNode=Ie,Re.staticInit();var Ve,Ye={d:function(r){return qe(r+16)+16},e:function(r,e,t){throw new sr(r).init(e,t),r,r},n:function(r){var e=ur[r];delete ur[r];var t=e.elements,n=t.length,o=t.map((function(r){return r.getterReturnType})).concat(t.map((function(r){return r.setterArgumentType}))),i=e.rawConstructor,a=e.rawDestructor;gr([r],o,(function(r){return t.forEach((function(e,t){var o=r[t],i=e.getter,a=e.getterContext,s=r[t+n],u=e.setter,c=e.setterContext;e.read=function(r){return o.fromWireType(i(a,r))},e.write=function(r,e){var t=[];u(c,r,s.toWireType(t,e)),cr(t)}})),[{name:e.name,fromWireType:function(r){for(var e=new Array(n),o=0;o<n;++o)e[o]=t[o].read(r);return a(r),e},toWireType:function(r,o){if(n!==o.length)throw new TypeError(\"Incorrect number of tuple elements for \"+e.name+\": expected=\"+n+\", actual=\"+o.length);for(var s=i(),u=0;u<n;++u)t[u].write(s,o[u]);return null!==r&&r.push(a,s),s},argPackAdvance:8,readValueFromPointer:fr,destructorFunction:a}]}))},p:function(r){var e=Er[r];delete Er[r];var t=e.rawConstructor,n=e.rawDestructor,o=e.fields;gr([r],o.map((function(r){return r.getterReturnType})).concat(o.map((function(r){return r.setterArgumentType}))),(function(r){var i={};return o.forEach((function(e,t){var n=e.fieldName,a=r[t],s=e.getter,u=e.getterContext,c=r[t+o.length],f=e.setter,l=e.setterContext;i[n]={read:function(r){return a.fromWireType(s(u,r))},write:function(r,e){var t=[];f(l,r,c.toWireType(t,e)),cr(t)}}})),[{name:e.name,fromWireType:function(r){var e={};for(var t in i)e[t]=i[t].read(r);return n(r),e},toWireType:function(r,e){for(var o in i)if(!(o in e))throw new TypeError('Missing field:  \"'+o+'\"');var a=t();for(o in i)i[o].write(a,e[o]);return null!==r&&r.push(n,a),a},argPackAdvance:8,readValueFromPointer:fr,destructorFunction:n}]}))},y:function(r,e,t,n,o){},I:function(r,e,t,n,o){var i=_r(t);Dr(r,{name:e=kr(e),fromWireType:function(r){return!!r},toWireType:function(r,e){return e?n:o},argPackAdvance:8,readValueFromPointer:function(r){var n;if(1===t)n=T;else if(2===t)n=C;else{if(4!==t)throw new TypeError(\"Unknown boolean type size: \"+e);n=F}return this.fromWireType(n[r>>i])},destructorFunction:null})},h:function(r,e,t,n,o,i,a,s,u,c,f,l,d){f=kr(f),i=ce(o,i),s&&(s=ce(a,s)),c&&(c=ce(u,c)),d=ce(l,d);var p=hr(f);Hr(p,(function(){de(\"Cannot construct \"+f+\" due to unbound types\",[n])})),gr([r,e,t],n?[n]:[],(function(e){var t,o;e=e[0],o=n?(t=e.registeredClass).instancePrototype:zr.prototype;var a=mr(p,(function(){if(Object.getPrototypeOf(this)!==u)throw new Pr(\"Use 'new' to construct \"+f);if(void 0===l.constructor_body)throw new Pr(f+\" has no accessible constructor\");var r=l.constructor_body[arguments.length];if(void 0===r)throw new Pr(\"Tried to invoke ctor of \"+f+\" with invalid number of parameters (\"+arguments.length+\") - expected (\"+Object.keys(l.constructor_body).toString()+\") parameters instead!\");return r.apply(this,arguments)})),u=Object.create(o,{constructor:{value:a}});a.prototype=u;var l=new Lr(f,a,u,d,t,i,s,c),h=new ae(f,l,!0,!1,!1),m=new ae(f+\"*\",l,!1,!1,!1),v=new ae(f+\" const*\",l,!1,!0,!1);return Ir[r]={pointerType:m,constPointerType:v},se(p,a),[h,m,v]}))},g:function(r,e,t,n,o,i){y(e>0);var a=pe(e,t);o=ce(n,o),gr([],[r],(function(r){var t=\"constructor \"+(r=r[0]).name;if(void 0===r.registeredClass.constructor_body&&(r.registeredClass.constructor_body=[]),void 0!==r.registeredClass.constructor_body[e-1])throw new Pr(\"Cannot register multiple constructors with identical number of parameters (\"+(e-1)+\") for class '\"+r.name+\"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");return r.registeredClass.constructor_body[e-1]=function(){de(\"Cannot construct \"+r.name+\" due to unbound types\",a)},gr([],a,(function(n){return n.splice(1,0,null),r.registeredClass.constructor_body[e-1]=he(t,n,null,o,i),[]})),[]}))},c:function(r,e,t,n,o,i,a,s){var u=pe(t,n);e=kr(e),i=ce(o,i),gr([],[r],(function(r){var n=(r=r[0]).name+\".\"+e;function o(){de(\"Cannot call \"+n+\" due to unbound types\",u)}e.startsWith(\"@@\")&&(e=Symbol[e.substring(2)]),s&&r.registeredClass.pureVirtualFunctions.push(e);var c=r.registeredClass.instancePrototype,f=c[e];return void 0===f||void 0===f.overloadTable&&f.className!==r.name&&f.argCount===t-2?(o.argCount=t-2,o.className=r.name,c[e]=o):(Ur(c,e,n),c[e].overloadTable[t-2]=o),gr([],u,(function(o){var s=he(n,o,r,i,a);return void 0===c[e].overloadTable?(s.argCount=t-2,c[e]=s):c[e].overloadTable[t-2]=s,[]})),[]}))},r:function(r,e,t,n,o,i,a,s,u,c){e=kr(e),o=ce(n,o),gr([],[r],(function(r){var n=(r=r[0]).name+\".\"+e,f={get:function(){de(\"Cannot access \"+n+\" due to unbound types\",[t,a])},enumerable:!0,configurable:!0};return f.set=u?function(){de(\"Cannot access \"+n+\" due to unbound types\",[t,a])}:function(r){Tr(n+\" is a read-only property\")},Object.defineProperty(r.registeredClass.instancePrototype,e,f),gr([],u?[t,a]:[t],(function(t){var a=t[0],f={get:function(){var e=me(this,r,n+\" getter\");return a.fromWireType(o(i,e))},enumerable:!0};if(u){u=ce(s,u);var l=t[1];f.set=function(e){var t=me(this,r,n+\" setter\"),o=[];u(c,t,l.toWireType(o,e)),cr(o)}}return Object.defineProperty(r.registeredClass.instancePrototype,e,f),[]})),[]}))},H:function(r,e){Dr(r,{name:e=kr(e),fromWireType:function(r){var e=_e.toValue(r);return we(r),e},toWireType:function(r,e){return _e.toHandle(e)},argPackAdvance:8,readValueFromPointer:fr,destructorFunction:null})},q:function(r,e,t,n){var o=_r(t);function i(){}e=kr(e),i.values={},Dr(r,{name:e,constructor:i,fromWireType:function(r){return this.constructor.values[r]},toWireType:function(r,e){return e.value},argPackAdvance:8,readValueFromPointer:be(e,o,n),destructorFunction:null}),Hr(e,i)},i:function(r,e,t){var n=ke(r,\"enum\");e=kr(e);var o=n.constructor,i=Object.create(n.constructor.prototype,{value:{value:t},constructor:{value:mr(n.name+\"_\"+e,(function(){}))}});o.values[t]=i,o[e]=i},v:function(r,e,t){var n=_r(t);Dr(r,{name:e=kr(e),fromWireType:function(r){return r},toWireType:function(r,e){if(\"number\"!==typeof e&&\"boolean\"!==typeof e)throw new TypeError('Cannot convert \"'+Pe(e)+'\" to '+this.name);return e},argPackAdvance:8,readValueFromPointer:Te(e,n),destructorFunction:null})},a:function(r,e,t,n,o,i){var a=pe(e,t);r=kr(r),o=ce(n,o),Hr(r,(function(){de(\"Cannot call \"+r+\" due to unbound types\",a)}),e-1),gr([],a,(function(t){var n=[t[0],null].concat(t.slice(1));return se(r,he(r,n,null,o,i),e-1),[]}))},k:function(r,e,t,n,o){e=kr(e),-1===o&&(o=4294967295);var i=_r(t),a=function(r){return r};if(0===n){var s=32-8*t;a=function(r){return r<<s>>>s}}var u=e.includes(\"unsigned\");Dr(r,{name:e,fromWireType:a,toWireType:function(r,t){if(\"number\"!==typeof t&&\"boolean\"!==typeof t)throw new TypeError('Cannot convert \"'+Pe(t)+'\" to '+this.name);if(t<n||t>o)throw new TypeError('Passing a number \"'+Pe(t)+'\" from JS side to C/C++ side to an argument of type \"'+e+'\", which is outside the valid range ['+n+\", \"+o+\"]!\");return u?t>>>0:0|t},argPackAdvance:8,readValueFromPointer:De(e,i,0!==n),destructorFunction:null})},j:function(r,e,t){var n=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][e];function o(r){var e=S,t=e[r>>=2],o=e[r+1];return new n(P,o,t)}Dr(r,{name:t=kr(t),fromWireType:o,argPackAdvance:8,readValueFromPointer:o},{ignoreDuplicateRegistrations:!0})},w:function(r,e){var t=\"std::string\"===(e=kr(e));Dr(r,{name:e,fromWireType:function(r){var e,n=S[r>>2];if(t)for(var o=r+4,i=0;i<=n;++i){var a=r+4+i;if(i==n||0==D[a]){var s=E(o,a-o);void 0===e?e=s:(e+=String.fromCharCode(0),e+=s),o=a+1}}else{var u=new Array(n);for(i=0;i<n;++i)u[i]=String.fromCharCode(D[r+4+i]);e=u.join(\"\")}return Xe(r),e},toWireType:function(r,e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var n=\"string\"===typeof e;n||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int8Array||Tr(\"Cannot pass non-string to std::string\");var o=(t&&n?function(){return k(e)}:function(){return e.length})(),i=qe(4+o+1);if(S[i>>2]=o,t&&n)b(e,i+4,o+1);else if(n)for(var a=0;a<o;++a){var s=e.charCodeAt(a);s>255&&(Xe(i),Tr(\"String has UTF-16 code units that do not fit in 8 bits\")),D[i+4+a]=s}else for(a=0;a<o;++a)D[i+4+a]=e[a];return null!==r&&r.push(Xe,i),i},argPackAdvance:8,readValueFromPointer:fr,destructorFunction:function(r){Xe(r)}})},t:function(r,e,t){var n,o,i,a,s;t=kr(t),2===e?(n=R,o=j,a=x,i=function(){return A},s=1):4===e&&(n=W,o=B,a=N,i=function(){return S},s=2),Dr(r,{name:t,fromWireType:function(r){for(var t,o=S[r>>2],a=i(),u=r+4,c=0;c<=o;++c){var f=r+4+c*e;if(c==o||0==a[f>>s]){var l=n(u,f-u);void 0===t?t=l:(t+=String.fromCharCode(0),t+=l),u=f+e}}return Xe(r),t},toWireType:function(r,n){\"string\"!==typeof n&&Tr(\"Cannot pass non-string to C++ string type \"+t);var i=a(n),u=qe(4+i+e);return S[u>>2]=i>>s,o(n,u+4,i+e),null!==r&&r.push(Xe,u),u},argPackAdvance:8,readValueFromPointer:fr,destructorFunction:function(r){Xe(r)}})},o:function(r,e,t,n,o,i){ur[r]={name:kr(e),rawConstructor:ce(t,n),rawDestructor:ce(o,i),elements:[]}},b:function(r,e,t,n,o,i,a,s,u){ur[r].elements.push({getterReturnType:e,getter:ce(t,n),getterContext:o,setterArgumentType:i,setter:ce(a,s),setterContext:u})},m:function(r,e,t,n,o,i){Er[r]={name:kr(e),rawConstructor:ce(t,n),rawDestructor:ce(o,i),fields:[]}},f:function(r,e,t,n,o,i,a,s,u,c){Er[r].fields.push({fieldName:kr(e),getterReturnType:t,getter:ce(n,o),getterContext:i,setterArgumentType:a,setter:ce(s,u),setterContext:c})},J:function(r,e){Dr(r,{isVoid:!0,name:e=kr(e),argPackAdvance:0,fromWireType:function(){},toWireType:function(r,e){}})},K:we,L:function(r){r>4&&(ye[r].refcount+=1)},l:function(r,e){var t=(r=ke(r,\"_emval_take_value\")).readValueFromPointer(e);return _e.toHandle(t)},u:function(){K(\"\")},A:function(r,e,t){D.copyWithin(r,e,e+t)},s:function(r){var e,t,n=D.length,o=2147483648;if((r>>>=0)>o)return!1;for(var i=1;i<=4;i*=2){var a=n*(1+.2/i);if(a=Math.min(a,r+100663296),Ce(Math.min(o,((e=Math.max(r,a))%(t=65536)>0&&(e+=t-e%t),e))))return!0}return!1},C:function(r,e){var t=0;return Fe().forEach((function(n,o){var i=e+t;F[r+4*o>>2]=i,function(r,e,t){for(var n=0;n<r.length;++n)T[e++>>0]=r.charCodeAt(n);t||(T[e>>0]=0)}(n,i),t+=n.length+1})),0},D:function(r,e){var t=Fe();F[r>>2]=t.length;var n=0;return t.forEach((function(r){n+=r.length+1})),F[e>>2]=n,0},G:function(r){try{var e=je.getStreamFromFD(r);return Re.close(e),0}catch(t){return\"undefined\"!==typeof Re&&t instanceof Re.ErrnoError||K(t),t.errno}},E:function(r,e,t,n){try{var o=je.getStreamFromFD(r),i=je.doReadv(o,e,t);return F[n>>2]=i,0}catch(a){return\"undefined\"!==typeof Re&&a instanceof Re.ErrnoError||K(a),a.errno}},x:function(r,e,t,n,o){try{var i=je.getStreamFromFD(r),a=4294967296*t+(e>>>0),s=9007199254740992;return a<=-s||a>=s?-61:(Re.llseek(i,a,n),er=[i.position>>>0,(rr=i.position,+Math.abs(rr)>=1?rr>0?(0|Math.min(+Math.floor(rr/4294967296),4294967295))>>>0:~~+Math.ceil((rr-+(~~rr>>>0))/4294967296)>>>0:0)],F[o>>2]=er[0],F[o+4>>2]=er[1],i.getdents&&0===a&&0===n&&(i.getdents=null),0)}catch(u){return\"undefined\"!==typeof Re&&u instanceof Re.ErrnoError||K(u),u.errno}},F:function(r,e,t,n){try{var o=je.getStreamFromFD(r),i=je.doWritev(o,e,t);return F[n>>2]=i,0}catch(a){return\"undefined\"!==typeof Re&&a instanceof Re.ErrnoError||K(a),a.errno}},z:function(r){r},B:function(r,e,t,n){return function(r,e,t,n){var o=F[n+40>>2],i={tm_sec:F[n>>2],tm_min:F[n+4>>2],tm_hour:F[n+8>>2],tm_mday:F[n+12>>2],tm_mon:F[n+16>>2],tm_year:F[n+20>>2],tm_wday:F[n+24>>2],tm_yday:F[n+28>>2],tm_isdst:F[n+32>>2],tm_gmtoff:F[n+36>>2],tm_zone:o?E(o):\"\"},a=E(t),s={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var u in s)a=a.replace(new RegExp(u,\"g\"),s[u]);var c=[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],f=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"];function l(r,e,t){for(var n=\"number\"===typeof r?r.toString():r||\"\";n.length<e;)n=t[0]+n;return n}function d(r,e){return l(r,e,\"0\")}function p(r,e){function t(r){return r<0?-1:r>0?1:0}var n;return 0===(n=t(r.getFullYear()-e.getFullYear()))&&0===(n=t(r.getMonth()-e.getMonth()))&&(n=t(r.getDate()-e.getDate())),n}function h(r){switch(r.getDay()){case 0:return new Date(r.getFullYear()-1,11,29);case 1:return r;case 2:return new Date(r.getFullYear(),0,3);case 3:return new Date(r.getFullYear(),0,2);case 4:return new Date(r.getFullYear(),0,1);case 5:return new Date(r.getFullYear()-1,11,31);case 6:return new Date(r.getFullYear()-1,11,30)}}function m(r){var e=ze(new Date(r.tm_year+1900,0,1),r.tm_yday),t=new Date(e.getFullYear(),0,4),n=new Date(e.getFullYear()+1,0,4),o=h(t),i=h(n);return p(o,e)<=0?p(i,e)<=0?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var v={\"%a\":function(r){return c[r.tm_wday].substring(0,3)},\"%A\":function(r){return c[r.tm_wday]},\"%b\":function(r){return f[r.tm_mon].substring(0,3)},\"%B\":function(r){return f[r.tm_mon]},\"%C\":function(r){return d((r.tm_year+1900)/100|0,2)},\"%d\":function(r){return d(r.tm_mday,2)},\"%e\":function(r){return l(r.tm_mday,2,\" \")},\"%g\":function(r){return m(r).toString().substring(2)},\"%G\":function(r){return m(r)},\"%H\":function(r){return d(r.tm_hour,2)},\"%I\":function(r){var e=r.tm_hour;return 0==e?e=12:e>12&&(e-=12),d(e,2)},\"%j\":function(r){return d(r.tm_mday+We(xe(r.tm_year+1900)?Be:Ne,r.tm_mon-1),3)},\"%m\":function(r){return d(r.tm_mon+1,2)},\"%M\":function(r){return d(r.tm_min,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(r){return r.tm_hour>=0&&r.tm_hour<12?\"AM\":\"PM\"},\"%S\":function(r){return d(r.tm_sec,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(r){return r.tm_wday||7},\"%U\":function(r){var e=new Date(r.tm_year+1900,0,1),t=0===e.getDay()?e:ze(e,7-e.getDay()),n=new Date(r.tm_year+1900,r.tm_mon,r.tm_mday);if(p(t,n)<0){var o=We(xe(n.getFullYear())?Be:Ne,n.getMonth()-1)-31,i=31-t.getDate()+o+n.getDate();return d(Math.ceil(i/7),2)}return 0===p(t,e)?\"01\":\"00\"},\"%V\":function(r){var e,t=new Date(r.tm_year+1900,0,4),n=new Date(r.tm_year+1901,0,4),o=h(t),i=h(n),a=ze(new Date(r.tm_year+1900,0,1),r.tm_yday);return p(a,o)<0?\"53\":p(i,a)<=0?\"01\":(e=o.getFullYear()<r.tm_year+1900?r.tm_yday+32-o.getDate():r.tm_yday+1-o.getDate(),d(Math.ceil(e/7),2))},\"%w\":function(r){return r.tm_wday},\"%W\":function(r){var e=new Date(r.tm_year,0,1),t=1===e.getDay()?e:ze(e,0===e.getDay()?1:7-e.getDay()+1),n=new Date(r.tm_year+1900,r.tm_mon,r.tm_mday);if(p(t,n)<0){var o=We(xe(n.getFullYear())?Be:Ne,n.getMonth()-1)-31,i=31-t.getDate()+o+n.getDate();return d(Math.ceil(i/7),2)}return 0===p(t,e)?\"01\":\"00\"},\"%y\":function(r){return(r.tm_year+1900).toString().substring(2)},\"%Y\":function(r){return r.tm_year+1900},\"%z\":function(r){var e=r.tm_gmtoff,t=e>=0;return e=(e=Math.abs(e)/60)/60*100+e%60,(t?\"+\":\"-\")+String(\"0000\"+e).slice(-4)},\"%Z\":function(r){return r.tm_zone},\"%%\":function(){return\"%\"}};for(var u in v)a.includes(u)&&(a=a.replace(new RegExp(u,\"g\"),v[u](i)));var y=Le(a,!1);return y.length>e?0:(z(y,r),y.length-1)}(r,e,t,n)}},qe=(function(){var r={a:Ye};function t(r,t){var n,o=r.exports;e.asm=o,I((m=e.asm.M).buffer),U=e.asm.O,n=e.asm.N,L.unshift(n),J()}function o(r){t(r.instance)}function i(e){return(h||\"function\"!==typeof fetch?Promise.resolve().then((function(){return nr(Z)})):fetch(Z,{credentials:\"same-origin\"}).then((function(r){if(!r.ok)throw\"failed to load wasm binary file at '\"+Z+\"'\";return r.arrayBuffer()})).catch((function(){return nr(Z)}))).then((function(e){return WebAssembly.instantiate(e,r)})).then((function(r){return r})).then(e,(function(r){p(\"failed to asynchronously prepare wasm: \"+r),K(r)}))}if(G(),e.instantiateWasm)try{return e.instantiateWasm(r,t)}catch(a){return p(\"Module.instantiateWasm callback failed with error: \"+a),!1}(h||\"function\"!==typeof WebAssembly.instantiateStreaming||tr(Z)||\"function\"!==typeof fetch?i(o):fetch(Z,{credentials:\"same-origin\"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(o,(function(r){return p(\"wasm streaming compile failed: \"+r),p(\"falling back to ArrayBuffer instantiation\"),i(o)}))}))).catch(n)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.N).apply(null,arguments)},e._malloc=function(){return(qe=e._malloc=e.asm.P).apply(null,arguments)}),Xe=e._free=function(){return(Xe=e._free=e.asm.Q).apply(null,arguments)},Ge=e.___getTypeName=function(){return(Ge=e.___getTypeName=e.asm.R).apply(null,arguments)},Je=(e.___embind_register_native_and_builtin_types=function(){return(e.___embind_register_native_and_builtin_types=e.asm.S).apply(null,arguments)},e.stackSave=function(){return(Je=e.stackSave=e.asm.T).apply(null,arguments)}),Ke=e.stackRestore=function(){return(Ke=e.stackRestore=e.asm.U).apply(null,arguments)},Ze=e.stackAlloc=function(){return(Ze=e.stackAlloc=e.asm.V).apply(null,arguments)};e.dynCall_jiji=function(){return(e.dynCall_jiji=e.asm.W).apply(null,arguments)},e.dynCall_iiiiij=function(){return(e.dynCall_iiiiij=e.asm.X).apply(null,arguments)},e.dynCall_iiiiijj=function(){return(e.dynCall_iiiiijj=e.asm.Y).apply(null,arguments)},e.dynCall_iiiiiijj=function(){return(e.dynCall_iiiiiijj=e.asm.Z).apply(null,arguments)},e.dynCall_viijii=function(){return(e.dynCall_viijii=e.asm._).apply(null,arguments)};function Qe(r){function n(){Ve||(Ve=!0,e.calledRun=!0,v||(!0,e.noFSInit||Re.init.initialized||Re.init(),Re.ignorePermissions=!1,Me.init(),or(L),t(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),function(){if(e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;)r=e.postRun.shift(),V.unshift(r);var r;or(V)}()))}r=r||c,Y>0||(!function(){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)r=e.preRun.shift(),H.unshift(r);var r;or(H)}(),Y>0||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),n()}),1)):n()))}if(e.ccall=function(r,t,n,o,i){var a={string:function(r){var e=0;if(null!==r&&void 0!==r&&0!==r){var t=1+(r.length<<2);b(r,e=Ze(t),t)}return e},array:function(r){var e=Ze(r.length);return z(r,e),e}},s=function(r){var t=e[\"_\"+r];return y(t,\"Cannot call unknown function \"+r+\", make sure it is exported\"),t}(r),u=[],c=0;if(o)for(var f=0;f<o.length;f++){var l=a[n[f]];l?(0===c&&(c=Je()),u[f]=l(o[f])):u[f]=o[f]}var d=s.apply(null,u);return d=function(r){return 0!==c&&Ke(c),function(r){return\"string\"===t?E(r):\"boolean\"===t?Boolean(r):r}(r)}(d)},X=function r(){Ve||Qe(),Ve||(X=r)},e.run=Qe,e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();return Qe(),e.ready}}();e.default=n}}]);","name":"static/js/6.77b84f76.chunk.js","map":{"version":3,"names":["window","push","module","__webpack_exports__","__webpack_require__","r","Module","_scriptDir","document","currentScript","src","undefined","readyPromiseResolve","readyPromiseReject","Promise","resolve","reject","key","moduleOverrides","hasOwnProperty","read_","readAsync","readBinary","arguments_","thisProgram","scriptDirectory","indexOf","substr","replace","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","onload","onerror","responseType","status","response","out","console","log","bind","err","warn","wasmBinary","wasmMemory","WebAssembly","abort","ABORT","assert","condition","text","UTF8Decoder","TextDecoder","UTF8ArrayToString","heap","idx","maxBytesToRead","endIdx","endPtr","subarray","decode","str","u0","u1","u2","String","fromCharCode","ch","UTF8ToString","ptr","HEAPU8","stringToUTF8Array","outIdx","maxBytesToWrite","startIdx","i","length","u","charCodeAt","stringToUTF8","outPtr","lengthBytesUTF8","len","buffer","HEAP8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","lengthBytesUTF32","writeArrayToMemory","array","set","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","wasmTable","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","runDependencies","runDependencyWatcher","dependenciesFulfilled","addRunDependency","id","removeRunDependency","clearInterval","callback","what","e","RuntimeError","wasmBinaryFile","path","tempDouble","tempI64","isDataURI","filename","startsWith","getBinary","file","callRuntimeCallbacks","callbacks","shift","func","arg","getWasmTableEntry","wasmTableMirror","funcPtr","get","ExceptionInfo","excPtr","this","set_type","type","get_type","set_destructor","destructor","get_destructor","set_refcount","refcount","set_caught","caught","get_caught","set_rethrown","rethrown","get_rethrown","init","add_ref","value","release_ref","prev","tupleRegistrations","runDestructors","destructors","pop","del","simpleReadValueFromPointer","pointer","awaitingDependencies","registeredTypes","typeDependencies","makeLegalFunctionName","name","f","createNamedFunction","body","Function","extendError","baseErrorType","errorName","errorClass","message","stack","Error","toString","prototype","Object","create","constructor","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","forEach","Array","unregisteredTypes","registered","dt","structRegistrations","getShiftFromSize","size","TypeError","embind_charCodes","readLatin1String","ret","c","BindingError","throwBindingError","rawType","registeredInstance","options","ignoreDuplicateRegistrations","cb","ClassHandle_isAliasOf","other","ClassHandle","leftClass","$$","ptrType","registeredClass","left","rightClass","right","baseClass","upcast","throwInstanceAlreadyDeleted","obj","finalizationRegistry","detachFinalizer","handle","releaseClassHandle","count","smartPtr","smartPtrType","rawDestructor","runDestructor","attachFinalizer","FinalizationRegistry","info","register","unregister","ClassHandle_clone","preservePointerOnDelete","o","clone","getPrototypeOf","deleteScheduled","ClassHandle_delete","ClassHandle_isDeleted","delayFunction","deletionQueue","flushPendingDeletes","ClassHandle_deleteLater","registeredPointers","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","arguments","apply","argCount","exposePublicSymbol","numArguments","RegisteredClass","instancePrototype","getActualType","downcast","pureVirtualFunctions","upcastPointer","ptrClass","desiredClass","constNoSmartPtrRawPointerToWireType","isReference","_embind_repr","handleClass","genericPointerToWireType","isSmartPointer","rawConstructor","isConst","sharingPolicy","clonedHandle","rawShare","Emval","toHandle","nonConstNoSmartPtrRawPointerToWireType","RegisteredPointer_getPointee","rawGetPointee","RegisteredPointer_destructor","RegisteredPointer_deleteObject","downcastPointer","rv","getInheritedInstanceCount","keys","registeredInstances","getLiveInheritedInstances","k","setDelayFunction","fn","getInheritedInstance","class_","getBasestPointer","makeClassHandle","record","RegisteredPointer_fromWireType","rawPointer","getPointee","makeDefaultHandle","pointeeType","toType","actualType","registeredPointerRecord","call","constPointerType","pointerType","dp","RegisteredPointer","destructorFunction","replacePublicSymbol","dynCall","sig","args","includes","concat","dynCallLegacy","embind__requireFunction","signature","rawFunction","fp","argCache","getDynCaller","UnboundTypeError","getTypeName","___getTypeName","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","map","join","heap32VectorToArray","firstElement","craftInvokerFunction","argTypes","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","argumentList","dummy","new_","validateThis","this_","emval_free_list","emval_handle_array","__emval_decref","count_emval_handles","get_first_emval","toValue","enumReadValueFromPointer","signed","requireRegisteredType","impl","v","t","floatReadValueFromPointer","integerReadValueFromPointer","emscripten_realloc_buffer","grow","byteLength","ENV","getEnvStrings","strings","env","USER","LOGNAME","PATH","PWD","HOME","LANG","navigator","languages","_","x","splitPath","exec","slice","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","normalize","isAbsolute","charAt","trailingSlash","split","filter","p","dirname","result","root","dir","basename","lastSlash","extname","paths","join2","l","PATH_FS","resolvedPath","resolvedAbsolute","FS","cwd","relative","from","to","trim","arr","start","end","fromParts","toParts","Math","min","samePartsLength","outputParts","TTY","ttys","shutdown","dev","ops","input","output","registerDevice","stream_ops","stream","tty","node","rdev","ErrnoError","seekable","close","flush","read","offset","pos","get_char","bytesRead","timestamp","Date","now","write","put_char","default_tty_ops","prompt","readline","intArrayFromString","val","default_tty1_ops","MEMFS","ops_table","mount","_mount","createNode","parent","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","allocate","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","max","oldContents","resizeFileStorage","newSize","attr","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","ceil","genericErrors","old_node","new_dir","new_name","new_node","lookupNode","entries","newname","oldpath","position","canOwn","whence","address","prot","flags","allocated","byteOffset","mmapFlags","mounts","devices","streams","nextInode","nameTable","currentPath","initialized","ignorePermissions","filesystems","syncFSRequests","lookupPath","opts","defaults","follow_mount","recurse_count","current","current_path","islast","isMountpoint","mounted","follow","getPath","isRoot","mountpoint","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","errCode","mayLookup","nodeName","FSNode","destroyNode","isSocket","flagModes","w","a","modeStringToFlags","flagsToPermissionString","flag","perms","nodePermissions","mayCreate","mayDelete","isdir","errno","mayOpen","MAX_OPEN_FDS","nextfd","fd_start","fd_end","fd","getStream","createStream","FSStream","object","isRead","isWrite","isAppend","newStream","closeStream","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","syncfs","populate","completed","doCallback","done","errored","pseudo","mountRoot","unmount","next","mkdir","mkdirTree","dirs","d","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","lstat","chmod","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","utime","created","ungotten","error","readFiles","isClosed","getdents","seeking","bytesWritten","munmap","ioctl","cmd","readFile","encoding","writeFile","data","actualNumBytes","ArrayBuffer","isView","chdir","createDefaultDirectories","createDefaultDevices","random_device","crypto","randomBuffer","getRandomValues","getRandomDevice","createDevice","createSpecialDirectories","proc_self","createStandardStreams","ensureErrnoError","setErrno","code","staticInit","quit","fflush","getMode","canRead","canWrite","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","createDataFile","forceLoadFile","isDevice","isFolder","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","getter","setDataGetter","cacheLength","header","datalength","Number","getResponseHeader","hasByteServing","usesGzip","lazyArray","setRequestHeader","overrideMimeType","doXHR","_length","_chunkSize","defineProperties","createPreloadedFile","dontCreateFile","preFinish","Browser","fullname","processData","byteArray","finish","handled","plugin","noRunDep","dep","arrayBuffer","event","asyncLoad","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","DB_NAME","location","pathname","DB_VERSION","DB_STORE_NAME","saveFilesToDB","openRequest","onupgradeneeded","createObjectStore","onsuccess","transaction","files","objectStore","ok","fail","total","putRequest","put","loadFilesFromDB","db","getRequest","SYSCALLS","mappings","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","dirstream","doStat","abs","floor","getTime","doMsync","addr","doMkdir","doMknod","doReadlink","bufsize","endChar","doAccess","amode","doDup","suggestFD","suggest","doReadv","iov","iovcnt","curr","doWritev","varargs","getStr","getStreamFromFD","get64","low","high","__isLeapYear","year","__arraySum","index","sum","__MONTH_DAYS_LEAP","__MONTH_DAYS_REGULAR","__addDays","date","days","newDate","leap","getFullYear","currentMonth","getMonth","daysInCurrentMonth","getDate","setDate","setMonth","setFullYear","codes","embind_init_charCodes","readMode","writeMode","stringy","dontAddNull","u8array","numBytesWritten","calledRun","asmLibraryArg","_malloc","n","rawTupleType","reg","elements","elementsLength","elementTypes","elt","getterReturnType","setterArgumentType","getterContext","setter","setterContext","fromWireType","toWireType","argPackAdvance","readValueFromPointer","structType","fieldRecords","fields","field","fieldTypes","fieldName","y","primitiveType","minRange","maxRange","I","trueValue","falseValue","wt","h","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","referenceConverter","pointerConverter","constPointerConverter","g","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","rawInvoker","context","isPureVirtual","unboundTypesHandler","Symbol","substring","method","className","memberFunction","getterSignature","setterSignature","desc","enumerable","configurable","defineProperty","H","q","isSigned","ctor","values","rawEnumType","enumValue","enumType","Enum","Value","invokerArgsArray","bitshift","isUnsignedType","j","dataTypeIndex","TA","decodeMemoryView","stdStringIsUTF8","decodeStartPtr","currentBytePtr","stringSegment","valueIsOfTypeString","Uint8ClampedArray","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","constructorSignature","b","J","isVoid","K","L","argv","A","dest","num","copyWithin","s","requestedSize","multiple","oldSize","maxHeapSize","cutDown","overGrownHeapSize","C","__environ","environ_buf","bufSize","string","writeAsciiToMemory","D","penviron_count","penviron_buf_size","G","E","pnum","offset_low","offset_high","newOffset","DOUBLE_LIMIT","F","z","B","maxsize","format","tm","tm_zone","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","rule","RegExp","WEEKDAYS","MONTHS","leadingSomething","digits","character","leadingNulls","compareByDay","date1","date2","sgn","compare","getFirstWeekStartDate","janFourth","getDay","getWeekBasedYear","thisDate","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","twelveHour","janFirst","firstSunday","endDate","februaryFirstUntilEndMonth","daysDifference","firstMonday","off","ahead","bytes","_strftime","receiveInstance","instance","exports","receiveInstantiationResult","instantiateArrayBuffer","receiver","fetch","then","credentials","catch","binary","instantiate","reason","instantiateStreaming","createWasm","stackSave","stackRestore","stackAlloc","run","doRun","postRun","preRun","setTimeout","ident","returnType","toC","getCFunc","cArgs","converter","Boolean","convertReturnValue","onDone","runCaller","ready"],"sources":["static/js/6.77b84f76.chunk.js"],"mappings":"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"},"input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[6],{\n\n/***/ 199:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return function (Module) {\n    Module = Module || {};\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = {};\n    var key;\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readAsync, readBinary, setWindowTitle;\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document !== \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n      {\n        read_ = function read_(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary(url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n        readAsync = function readAsync(url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = function () {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n      setWindowTitle = function setWindowTitle(title) {\n        document.title = title;\n      };\n    } else {}\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var tempRet0 = 0;\n    var setTempRet0 = function setTempRet0(value) {\n      tempRet0 = value;\n    };\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    if (typeof WebAssembly !== \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n    function getCFunc(ident) {\n      var func = Module[\"_\" + ident];\n      assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n      return func;\n    }\n    function ccall(ident, returnType, argTypes, args, opts) {\n      var toC = {\n        \"string\": function string(str) {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len);\n          }\n          return ret;\n        },\n        \"array\": function array(arr) {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n      function convertReturnValue(ret) {\n        if (returnType === \"string\") return UTF8ToString(ret);\n        if (returnType === \"boolean\") return Boolean(ret);\n        return ret;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n      ret = onDone(ret);\n      return ret;\n    }\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n    function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heap[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n        while (idx < endPtr) {\n          var u0 = heap[idx++];\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n          var u1 = heap[idx++] & 63;\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n          var u2 = heap[idx++] & 63;\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n          }\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n      return str;\n    }\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n    function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\n      }\n      return len;\n    }\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n    function UTF16ToString(ptr, maxBytesToRead) {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) {\n        ++idx;\n      }\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var str = \"\";\n        for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) break;\n          str += String.fromCharCode(codeUnit);\n        }\n        return str;\n      }\n    }\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n    function UTF32ToString(ptr, maxBytesToRead) {\n      var i = 0;\n      var str = \"\";\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    }\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF32(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    }\n    function writeArrayToMemory(array, buffer) {\n      HEAP8.set(array, buffer);\n    }\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      }\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n      return x;\n    }\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n    var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n    var wasmTable;\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n      FS.ignorePermissions = false;\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    function abort(what) {\n      {\n        if (Module[\"onAbort\"]) {\n          Module[\"onAbort\"](what);\n        }\n      }\n      what = \"Aborted(\" + what + \")\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += \". Build with -s ASSERTIONS=1 for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n    var wasmBinaryFile;\n    wasmBinaryFile = \"process.wasm\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n    function getBinary(file) {\n      try {\n        if (file == wasmBinaryFile && wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n        if (readBinary) {\n          return readBinary(file);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n            return response[\"arrayBuffer\"]();\n          }).catch(function () {\n            return getBinary(wasmBinaryFile);\n          });\n        }\n      }\n      return Promise.resolve().then(function () {\n        return getBinary(wasmBinaryFile);\n      });\n    }\n    function createWasm() {\n      var info = {\n        \"a\": asmLibraryArg\n      };\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        wasmMemory = Module[\"asm\"][\"M\"];\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        wasmTable = Module[\"asm\"][\"O\"];\n        addOnInit(Module[\"asm\"][\"N\"]);\n        removeRunDependency(\"wasm-instantiate\");\n      }\n      addRunDependency(\"wasm-instantiate\");\n      function receiveInstantiationResult(result) {\n        receiveInstance(result[\"instance\"]);\n      }\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(function (instance) {\n          return instance;\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err(\"wasm streaming compile failed: \" + reason);\n              err(\"falling back to ArrayBuffer instantiation\");\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiationResult);\n        }\n      }\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n      instantiateAsync().catch(readyPromiseReject);\n      return {};\n    }\n    var tempDouble;\n    var tempI64;\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == \"function\") {\n          callback(Module);\n          continue;\n        }\n        var func = callback.func;\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            getWasmTableEntry(func)();\n          } else {\n            getWasmTableEntry(func)(callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n    var wasmTableMirror = [];\n    function getWasmTableEntry(funcPtr) {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      return func;\n    }\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size + 16) + 16;\n    }\n    function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 16;\n      this.set_type = function (type) {\n        HEAP32[this.ptr + 4 >> 2] = type;\n      };\n      this.get_type = function () {\n        return HEAP32[this.ptr + 4 >> 2];\n      };\n      this.set_destructor = function (destructor) {\n        HEAP32[this.ptr + 8 >> 2] = destructor;\n      };\n      this.get_destructor = function () {\n        return HEAP32[this.ptr + 8 >> 2];\n      };\n      this.set_refcount = function (refcount) {\n        HEAP32[this.ptr >> 2] = refcount;\n      };\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[this.ptr + 12 >> 0] = caught;\n      };\n      this.get_caught = function () {\n        return HEAP8[this.ptr + 12 >> 0] != 0;\n      };\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[this.ptr + 13 >> 0] = rethrown;\n      };\n      this.get_rethrown = function () {\n        return HEAP8[this.ptr + 13 >> 0] != 0;\n      };\n      this.init = function (type, destructor) {\n        this.set_type(type);\n        this.set_destructor(destructor);\n        this.set_refcount(0);\n        this.set_caught(false);\n        this.set_rethrown(false);\n      };\n      this.add_ref = function () {\n        var value = HEAP32[this.ptr >> 2];\n        HEAP32[this.ptr >> 2] = value + 1;\n      };\n      this.release_ref = function () {\n        var prev = HEAP32[this.ptr >> 2];\n        HEAP32[this.ptr >> 2] = prev - 1;\n        return prev === 1;\n      };\n    }\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n    function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw ptr;\n    }\n    var tupleRegistrations = {};\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n    }\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n    function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return \"_unknown\";\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return \"_\" + name;\n      } else {\n        return name;\n      }\n    }\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n    }\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + \": \" + this.message;\n        }\n      };\n      return errorClass;\n    }\n    var InternalError = undefined;\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function (dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(function () {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n    function __embind_finalize_value_array(rawTupleType) {\n      var reg = tupleRegistrations[rawTupleType];\n      delete tupleRegistrations[rawTupleType];\n      var elements = reg.elements;\n      var elementsLength = elements.length;\n      var elementTypes = elements.map(function (elt) {\n        return elt.getterReturnType;\n      }).concat(elements.map(function (elt) {\n        return elt.setterArgumentType;\n      }));\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      whenDependentTypesAreResolved([rawTupleType], elementTypes, function (elementTypes) {\n        elements.forEach(function (elt, i) {\n          var getterReturnType = elementTypes[i];\n          var getter = elt.getter;\n          var getterContext = elt.getterContext;\n          var setterArgumentType = elementTypes[i + elementsLength];\n          var setter = elt.setter;\n          var setterContext = elt.setterContext;\n          elt.read = function (ptr) {\n            return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n          };\n          elt.write = function (ptr, o) {\n            var destructors = [];\n            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n            runDestructors(destructors);\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": function fromWireType(ptr) {\n            var rv = new Array(elementsLength);\n            for (var i = 0; i < elementsLength; ++i) {\n              rv[i] = elements[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": function toWireType(destructors, o) {\n            if (elementsLength !== o.length) {\n              throw new TypeError(\"Incorrect number of tuple elements for \" + reg.name + \": expected=\" + elementsLength + \", actual=\" + o.length);\n            }\n            var ptr = rawConstructor();\n            for (var i = 0; i < elementsLength; ++i) {\n              elements[i].write(ptr, o[i]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          \"argPackAdvance\": 8,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    }\n    var structRegistrations = {};\n    function __embind_finalize_value_object(structType) {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords.map(function (field) {\n        return field.getterReturnType;\n      }).concat(fieldRecords.map(function (field) {\n        return field.setterArgumentType;\n      }));\n      whenDependentTypesAreResolved([structType], fieldTypes, function (fieldTypes) {\n        var fields = {};\n        fieldRecords.forEach(function (field, i) {\n          var fieldName = field.fieldName;\n          var getterReturnType = fieldTypes[i];\n          var getter = field.getter;\n          var getterContext = field.getterContext;\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\n          var setter = field.setter;\n          var setterContext = field.setterContext;\n          fields[fieldName] = {\n            read: function read(ptr) {\n              return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n            },\n            write: function write(ptr, o) {\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n              runDestructors(destructors);\n            }\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": function fromWireType(ptr) {\n            var rv = {};\n            for (var i in fields) {\n              rv[i] = fields[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": function toWireType(destructors, o) {\n            for (var fieldName in fields) {\n              if (!(fieldName in o)) {\n                throw new TypeError('Missing field:  \"' + fieldName + '\"');\n              }\n            }\n            var ptr = rawConstructor();\n            for (fieldName in fields) {\n              fields[fieldName].write(ptr, o[fieldName]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          \"argPackAdvance\": 8,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    }\n    function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(\"Unknown type size: \" + size);\n      }\n    }\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }\n    var embind_charCodes = undefined;\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n    var BindingError = undefined;\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n    function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      }\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function (cb) {\n          cb();\n        });\n      }\n    }\n    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(wt) {\n          return !!wt;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": function readValueFromPointer(pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n          return this[\"fromWireType\"](heap[pointer >> shift]);\n        },\n        destructorFunction: null\n      });\n    }\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n      return leftClass === rightClass && left === right;\n    }\n    function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType\n      };\n    }\n    function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n    }\n    var finalizationRegistry = false;\n    function detachFinalizer(handle) {}\n    function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n    function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n    function attachFinalizer(handle) {\n      if (\"undefined\" === typeof FinalizationRegistry) {\n        attachFinalizer = function attachFinalizer(handle) {\n          return handle;\n        };\n        return handle;\n      }\n      finalizationRegistry = new FinalizationRegistry(function (info) {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = function attachFinalizer(handle) {\n        var $$ = handle.$$;\n        var info = {\n          $$: $$\n        };\n        finalizationRegistry.register(handle, info, handle);\n        return handle;\n      };\n      detachFinalizer = function detachFinalizer(handle) {\n        finalizationRegistry.unregister(handle);\n      };\n      return attachFinalizer(handle);\n    }\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: shallowCopyInternalPointer(this.$$)\n          }\n        }));\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n    var delayFunction = undefined;\n    var deletionQueue = [];\n    function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj[\"delete\"]();\n      }\n    }\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n    function init_ClassHandle() {\n      ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n      ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n      ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n      ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n      ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n    }\n    function ClassHandle() {}\n    var registeredPointers = {};\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n    function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    }\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n            }\n            break;\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle[\"clone\"]();\n              ptr = this.rawShare(ptr, Emval.toHandle(function () {\n                clonedHandle[\"delete\"]();\n              }));\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n          default:\n            throwBindingError(\"Unsupporting sharing policy\");\n        }\n      }\n      return ptr;\n    }\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n    function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle[\"delete\"]();\n      }\n    }\n    function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    }\n    function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n    function getLiveInheritedInstances() {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    }\n    function setDelayFunction(fn) {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n    function init_embind() {\n      Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n      Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n      Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n      Module[\"setDelayFunction\"] = setDelayFunction;\n    }\n    var registeredInstances = {};\n    function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n        throwBindingError(\"ptr should not be undefined\");\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    }\n    function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n    function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n      }\n      record.count = {\n        value: 1\n      };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record\n        }\n      }));\n    }\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance[\"clone\"]();\n        } else {\n          var rv = registeredInstance[\"clone\"]();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr\n          });\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n    function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n      RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n    }\n    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this[\"toWireType\"] = genericPointerToWireType;\n      }\n    }\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n    function dynCallLegacy(sig, ptr, args) {\n      var f = Module[\"dynCall_\" + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    }\n    function dynCall(sig, ptr, args) {\n      if (sig.includes(\"j\")) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      return getWasmTableEntry(ptr).apply(null, args);\n    }\n    function getDynCaller(sig, ptr) {\n      var argCache = [];\n      return function () {\n        argCache.length = arguments.length;\n        for (var i = 0; i < arguments.length; i++) {\n          argCache[i] = arguments[i];\n        }\n        return dynCall(sig, ptr, argCache);\n      };\n    }\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes(\"j\")) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp !== \"function\") {\n        throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n    var UnboundTypeError = undefined;\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\", \"]));\n    }\n    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n          var body = registeredClass.constructor_body[arguments.length];\n          if (undefined === body) {\n            throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n          }\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor\n          }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    }\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n      return array;\n    }\n    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = \"constructor \" + classType.name;\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n          throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n          return [];\n        });\n        return [];\n      });\n    }\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n      }\n      var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n      var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n      invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n      } else {}\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    function validateThis(this_, classType, humanName) {\n      if (!(this_ instanceof Object)) {\n        throwBindingError(humanName + ' with invalid \"this\": ' + this_);\n      }\n      if (!(this_ instanceof classType.registeredClass.constructor)) {\n        throwBindingError(humanName + ' incompatible with \"this\" of type ' + this_.constructor.name);\n      }\n      if (!this_.$$.ptr) {\n        throwBindingError(\"cannot call emscripten binding method \" + humanName + \" on deleted object\");\n      }\n      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n    }\n    function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      fieldName = readLatin1String(fieldName);\n      getter = embind__requireFunction(getterSignature, getter);\n      whenDependentTypesAreResolved([], [classType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + fieldName;\n        var desc = {\n          get: function get() {\n            throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [getterReturnType, setterArgumentType]);\n          },\n          enumerable: true,\n          configurable: true\n        };\n        if (setter) {\n          desc.set = function () {\n            throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [getterReturnType, setterArgumentType]);\n          };\n        } else {\n          desc.set = function (v) {\n            throwBindingError(humanName + \" is a read-only property\");\n          };\n        }\n        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function (types) {\n          var getterReturnType = types[0];\n          var desc = {\n            get: function get() {\n              var ptr = validateThis(this, classType, humanName + \" getter\");\n              return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n            },\n            enumerable: true\n          };\n          if (setter) {\n            setter = embind__requireFunction(setterSignature, setter);\n            var setterArgumentType = types[1];\n            desc.set = function (v) {\n              var ptr = validateThis(this, classType, humanName + \" setter\");\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n              runDestructors(destructors);\n            };\n          }\n          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n          return [];\n        });\n        return [];\n      });\n    }\n    var emval_free_list = [];\n    var emval_handle_array = [{}, {\n      value: undefined\n    }, {\n      value: null\n    }, {\n      value: true\n    }, {\n      value: false\n    }];\n    function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n    function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    }\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n      return null;\n    }\n    function init_emval() {\n      Module[\"count_emval_handles\"] = count_emval_handles;\n      Module[\"get_first_emval\"] = get_first_emval;\n    }\n    var Emval = {\n      toValue: function toValue(handle) {\n        if (!handle) {\n          throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n        }\n        return emval_handle_array[handle].value;\n      },\n      toHandle: function toHandle(value) {\n        switch (value) {\n          case undefined:\n            {\n              return 1;\n            }\n          case null:\n            {\n              return 2;\n            }\n          case true:\n            {\n              return 3;\n            }\n          case false:\n            {\n              return 4;\n            }\n          default:\n            {\n              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n              emval_handle_array[handle] = {\n                refcount: 1,\n                value: value\n              };\n              return handle;\n            }\n        }\n      }\n    };\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(handle) {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          return Emval.toHandle(value);\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    }\n    function enumReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return function (pointer) {\n            var heap = signed ? HEAP8 : HEAPU8;\n            return this[\"fromWireType\"](heap[pointer]);\n          };\n        case 1:\n          return function (pointer) {\n            var heap = signed ? HEAP16 : HEAPU16;\n            return this[\"fromWireType\"](heap[pointer >> 1]);\n          };\n        case 2:\n          return function (pointer) {\n            var heap = signed ? HEAP32 : HEAPU32;\n            return this[\"fromWireType\"](heap[pointer >> 2]);\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_enum(rawType, name, size, isSigned) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      function ctor() {}\n      ctor.values = {};\n      registerType(rawType, {\n        name: name,\n        constructor: ctor,\n        \"fromWireType\": function fromWireType(c) {\n          return this.constructor.values[c];\n        },\n        \"toWireType\": function toWireType(destructors, c) {\n          return c.value;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": enumReadValueFromPointer(name, shift, isSigned),\n        destructorFunction: null\n      });\n      exposePublicSymbol(name, ctor);\n    }\n    function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n      return impl;\n    }\n    function __embind_register_enum_value(rawEnumType, name, enumValue) {\n      var enumType = requireRegisteredType(rawEnumType, \"enum\");\n      name = readLatin1String(name);\n      var Enum = enumType.constructor;\n      var Value = Object.create(enumType.constructor.prototype, {\n        value: {\n          value: enumValue\n        },\n        constructor: {\n          value: createNamedFunction(enumType.name + \"_\" + name, function () {})\n        }\n      });\n      Enum.values[enumValue] = Value;\n      Enum[name] = Value;\n    }\n    function _embind_repr(v) {\n      if (v === null) {\n        return \"null\";\n      }\n      var t = typeof v;\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    }\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n        case 3:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          return value;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n          return value;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(name, function () {\n        throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n      }, argCount - 1);\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n        return [];\n      });\n    }\n    function integerReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return signed ? function readS8FromPointer(pointer) {\n            return HEAP8[pointer];\n          } : function readU8FromPointer(pointer) {\n            return HEAPU8[pointer];\n          };\n        case 1:\n          return signed ? function readS16FromPointer(pointer) {\n            return HEAP16[pointer >> 1];\n          } : function readU16FromPointer(pointer) {\n            return HEAPU16[pointer >> 1];\n          };\n        case 2:\n          return signed ? function readS32FromPointer(pointer) {\n            return HEAP32[pointer >> 2];\n          } : function readU32FromPointer(pointer) {\n            return HEAPU32[pointer >> 2];\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var shift = getShiftFromSize(size);\n      var fromWireType = function fromWireType(value) {\n        return value;\n      };\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = function fromWireType(value) {\n          return value << bitshift >>> bitshift;\n        };\n      }\n      var isUnsignedType = name.includes(\"unsigned\");\n      registerType(primitiveType, {\n        name: name,\n        \"fromWireType\": fromWireType,\n        \"toWireType\": function toWireType(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n          if (value < minRange || value > maxRange) {\n            throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n          }\n          return isUnsignedType ? value >>> 0 : value | 0;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle];\n        var data = heap[handle + 1];\n        return new TA(buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": decodeMemoryView,\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": decodeMemoryView\n      }, {\n        ignoreDuplicateRegistrations: true\n      });\n    }\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = value + 4;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = value + 4 + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n            }\n            str = a.join(\"\");\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var getLength;\n          var valueIsOfTypeString = typeof value === \"string\";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            getLength = function getLength() {\n              return lengthBytesUTF8(value);\n            };\n          } else {\n            getLength = function getLength() {\n              return value.length;\n            };\n          }\n          var length = getLength();\n          var ptr = _malloc(4 + length + 1);\n          HEAPU32[ptr >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr + 4, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                }\n                HEAPU8[ptr + 4 + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + 4 + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = function getHeap() {\n          return HEAPU16;\n        };\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = function getHeap() {\n          return HEAPU32;\n        };\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (!(typeof value === \"string\")) {\n            throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_value_array(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n      tupleRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        elements: []\n      };\n    }\n    function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      tupleRegistrations[rawTupleType].elements.push({\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    }\n    function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        fields: []\n      };\n    }\n    function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      structRegistrations[structType].fields.push({\n        fieldName: readLatin1String(fieldName),\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    }\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        \"argPackAdvance\": 0,\n        \"fromWireType\": function fromWireType() {\n          return undefined;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return undefined;\n        }\n      });\n    }\n    function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n    function __emval_take_value(type, argv) {\n      type = requireRegisteredType(type, \"_emval_take_value\");\n      var v = type[\"readValueFromPointer\"](argv);\n      return Emval.toHandle(v);\n    }\n    function _abort() {\n      abort(\"\");\n    }\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {}\n    }\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      var maxHeapSize = 2147483648;\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var ENV = {};\n    function getExecutableName() {\n      return thisProgram || \"./this.program\";\n    }\n    function getEnvStrings() {\n      if (!getEnvStrings.strings) {\n        var lang = (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n        var env = {\n          \"USER\": \"web_user\",\n          \"LOGNAME\": \"web_user\",\n          \"PATH\": \"/\",\n          \"PWD\": \"/\",\n          \"HOME\": \"/home/web_user\",\n          \"LANG\": lang,\n          \"_\": getExecutableName()\n        };\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(x + \"=\" + env[x]);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    }\n    var PATH = {\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = path.charAt(0) === \"/\",\n          trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          return \".\";\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: function basename(path) {\n        if (path === \"/\") return \"/\";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function extname(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function join() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      }\n    };\n    function getRandomDevice() {\n      if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n        var randomBuffer = new Uint8Array(1);\n        return function () {\n          crypto.getRandomValues(randomBuffer);\n          return randomBuffer[0];\n        };\n      } else return function () {\n        abort(\"randomDevice\");\n      };\n    }\n    var PATH_FS = {\n      resolve: function resolve() {\n        var resolvedPath = \"\",\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n          if (typeof path !== \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === \"/\";\n        }\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: function relative(from, to) {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\") break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\") break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var TTY = {\n      ttys: [],\n      init: function init() {},\n      shutdown: function shutdown() {},\n      register: function register(dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function close(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        flush: function flush(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        read: function read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write: function write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function get_char(tty) {\n          if (!tty.input.length) {\n            var result = null;\n            if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n              result = window.prompt(\"Input: \");\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            } else if (typeof readline == \"function\") {\n              result = readline();\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            }\n            if (!result) {\n              return null;\n            }\n            tty.input = intArrayFromString(result, true);\n          }\n          return tty.input.shift();\n        },\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function flush(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      },\n      default_tty1_ops: {\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function flush(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    function mmapAlloc(size) {\n      abort();\n    }\n    var MEMFS = {\n      ops_table: null,\n      mount: function mount(_mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode: function createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray: function getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage: function resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr: function getattr(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod: function mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n          old_node.parent = new_dir;\n        },\n        unlink: function unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir: function rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir: function readdir(node) {\n          var entries = [\".\", \"..\"];\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink: function symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          }\n          return size;\n        },\n        write: function write(stream, buffer, offset, length, position, canOwn) {\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate: function allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function mmap(stream, address, length, position, prot, flags) {\n          if (address !== 0) {\n            throw new FS.ErrnoError(28);\n          }\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          if (!(flags & 2) && contents.buffer === buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            HEAP8.set(contents, ptr);\n          }\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync: function msync(stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          if (mmapFlags & 2) {\n            return 0;\n          }\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    function asyncLoad(url, onload, onerror, noRunDep) {\n      var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\n      readAsync(url, function (arrayBuffer) {\n        assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n        onload(new Uint8Array(arrayBuffer));\n        if (dep) removeRunDependency(dep);\n      }, function (event) {\n        if (onerror) {\n          onerror();\n        } else {\n          throw 'Loading data file \"' + url + '\" failed.';\n        }\n      });\n      if (dep) addRunDependency(dep);\n    }\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      lookupPath: function lookupPath(path, opts) {\n        path = PATH_FS.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path) return {\n          path: \"\",\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n        var parts = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), false);\n        var current = FS.root;\n        var current_path = \"/\";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count\n              });\n              current = lookup.node;\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath: function getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n          }\n          path = path ? node.name + \"/\" + path : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function hashName(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        return FS.lookup(parent, name);\n      },\n      createNode: function createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint: function isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile: function isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagModes: {\n        \"r\": 0,\n        \"r+\": 2,\n        \"w\": 577,\n        \"w+\": 578,\n        \"a\": 1089,\n        \"a+\": 1090\n      },\n      modeStringToFlags: function modeStringToFlags(str) {\n        var flags = FS.flagModes[str];\n        if (typeof flags === \"undefined\") {\n          throw new Error(\"Unknown file open mode: \" + str);\n        }\n        return flags;\n      },\n      flagsToPermissionString: function flagsToPermissionString(flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n        if (flag & 512) {\n          perms += \"w\";\n        }\n        return perms;\n      },\n      nodePermissions: function nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        if (perms.includes(\"r\") && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup: function mayLookup(dir) {\n        var errCode = FS.nodePermissions(dir, \"x\");\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate: function mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete: function mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, \"wx\");\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen: function mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function nextfd(fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStream: function getStream(fd) {\n        return FS.streams[fd];\n      },\n      createStream: function createStream(stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function () {};\n          FS.FSStream.prototype = {\n            object: {\n              get: function get() {\n                return this.node;\n              },\n              set: function set(val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get: function get() {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get: function get() {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get: function get() {\n                return this.flags & 1024;\n              }\n            }\n          };\n        }\n        var newStream = new FS.FSStream();\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open: function open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek: function llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: function major(dev) {\n        return dev >> 8;\n      },\n      minor: function minor(dev) {\n        return dev & 255;\n      },\n      makedev: function makedev(ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function registerDevice(dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: function getDevice(dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n        return mounts;\n      },\n      syncfs: function syncfs(populate, callback) {\n        if (typeof populate === \"function\") {\n          callback = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function mount(type, opts, mountpoint) {\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path;\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount: function unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function create(path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function mkdirTree(path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += \"/\" + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev: function mkdev(path, mode, dev) {\n        if (typeof dev === \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        lookup = FS.lookupPath(old_path, {\n          parent: true\n        });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, {\n          parent: true\n        });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(28);\n        }\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(55);\n        }\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n        if (old_node === new_node) {\n          return;\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, \"w\");\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir: function rmdir(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir: function readdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink: function unlink(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink: function readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat: function lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod: function chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function fchmod(fd, mode) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chmod(stream.node, mode);\n      },\n      chown: function chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n        });\n      },\n      lchown: function lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function fchown(fd, uid, gid) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, \"w\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate: function ftruncate(fd, len) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime: function utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open: function open(path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === \"undefined\" ? 438 : mode;\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path === \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        if (flags & 512) {\n          FS.truncate(node, 0);\n        }\n        flags &= ~(128 | 512 | 131072);\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          id: node.id,\n          flags: flags,\n          mode: node.mode,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          node_ops: node.node_ops,\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close: function close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed: function isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek: function llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position !== \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position !== \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate: function allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function mmap(stream, address, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);\n      },\n      msync: function msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      munmap: function munmap(stream) {\n        return 0;\n      },\n      ioctl: function ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function readFile(path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || \"binary\";\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function writeFile(path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data === \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n        FS.close(stream);\n      },\n      cwd: function cwd() {\n        return FS.currentPath;\n      },\n      chdir: function chdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function createDefaultDirectories() {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices: function createDefaultDevices() {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function read() {\n            return 0;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var random_device = getRandomDevice();\n        FS.createDevice(\"/dev\", \"random\", random_device);\n        FS.createDevice(\"/dev\", \"urandom\", random_device);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories: function createSpecialDirectories() {\n        FS.mkdir(\"/proc\");\n        var proc_self = FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount: function mount() {\n            var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup: function lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: \"fake\"\n                  },\n                  node_ops: {\n                    readlink: function readlink() {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams: function createStandardStreams() {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n        var stdin = FS.open(\"/dev/stdin\", 0);\n        var stdout = FS.open(\"/dev/stdout\", 1);\n        var stderr = FS.open(\"/dev/stderr\", 1);\n      },\n      ensureErrnoError: function ensureErrnoError() {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.node = node;\n          this.setErrno = function (errno) {\n            this.errno = errno;\n          };\n          this.setErrno(errno);\n          this.message = \"FS error\";\n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [44].forEach(function (code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit: function staticInit() {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          \"MEMFS\": MEMFS\n        };\n      },\n      init: function init(input, output, error) {\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit: function quit() {\n        FS.init.initialized = false;\n        var fflush = Module[\"_fflush\"];\n        if (fflush) fflush(0);\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      getMode: function getMode(canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },\n      findObject: function findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          return null;\n        }\n      },\n      analyzePath: function analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath: function createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n          parent = current;\n        }\n        return current;\n      },\n      createFile: function createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data === \"string\") {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) {\n              arr[i] = data.charCodeAt(i);\n            }\n            data = arr;\n          }\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },\n      createDevice: function createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open: function open(stream) {\n            stream.seekable = false;\n          },\n          close: function close(stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile: function forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (read_) {\n          try {\n            obj.contents = intArrayFromString(read_(obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n      },\n      createLazyFile: function createLazyFile(parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return undefined;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n          var doXHR = function doXHR(from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || \"\", true);\n            }\n          };\n          var lazyArray = this;\n          lazyArray.setDataGetter(function (chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function get() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function get() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function get() {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function (key) {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function forceLoadLazyFile() {\n            FS.forceLoadFile(node);\n            return fn.apply(null, arguments);\n          };\n        });\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          FS.forceLoadFile(node);\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      createPreloadedFile: function createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency(\"cp \" + fullname);\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n          var handled = false;\n          Module[\"preloadPlugins\"].forEach(function (plugin) {\n            if (handled) return;\n            if (plugin[\"canHandle\"](fullname)) {\n              plugin[\"handle\"](byteArray, fullname, finish, function () {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n        addRunDependency(dep);\n        if (typeof url == \"string\") {\n          asyncLoad(url, function (byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },\n      indexedDB: function indexedDB() {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },\n      DB_NAME: function DB_NAME() {\n        return \"EM_FS_\" + window.location.pathname;\n      },\n      DB_VERSION: 20,\n      DB_STORE_NAME: \"FILE_DATA\",\n      saveFilesToDB: function saveFilesToDB(paths, onload, onerror) {\n        onload = onload || function () {};\n        onerror = onerror || function () {};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          out(\"creating db\");\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n            fail = 0,\n            total = paths.length;\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n          paths.forEach(function (path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = function putRequest_onsuccess() {\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            putRequest.onerror = function putRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      },\n      loadFilesFromDB: function loadFilesFromDB(paths, onload, onerror) {\n        onload = onload || function () {};\n        onerror = onerror || function () {};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = onerror;\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\n          } catch (e) {\n            onerror(e);\n            return;\n          }\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n            fail = 0,\n            total = paths.length;\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n          paths.forEach(function (path) {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            getRequest.onerror = function getRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      }\n    };\n    var SYSCALLS = {\n      mappings: {},\n      DEFAULT_POLLMASK: 5,\n      calculateAt: function calculateAt(dirfd, path, allowEmpty) {\n        if (path[0] === \"/\") {\n          return path;\n        }\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = FS.getStream(dirfd);\n          if (!dirstream) throw new FS.ErrnoError(8);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat: function doStat(func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -54;\n          }\n          throw e;\n        }\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAP32[buf + 48 >> 2] = 4096;\n        HEAP32[buf + 52 >> 2] = stat.blocks;\n        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 76 >> 2] = 0;\n        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync: function doMsync(addr, stream, len, flags, offset) {\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      doMkdir: function doMkdir(path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },\n      doMknod: function doMknod(path, mode, dev) {\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n          default:\n            return -28;\n        }\n        FS.mknod(path, mode, dev);\n        return 0;\n      },\n      doReadlink: function doReadlink(path, buf, bufsize) {\n        if (bufsize <= 0) return -28;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len;\n      },\n      doAccess: function doAccess(path, amode) {\n        if (amode & ~7) {\n          return -28;\n        }\n        var node;\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        node = lookup.node;\n        if (!node) {\n          return -44;\n        }\n        var perms = \"\";\n        if (amode & 4) perms += \"r\";\n        if (amode & 2) perms += \"w\";\n        if (amode & 1) perms += \"x\";\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -2;\n        }\n        return 0;\n      },\n      doDup: function doDup(path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },\n      doReadv: function doReadv(stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.read(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break;\n        }\n        return ret;\n      },\n      doWritev: function doWritev(stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.write(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n        return ret;\n      },\n      varargs: undefined,\n      get: function get() {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      getStreamFromFD: function getStreamFromFD(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) throw new FS.ErrnoError(8);\n        return stream;\n      },\n      get64: function get64(low, high) {\n        return low;\n      }\n    };\n    function _environ_get(__environ, environ_buf) {\n      var bufSize = 0;\n      getEnvStrings().forEach(function (string, i) {\n        var ptr = environ_buf + bufSize;\n        HEAP32[__environ + i * 4 >> 2] = ptr;\n        writeAsciiToMemory(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    }\n    function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = getEnvStrings();\n      HEAP32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(function (string) {\n        bufSize += string.length + 1;\n      });\n      HEAP32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    }\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var HIGH_OFFSET = 4294967296;\n        var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\n        var DOUBLE_LIMIT = 9007199254740992;\n        if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\n          return -61;\n        }\n        FS.llseek(stream, offset, whence);\n        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _setTempRet0(val) {\n      setTempRet0(val);\n    }\n    function __isLeapYear(year) {\n      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    }\n    function __arraySum(array, index) {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]) {}\n      return sum;\n    }\n    var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    function __addDays(date, days) {\n      var newDate = new Date(date.getTime());\n      while (days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n          days -= daysInCurrentMonth - newDate.getDate() + 1;\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth + 1);\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear() + 1);\n          }\n        } else {\n          newDate.setDate(newDate.getDate() + days);\n          return newDate;\n        }\n      }\n      return newDate;\n    }\n    function _strftime(s, maxsize, format, tm) {\n      var tm_zone = HEAP32[tm + 40 >> 2];\n      var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[tm + 4 >> 2],\n        tm_hour: HEAP32[tm + 8 >> 2],\n        tm_mday: HEAP32[tm + 12 >> 2],\n        tm_mon: HEAP32[tm + 16 >> 2],\n        tm_year: HEAP32[tm + 20 >> 2],\n        tm_wday: HEAP32[tm + 24 >> 2],\n        tm_yday: HEAP32[tm + 28 >> 2],\n        tm_isdst: HEAP32[tm + 32 >> 2],\n        tm_gmtoff: HEAP32[tm + 36 >> 2],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n      };\n      var pattern = UTF8ToString(format);\n      var EXPANSION_RULES_1 = {\n        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n        \"%D\": \"%m/%d/%y\",\n        \"%F\": \"%Y-%m-%d\",\n        \"%h\": \"%b\",\n        \"%r\": \"%I:%M:%S %p\",\n        \"%R\": \"%H:%M\",\n        \"%T\": \"%H:%M:%S\",\n        \"%x\": \"%m/%d/%y\",\n        \"%X\": \"%H:%M:%S\",\n        \"%Ec\": \"%c\",\n        \"%EC\": \"%C\",\n        \"%Ex\": \"%m/%d/%y\",\n        \"%EX\": \"%H:%M:%S\",\n        \"%Ey\": \"%y\",\n        \"%EY\": \"%Y\",\n        \"%Od\": \"%d\",\n        \"%Oe\": \"%e\",\n        \"%OH\": \"%H\",\n        \"%OI\": \"%I\",\n        \"%Om\": \"%m\",\n        \"%OM\": \"%M\",\n        \"%OS\": \"%S\",\n        \"%Ou\": \"%u\",\n        \"%OU\": \"%U\",\n        \"%OV\": \"%V\",\n        \"%Ow\": \"%w\",\n        \"%OW\": \"%W\",\n        \"%Oy\": \"%y\"\n      };\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n      }\n      var WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n      var MONTHS = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n      function leadingSomething(value, digits, character) {\n        var str = typeof value === \"number\" ? value.toString() : value || \"\";\n        while (str.length < digits) {\n          str = character[0] + str;\n        }\n        return str;\n      }\n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, \"0\");\n      }\n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : value > 0 ? 1 : 0;\n        }\n        var compare;\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate() - date2.getDate());\n          }\n        }\n        return compare;\n      }\n      function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n          case 0:\n            return new Date(janFourth.getFullYear() - 1, 11, 29);\n          case 1:\n            return janFourth;\n          case 2:\n            return new Date(janFourth.getFullYear(), 0, 3);\n          case 3:\n            return new Date(janFourth.getFullYear(), 0, 2);\n          case 4:\n            return new Date(janFourth.getFullYear(), 0, 1);\n          case 5:\n            return new Date(janFourth.getFullYear() - 1, 11, 31);\n          case 6:\n            return new Date(janFourth.getFullYear() - 1, 11, 30);\n        }\n      }\n      function getWeekBasedYear(date) {\n        var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n            return thisDate.getFullYear() + 1;\n          } else {\n            return thisDate.getFullYear();\n          }\n        } else {\n          return thisDate.getFullYear() - 1;\n        }\n      }\n      var EXPANSION_RULES_2 = {\n        \"%a\": function a(date) {\n          return WEEKDAYS[date.tm_wday].substring(0, 3);\n        },\n        \"%A\": function A(date) {\n          return WEEKDAYS[date.tm_wday];\n        },\n        \"%b\": function b(date) {\n          return MONTHS[date.tm_mon].substring(0, 3);\n        },\n        \"%B\": function B(date) {\n          return MONTHS[date.tm_mon];\n        },\n        \"%C\": function C(date) {\n          var year = date.tm_year + 1900;\n          return leadingNulls(year / 100 | 0, 2);\n        },\n        \"%d\": function d(date) {\n          return leadingNulls(date.tm_mday, 2);\n        },\n        \"%e\": function e(date) {\n          return leadingSomething(date.tm_mday, 2, \" \");\n        },\n        \"%g\": function g(date) {\n          return getWeekBasedYear(date).toString().substring(2);\n        },\n        \"%G\": function G(date) {\n          return getWeekBasedYear(date);\n        },\n        \"%H\": function H(date) {\n          return leadingNulls(date.tm_hour, 2);\n        },\n        \"%I\": function I(date) {\n          var twelveHour = date.tm_hour;\n          if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        \"%j\": function j(date) {\n          return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n        },\n        \"%m\": function m(date) {\n          return leadingNulls(date.tm_mon + 1, 2);\n        },\n        \"%M\": function M(date) {\n          return leadingNulls(date.tm_min, 2);\n        },\n        \"%n\": function n() {\n          return \"\\n\";\n        },\n        \"%p\": function p(date) {\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\n            return \"AM\";\n          } else {\n            return \"PM\";\n          }\n        },\n        \"%S\": function S(date) {\n          return leadingNulls(date.tm_sec, 2);\n        },\n        \"%t\": function t() {\n          return \"\\t\";\n        },\n        \"%u\": function u(date) {\n          return date.tm_wday || 7;\n        },\n        \"%U\": function U(date) {\n          var janFirst = new Date(date.tm_year + 1900, 0, 1);\n          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n          var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n          if (compareByDay(firstSunday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n            var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n          return compareByDay(firstSunday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%V\": function V(date) {\n          var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\n          var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n          var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n            return \"53\";\n          }\n          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n            return \"01\";\n          }\n          var daysDifference;\n          if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\n            daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\n          } else {\n            daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\n          }\n          return leadingNulls(Math.ceil(daysDifference / 7), 2);\n        },\n        \"%w\": function w(date) {\n          return date.tm_wday;\n        },\n        \"%W\": function W(date) {\n          var janFirst = new Date(date.tm_year, 0, 1);\n          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n          var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n          if (compareByDay(firstMonday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n            var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n          return compareByDay(firstMonday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%y\": function y(date) {\n          return (date.tm_year + 1900).toString().substring(2);\n        },\n        \"%Y\": function Y(date) {\n          return date.tm_year + 1900;\n        },\n        \"%z\": function z(date) {\n          var off = date.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          off = off / 60 * 100 + off % 60;\n          return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n        },\n        \"%Z\": function Z(date) {\n          return date.tm_zone;\n        },\n        \"%%\": function _() {\n          return \"%\";\n        }\n      };\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.includes(rule)) {\n          pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n        }\n      }\n      var bytes = intArrayFromString(pattern, false);\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n      writeArrayToMemory(bytes, s);\n      return bytes.length - 1;\n    }\n    function _strftime_l(s, maxsize, format, tm) {\n      return _strftime(s, maxsize, format, tm);\n    }\n    InternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n    init_ClassHandle();\n    init_RegisteredPointer();\n    init_embind();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n    init_emval();\n    var FSNode = function FSNode(parent, name, mode, rdev) {\n      if (!parent) {\n        parent = this;\n      }\n      this.parent = parent;\n      this.mount = parent.mount;\n      this.mounted = null;\n      this.id = FS.nextInode++;\n      this.name = name;\n      this.mode = mode;\n      this.node_ops = {};\n      this.stream_ops = {};\n      this.rdev = rdev;\n    };\n    var readMode = 292 | 73;\n    var writeMode = 146;\n    Object.defineProperties(FSNode.prototype, {\n      read: {\n        get: function get() {\n          return (this.mode & readMode) === readMode;\n        },\n        set: function set(val) {\n          val ? this.mode |= readMode : this.mode &= ~readMode;\n        }\n      },\n      write: {\n        get: function get() {\n          return (this.mode & writeMode) === writeMode;\n        },\n        set: function set(val) {\n          val ? this.mode |= writeMode : this.mode &= ~writeMode;\n        }\n      },\n      isFolder: {\n        get: function get() {\n          return FS.isDir(this.mode);\n        }\n      },\n      isDevice: {\n        get: function get() {\n          return FS.isChrdev(this.mode);\n        }\n      }\n    });\n    FS.FSNode = FSNode;\n    FS.staticInit();\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var asmLibraryArg = {\n      \"d\": ___cxa_allocate_exception,\n      \"e\": ___cxa_throw,\n      \"n\": __embind_finalize_value_array,\n      \"p\": __embind_finalize_value_object,\n      \"y\": __embind_register_bigint,\n      \"I\": __embind_register_bool,\n      \"h\": __embind_register_class,\n      \"g\": __embind_register_class_constructor,\n      \"c\": __embind_register_class_function,\n      \"r\": __embind_register_class_property,\n      \"H\": __embind_register_emval,\n      \"q\": __embind_register_enum,\n      \"i\": __embind_register_enum_value,\n      \"v\": __embind_register_float,\n      \"a\": __embind_register_function,\n      \"k\": __embind_register_integer,\n      \"j\": __embind_register_memory_view,\n      \"w\": __embind_register_std_string,\n      \"t\": __embind_register_std_wstring,\n      \"o\": __embind_register_value_array,\n      \"b\": __embind_register_value_array_element,\n      \"m\": __embind_register_value_object,\n      \"f\": __embind_register_value_object_field,\n      \"J\": __embind_register_void,\n      \"K\": __emval_decref,\n      \"L\": __emval_incref,\n      \"l\": __emval_take_value,\n      \"u\": _abort,\n      \"A\": _emscripten_memcpy_big,\n      \"s\": _emscripten_resize_heap,\n      \"C\": _environ_get,\n      \"D\": _environ_sizes_get,\n      \"G\": _fd_close,\n      \"E\": _fd_read,\n      \"x\": _fd_seek,\n      \"F\": _fd_write,\n      \"z\": _setTempRet0,\n      \"B\": _strftime_l\n    };\n    var asm = createWasm();\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"N\"]).apply(null, arguments);\n    };\n    var _malloc = Module[\"_malloc\"] = function () {\n      return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"P\"]).apply(null, arguments);\n    };\n    var _free = Module[\"_free\"] = function () {\n      return (_free = Module[\"_free\"] = Module[\"asm\"][\"Q\"]).apply(null, arguments);\n    };\n    var ___getTypeName = Module[\"___getTypeName\"] = function () {\n      return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"R\"]).apply(null, arguments);\n    };\n    var ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function () {\n      return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"S\"]).apply(null, arguments);\n    };\n    var stackSave = Module[\"stackSave\"] = function () {\n      return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"T\"]).apply(null, arguments);\n    };\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"U\"]).apply(null, arguments);\n    };\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      return (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"V\"]).apply(null, arguments);\n    };\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n      return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"W\"]).apply(null, arguments);\n    };\n    var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = function () {\n      return (dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = Module[\"asm\"][\"X\"]).apply(null, arguments);\n    };\n    var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = function () {\n      return (dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = Module[\"asm\"][\"Y\"]).apply(null, arguments);\n    };\n    var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = function () {\n      return (dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = Module[\"asm\"][\"Z\"]).apply(null, arguments);\n    };\n    var dynCall_viijii = Module[\"dynCall_viijii\"] = function () {\n      return (dynCall_viijii = Module[\"dynCall_viijii\"] = Module[\"asm\"][\"_\"]).apply(null, arguments);\n    };\n    Module[\"ccall\"] = ccall;\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run(args) {\n      args = args || arguments_;\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    Module[\"run\"] = run;\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n    return Module.ready;\n  };\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (Module);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/baic/Documents/programm/gsrlic/node_modules/babel-loader/lib/index.js??ref--6-oneOf-2!/Users/baic/Documents/programm/gsrlic/node_modules/@splinetool/runtime/build/process.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA,4BAA4B,6BAA6B,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,mEAAmE,wBAAwB,4CAA4C,SAAS;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,uGAAuG,yDAAyD,6IAA6I,QAAQ;AACrT;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA,qBAAqB,kBAAkB;AACvC,+GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,iIAAiI;AACjI;AACA,sDAAsD;AACtD,OAAO;AACP,+CAA+C,qBAAqB;AACpE;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E,OAAO;AACP,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+EAA+E;AAC/E;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA,OAAO;AACP;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,2BAA2B,YAAY;AACvC;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA,WAAW;AACX,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C;AAC/C;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACc,qEAAM,E","file":"x","sourcesContent":["var Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return function (Module) {\n    Module = Module || {};\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = {};\n    var key;\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readAsync, readBinary, setWindowTitle;\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document !== \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n      {\n        read_ = function read_(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary(url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n        readAsync = function readAsync(url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = function () {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n      setWindowTitle = function setWindowTitle(title) {\n        document.title = title;\n      };\n    } else {}\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var tempRet0 = 0;\n    var setTempRet0 = function setTempRet0(value) {\n      tempRet0 = value;\n    };\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    if (typeof WebAssembly !== \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n    function getCFunc(ident) {\n      var func = Module[\"_\" + ident];\n      assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n      return func;\n    }\n    function ccall(ident, returnType, argTypes, args, opts) {\n      var toC = {\n        \"string\": function string(str) {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len);\n          }\n          return ret;\n        },\n        \"array\": function array(arr) {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n      function convertReturnValue(ret) {\n        if (returnType === \"string\") return UTF8ToString(ret);\n        if (returnType === \"boolean\") return Boolean(ret);\n        return ret;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n      ret = onDone(ret);\n      return ret;\n    }\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n    function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heap[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n        while (idx < endPtr) {\n          var u0 = heap[idx++];\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n          var u1 = heap[idx++] & 63;\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n          var u2 = heap[idx++] & 63;\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n          }\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n      return str;\n    }\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n    function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\n      }\n      return len;\n    }\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n    function UTF16ToString(ptr, maxBytesToRead) {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) {\n        ++idx;\n      }\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var str = \"\";\n        for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) break;\n          str += String.fromCharCode(codeUnit);\n        }\n        return str;\n      }\n    }\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n    function UTF32ToString(ptr, maxBytesToRead) {\n      var i = 0;\n      var str = \"\";\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    }\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF32(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    }\n    function writeArrayToMemory(array, buffer) {\n      HEAP8.set(array, buffer);\n    }\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      }\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n      return x;\n    }\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n    var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n    var wasmTable;\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n      FS.ignorePermissions = false;\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    function abort(what) {\n      {\n        if (Module[\"onAbort\"]) {\n          Module[\"onAbort\"](what);\n        }\n      }\n      what = \"Aborted(\" + what + \")\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += \". Build with -s ASSERTIONS=1 for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n    var wasmBinaryFile;\n    wasmBinaryFile = \"process.wasm\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n    function getBinary(file) {\n      try {\n        if (file == wasmBinaryFile && wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n        if (readBinary) {\n          return readBinary(file);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n            return response[\"arrayBuffer\"]();\n          }).catch(function () {\n            return getBinary(wasmBinaryFile);\n          });\n        }\n      }\n      return Promise.resolve().then(function () {\n        return getBinary(wasmBinaryFile);\n      });\n    }\n    function createWasm() {\n      var info = {\n        \"a\": asmLibraryArg\n      };\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        wasmMemory = Module[\"asm\"][\"M\"];\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        wasmTable = Module[\"asm\"][\"O\"];\n        addOnInit(Module[\"asm\"][\"N\"]);\n        removeRunDependency(\"wasm-instantiate\");\n      }\n      addRunDependency(\"wasm-instantiate\");\n      function receiveInstantiationResult(result) {\n        receiveInstance(result[\"instance\"]);\n      }\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(function (instance) {\n          return instance;\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err(\"wasm streaming compile failed: \" + reason);\n              err(\"falling back to ArrayBuffer instantiation\");\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiationResult);\n        }\n      }\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n      instantiateAsync().catch(readyPromiseReject);\n      return {};\n    }\n    var tempDouble;\n    var tempI64;\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == \"function\") {\n          callback(Module);\n          continue;\n        }\n        var func = callback.func;\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            getWasmTableEntry(func)();\n          } else {\n            getWasmTableEntry(func)(callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n    var wasmTableMirror = [];\n    function getWasmTableEntry(funcPtr) {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      return func;\n    }\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size + 16) + 16;\n    }\n    function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 16;\n      this.set_type = function (type) {\n        HEAP32[this.ptr + 4 >> 2] = type;\n      };\n      this.get_type = function () {\n        return HEAP32[this.ptr + 4 >> 2];\n      };\n      this.set_destructor = function (destructor) {\n        HEAP32[this.ptr + 8 >> 2] = destructor;\n      };\n      this.get_destructor = function () {\n        return HEAP32[this.ptr + 8 >> 2];\n      };\n      this.set_refcount = function (refcount) {\n        HEAP32[this.ptr >> 2] = refcount;\n      };\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[this.ptr + 12 >> 0] = caught;\n      };\n      this.get_caught = function () {\n        return HEAP8[this.ptr + 12 >> 0] != 0;\n      };\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[this.ptr + 13 >> 0] = rethrown;\n      };\n      this.get_rethrown = function () {\n        return HEAP8[this.ptr + 13 >> 0] != 0;\n      };\n      this.init = function (type, destructor) {\n        this.set_type(type);\n        this.set_destructor(destructor);\n        this.set_refcount(0);\n        this.set_caught(false);\n        this.set_rethrown(false);\n      };\n      this.add_ref = function () {\n        var value = HEAP32[this.ptr >> 2];\n        HEAP32[this.ptr >> 2] = value + 1;\n      };\n      this.release_ref = function () {\n        var prev = HEAP32[this.ptr >> 2];\n        HEAP32[this.ptr >> 2] = prev - 1;\n        return prev === 1;\n      };\n    }\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n    function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw ptr;\n    }\n    var tupleRegistrations = {};\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n    }\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n    function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return \"_unknown\";\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return \"_\" + name;\n      } else {\n        return name;\n      }\n    }\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n    }\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + \": \" + this.message;\n        }\n      };\n      return errorClass;\n    }\n    var InternalError = undefined;\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function (dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(function () {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n    function __embind_finalize_value_array(rawTupleType) {\n      var reg = tupleRegistrations[rawTupleType];\n      delete tupleRegistrations[rawTupleType];\n      var elements = reg.elements;\n      var elementsLength = elements.length;\n      var elementTypes = elements.map(function (elt) {\n        return elt.getterReturnType;\n      }).concat(elements.map(function (elt) {\n        return elt.setterArgumentType;\n      }));\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      whenDependentTypesAreResolved([rawTupleType], elementTypes, function (elementTypes) {\n        elements.forEach(function (elt, i) {\n          var getterReturnType = elementTypes[i];\n          var getter = elt.getter;\n          var getterContext = elt.getterContext;\n          var setterArgumentType = elementTypes[i + elementsLength];\n          var setter = elt.setter;\n          var setterContext = elt.setterContext;\n          elt.read = function (ptr) {\n            return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n          };\n          elt.write = function (ptr, o) {\n            var destructors = [];\n            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n            runDestructors(destructors);\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": function fromWireType(ptr) {\n            var rv = new Array(elementsLength);\n            for (var i = 0; i < elementsLength; ++i) {\n              rv[i] = elements[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": function toWireType(destructors, o) {\n            if (elementsLength !== o.length) {\n              throw new TypeError(\"Incorrect number of tuple elements for \" + reg.name + \": expected=\" + elementsLength + \", actual=\" + o.length);\n            }\n            var ptr = rawConstructor();\n            for (var i = 0; i < elementsLength; ++i) {\n              elements[i].write(ptr, o[i]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          \"argPackAdvance\": 8,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    }\n    var structRegistrations = {};\n    function __embind_finalize_value_object(structType) {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords.map(function (field) {\n        return field.getterReturnType;\n      }).concat(fieldRecords.map(function (field) {\n        return field.setterArgumentType;\n      }));\n      whenDependentTypesAreResolved([structType], fieldTypes, function (fieldTypes) {\n        var fields = {};\n        fieldRecords.forEach(function (field, i) {\n          var fieldName = field.fieldName;\n          var getterReturnType = fieldTypes[i];\n          var getter = field.getter;\n          var getterContext = field.getterContext;\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\n          var setter = field.setter;\n          var setterContext = field.setterContext;\n          fields[fieldName] = {\n            read: function read(ptr) {\n              return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n            },\n            write: function write(ptr, o) {\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n              runDestructors(destructors);\n            }\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": function fromWireType(ptr) {\n            var rv = {};\n            for (var i in fields) {\n              rv[i] = fields[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": function toWireType(destructors, o) {\n            for (var fieldName in fields) {\n              if (!(fieldName in o)) {\n                throw new TypeError('Missing field:  \"' + fieldName + '\"');\n              }\n            }\n            var ptr = rawConstructor();\n            for (fieldName in fields) {\n              fields[fieldName].write(ptr, o[fieldName]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          \"argPackAdvance\": 8,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    }\n    function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(\"Unknown type size: \" + size);\n      }\n    }\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }\n    var embind_charCodes = undefined;\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n    var BindingError = undefined;\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n    function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      }\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function (cb) {\n          cb();\n        });\n      }\n    }\n    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(wt) {\n          return !!wt;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": function readValueFromPointer(pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n          return this[\"fromWireType\"](heap[pointer >> shift]);\n        },\n        destructorFunction: null\n      });\n    }\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n      return leftClass === rightClass && left === right;\n    }\n    function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType\n      };\n    }\n    function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n    }\n    var finalizationRegistry = false;\n    function detachFinalizer(handle) {}\n    function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n    function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n    function attachFinalizer(handle) {\n      if (\"undefined\" === typeof FinalizationRegistry) {\n        attachFinalizer = function attachFinalizer(handle) {\n          return handle;\n        };\n        return handle;\n      }\n      finalizationRegistry = new FinalizationRegistry(function (info) {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = function attachFinalizer(handle) {\n        var $$ = handle.$$;\n        var info = {\n          $$: $$\n        };\n        finalizationRegistry.register(handle, info, handle);\n        return handle;\n      };\n      detachFinalizer = function detachFinalizer(handle) {\n        finalizationRegistry.unregister(handle);\n      };\n      return attachFinalizer(handle);\n    }\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: shallowCopyInternalPointer(this.$$)\n          }\n        }));\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n    var delayFunction = undefined;\n    var deletionQueue = [];\n    function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj[\"delete\"]();\n      }\n    }\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n    function init_ClassHandle() {\n      ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n      ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n      ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n      ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n      ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n    }\n    function ClassHandle() {}\n    var registeredPointers = {};\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n    function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    }\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n            }\n            break;\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle[\"clone\"]();\n              ptr = this.rawShare(ptr, Emval.toHandle(function () {\n                clonedHandle[\"delete\"]();\n              }));\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n          default:\n            throwBindingError(\"Unsupporting sharing policy\");\n        }\n      }\n      return ptr;\n    }\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n    function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle[\"delete\"]();\n      }\n    }\n    function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    }\n    function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n    function getLiveInheritedInstances() {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    }\n    function setDelayFunction(fn) {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n    function init_embind() {\n      Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n      Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n      Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n      Module[\"setDelayFunction\"] = setDelayFunction;\n    }\n    var registeredInstances = {};\n    function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n        throwBindingError(\"ptr should not be undefined\");\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    }\n    function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n    function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n      }\n      record.count = {\n        value: 1\n      };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record\n        }\n      }));\n    }\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance[\"clone\"]();\n        } else {\n          var rv = registeredInstance[\"clone\"]();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr\n          });\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n    function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n      RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n    }\n    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this[\"toWireType\"] = genericPointerToWireType;\n      }\n    }\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n    function dynCallLegacy(sig, ptr, args) {\n      var f = Module[\"dynCall_\" + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    }\n    function dynCall(sig, ptr, args) {\n      if (sig.includes(\"j\")) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      return getWasmTableEntry(ptr).apply(null, args);\n    }\n    function getDynCaller(sig, ptr) {\n      var argCache = [];\n      return function () {\n        argCache.length = arguments.length;\n        for (var i = 0; i < arguments.length; i++) {\n          argCache[i] = arguments[i];\n        }\n        return dynCall(sig, ptr, argCache);\n      };\n    }\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes(\"j\")) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp !== \"function\") {\n        throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n    var UnboundTypeError = undefined;\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\", \"]));\n    }\n    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n          var body = registeredClass.constructor_body[arguments.length];\n          if (undefined === body) {\n            throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n          }\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor\n          }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    }\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n      return array;\n    }\n    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = \"constructor \" + classType.name;\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n          throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n          return [];\n        });\n        return [];\n      });\n    }\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n      }\n      var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n      var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n      invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n      } else {}\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    function validateThis(this_, classType, humanName) {\n      if (!(this_ instanceof Object)) {\n        throwBindingError(humanName + ' with invalid \"this\": ' + this_);\n      }\n      if (!(this_ instanceof classType.registeredClass.constructor)) {\n        throwBindingError(humanName + ' incompatible with \"this\" of type ' + this_.constructor.name);\n      }\n      if (!this_.$$.ptr) {\n        throwBindingError(\"cannot call emscripten binding method \" + humanName + \" on deleted object\");\n      }\n      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n    }\n    function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      fieldName = readLatin1String(fieldName);\n      getter = embind__requireFunction(getterSignature, getter);\n      whenDependentTypesAreResolved([], [classType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + fieldName;\n        var desc = {\n          get: function get() {\n            throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [getterReturnType, setterArgumentType]);\n          },\n          enumerable: true,\n          configurable: true\n        };\n        if (setter) {\n          desc.set = function () {\n            throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [getterReturnType, setterArgumentType]);\n          };\n        } else {\n          desc.set = function (v) {\n            throwBindingError(humanName + \" is a read-only property\");\n          };\n        }\n        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function (types) {\n          var getterReturnType = types[0];\n          var desc = {\n            get: function get() {\n              var ptr = validateThis(this, classType, humanName + \" getter\");\n              return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n            },\n            enumerable: true\n          };\n          if (setter) {\n            setter = embind__requireFunction(setterSignature, setter);\n            var setterArgumentType = types[1];\n            desc.set = function (v) {\n              var ptr = validateThis(this, classType, humanName + \" setter\");\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n              runDestructors(destructors);\n            };\n          }\n          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n          return [];\n        });\n        return [];\n      });\n    }\n    var emval_free_list = [];\n    var emval_handle_array = [{}, {\n      value: undefined\n    }, {\n      value: null\n    }, {\n      value: true\n    }, {\n      value: false\n    }];\n    function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n    function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    }\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n      return null;\n    }\n    function init_emval() {\n      Module[\"count_emval_handles\"] = count_emval_handles;\n      Module[\"get_first_emval\"] = get_first_emval;\n    }\n    var Emval = {\n      toValue: function toValue(handle) {\n        if (!handle) {\n          throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n        }\n        return emval_handle_array[handle].value;\n      },\n      toHandle: function toHandle(value) {\n        switch (value) {\n          case undefined:\n            {\n              return 1;\n            }\n          case null:\n            {\n              return 2;\n            }\n          case true:\n            {\n              return 3;\n            }\n          case false:\n            {\n              return 4;\n            }\n          default:\n            {\n              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n              emval_handle_array[handle] = {\n                refcount: 1,\n                value: value\n              };\n              return handle;\n            }\n        }\n      }\n    };\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(handle) {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          return Emval.toHandle(value);\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    }\n    function enumReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return function (pointer) {\n            var heap = signed ? HEAP8 : HEAPU8;\n            return this[\"fromWireType\"](heap[pointer]);\n          };\n        case 1:\n          return function (pointer) {\n            var heap = signed ? HEAP16 : HEAPU16;\n            return this[\"fromWireType\"](heap[pointer >> 1]);\n          };\n        case 2:\n          return function (pointer) {\n            var heap = signed ? HEAP32 : HEAPU32;\n            return this[\"fromWireType\"](heap[pointer >> 2]);\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_enum(rawType, name, size, isSigned) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      function ctor() {}\n      ctor.values = {};\n      registerType(rawType, {\n        name: name,\n        constructor: ctor,\n        \"fromWireType\": function fromWireType(c) {\n          return this.constructor.values[c];\n        },\n        \"toWireType\": function toWireType(destructors, c) {\n          return c.value;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": enumReadValueFromPointer(name, shift, isSigned),\n        destructorFunction: null\n      });\n      exposePublicSymbol(name, ctor);\n    }\n    function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n      return impl;\n    }\n    function __embind_register_enum_value(rawEnumType, name, enumValue) {\n      var enumType = requireRegisteredType(rawEnumType, \"enum\");\n      name = readLatin1String(name);\n      var Enum = enumType.constructor;\n      var Value = Object.create(enumType.constructor.prototype, {\n        value: {\n          value: enumValue\n        },\n        constructor: {\n          value: createNamedFunction(enumType.name + \"_\" + name, function () {})\n        }\n      });\n      Enum.values[enumValue] = Value;\n      Enum[name] = Value;\n    }\n    function _embind_repr(v) {\n      if (v === null) {\n        return \"null\";\n      }\n      var t = typeof v;\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    }\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n        case 3:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          return value;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n          return value;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(name, function () {\n        throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n      }, argCount - 1);\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n        return [];\n      });\n    }\n    function integerReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return signed ? function readS8FromPointer(pointer) {\n            return HEAP8[pointer];\n          } : function readU8FromPointer(pointer) {\n            return HEAPU8[pointer];\n          };\n        case 1:\n          return signed ? function readS16FromPointer(pointer) {\n            return HEAP16[pointer >> 1];\n          } : function readU16FromPointer(pointer) {\n            return HEAPU16[pointer >> 1];\n          };\n        case 2:\n          return signed ? function readS32FromPointer(pointer) {\n            return HEAP32[pointer >> 2];\n          } : function readU32FromPointer(pointer) {\n            return HEAPU32[pointer >> 2];\n          };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var shift = getShiftFromSize(size);\n      var fromWireType = function fromWireType(value) {\n        return value;\n      };\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = function fromWireType(value) {\n          return value << bitshift >>> bitshift;\n        };\n      }\n      var isUnsignedType = name.includes(\"unsigned\");\n      registerType(primitiveType, {\n        name: name,\n        \"fromWireType\": fromWireType,\n        \"toWireType\": function toWireType(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n          if (value < minRange || value > maxRange) {\n            throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n          }\n          return isUnsignedType ? value >>> 0 : value | 0;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle];\n        var data = heap[handle + 1];\n        return new TA(buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": decodeMemoryView,\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": decodeMemoryView\n      }, {\n        ignoreDuplicateRegistrations: true\n      });\n    }\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = value + 4;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = value + 4 + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n            }\n            str = a.join(\"\");\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var getLength;\n          var valueIsOfTypeString = typeof value === \"string\";\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            getLength = function getLength() {\n              return lengthBytesUTF8(value);\n            };\n          } else {\n            getLength = function getLength() {\n              return value.length;\n            };\n          }\n          var length = getLength();\n          var ptr = _malloc(4 + length + 1);\n          HEAPU32[ptr >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr + 4, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                }\n                HEAPU8[ptr + 4 + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + 4 + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = function getHeap() {\n          return HEAPU16;\n        };\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = function getHeap() {\n          return HEAPU32;\n        };\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (!(typeof value === \"string\")) {\n            throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n    function __embind_register_value_array(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n      tupleRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        elements: []\n      };\n    }\n    function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      tupleRegistrations[rawTupleType].elements.push({\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    }\n    function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        fields: []\n      };\n    }\n    function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      structRegistrations[structType].fields.push({\n        fieldName: readLatin1String(fieldName),\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    }\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        \"argPackAdvance\": 0,\n        \"fromWireType\": function fromWireType() {\n          return undefined;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return undefined;\n        }\n      });\n    }\n    function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n    function __emval_take_value(type, argv) {\n      type = requireRegisteredType(type, \"_emval_take_value\");\n      var v = type[\"readValueFromPointer\"](argv);\n      return Emval.toHandle(v);\n    }\n    function _abort() {\n      abort(\"\");\n    }\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {}\n    }\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      var maxHeapSize = 2147483648;\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var ENV = {};\n    function getExecutableName() {\n      return thisProgram || \"./this.program\";\n    }\n    function getEnvStrings() {\n      if (!getEnvStrings.strings) {\n        var lang = (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n        var env = {\n          \"USER\": \"web_user\",\n          \"LOGNAME\": \"web_user\",\n          \"PATH\": \"/\",\n          \"PWD\": \"/\",\n          \"HOME\": \"/home/web_user\",\n          \"LANG\": lang,\n          \"_\": getExecutableName()\n        };\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(x + \"=\" + env[x]);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    }\n    var PATH = {\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = path.charAt(0) === \"/\",\n          trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          return \".\";\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: function basename(path) {\n        if (path === \"/\") return \"/\";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function extname(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function join() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      }\n    };\n    function getRandomDevice() {\n      if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n        var randomBuffer = new Uint8Array(1);\n        return function () {\n          crypto.getRandomValues(randomBuffer);\n          return randomBuffer[0];\n        };\n      } else return function () {\n        abort(\"randomDevice\");\n      };\n    }\n    var PATH_FS = {\n      resolve: function resolve() {\n        var resolvedPath = \"\",\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n          if (typeof path !== \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === \"/\";\n        }\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: function relative(from, to) {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\") break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\") break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var TTY = {\n      ttys: [],\n      init: function init() {},\n      shutdown: function shutdown() {},\n      register: function register(dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function close(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        flush: function flush(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        read: function read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write: function write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function get_char(tty) {\n          if (!tty.input.length) {\n            var result = null;\n            if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n              result = window.prompt(\"Input: \");\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            } else if (typeof readline == \"function\") {\n              result = readline();\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            }\n            if (!result) {\n              return null;\n            }\n            tty.input = intArrayFromString(result, true);\n          }\n          return tty.input.shift();\n        },\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function flush(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      },\n      default_tty1_ops: {\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function flush(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    function mmapAlloc(size) {\n      abort();\n    }\n    var MEMFS = {\n      ops_table: null,\n      mount: function mount(_mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode: function createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray: function getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage: function resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr: function getattr(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod: function mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n          old_node.parent = new_dir;\n        },\n        unlink: function unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir: function rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir: function readdir(node) {\n          var entries = [\".\", \"..\"];\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink: function symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          }\n          return size;\n        },\n        write: function write(stream, buffer, offset, length, position, canOwn) {\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate: function allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function mmap(stream, address, length, position, prot, flags) {\n          if (address !== 0) {\n            throw new FS.ErrnoError(28);\n          }\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          if (!(flags & 2) && contents.buffer === buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            HEAP8.set(contents, ptr);\n          }\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync: function msync(stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          if (mmapFlags & 2) {\n            return 0;\n          }\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    function asyncLoad(url, onload, onerror, noRunDep) {\n      var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\n      readAsync(url, function (arrayBuffer) {\n        assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n        onload(new Uint8Array(arrayBuffer));\n        if (dep) removeRunDependency(dep);\n      }, function (event) {\n        if (onerror) {\n          onerror();\n        } else {\n          throw 'Loading data file \"' + url + '\" failed.';\n        }\n      });\n      if (dep) addRunDependency(dep);\n    }\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      lookupPath: function lookupPath(path, opts) {\n        path = PATH_FS.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path) return {\n          path: \"\",\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n        var parts = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), false);\n        var current = FS.root;\n        var current_path = \"/\";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count\n              });\n              current = lookup.node;\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath: function getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n          }\n          path = path ? node.name + \"/\" + path : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function hashName(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        return FS.lookup(parent, name);\n      },\n      createNode: function createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint: function isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile: function isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagModes: {\n        \"r\": 0,\n        \"r+\": 2,\n        \"w\": 577,\n        \"w+\": 578,\n        \"a\": 1089,\n        \"a+\": 1090\n      },\n      modeStringToFlags: function modeStringToFlags(str) {\n        var flags = FS.flagModes[str];\n        if (typeof flags === \"undefined\") {\n          throw new Error(\"Unknown file open mode: \" + str);\n        }\n        return flags;\n      },\n      flagsToPermissionString: function flagsToPermissionString(flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n        if (flag & 512) {\n          perms += \"w\";\n        }\n        return perms;\n      },\n      nodePermissions: function nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        if (perms.includes(\"r\") && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup: function mayLookup(dir) {\n        var errCode = FS.nodePermissions(dir, \"x\");\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate: function mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete: function mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, \"wx\");\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen: function mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function nextfd(fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStream: function getStream(fd) {\n        return FS.streams[fd];\n      },\n      createStream: function createStream(stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function () {};\n          FS.FSStream.prototype = {\n            object: {\n              get: function get() {\n                return this.node;\n              },\n              set: function set(val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get: function get() {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get: function get() {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get: function get() {\n                return this.flags & 1024;\n              }\n            }\n          };\n        }\n        var newStream = new FS.FSStream();\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open: function open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek: function llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: function major(dev) {\n        return dev >> 8;\n      },\n      minor: function minor(dev) {\n        return dev & 255;\n      },\n      makedev: function makedev(ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function registerDevice(dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: function getDevice(dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n        return mounts;\n      },\n      syncfs: function syncfs(populate, callback) {\n        if (typeof populate === \"function\") {\n          callback = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function mount(type, opts, mountpoint) {\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path;\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount: function unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function create(path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function mkdirTree(path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += \"/\" + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev: function mkdev(path, mode, dev) {\n        if (typeof dev === \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        lookup = FS.lookupPath(old_path, {\n          parent: true\n        });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, {\n          parent: true\n        });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(28);\n        }\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(55);\n        }\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n        if (old_node === new_node) {\n          return;\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, \"w\");\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir: function rmdir(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir: function readdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink: function unlink(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink: function readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat: function lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod: function chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function fchmod(fd, mode) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chmod(stream.node, mode);\n      },\n      chown: function chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n        });\n      },\n      lchown: function lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function fchown(fd, uid, gid) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, \"w\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate: function ftruncate(fd, len) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime: function utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open: function open(path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === \"undefined\" ? 438 : mode;\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path === \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        if (flags & 512) {\n          FS.truncate(node, 0);\n        }\n        flags &= ~(128 | 512 | 131072);\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          id: node.id,\n          flags: flags,\n          mode: node.mode,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          node_ops: node.node_ops,\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close: function close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed: function isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek: function llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position !== \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position !== \"undefined\";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate: function allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function mmap(stream, address, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);\n      },\n      msync: function msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      munmap: function munmap(stream) {\n        return 0;\n      },\n      ioctl: function ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function readFile(path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || \"binary\";\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function writeFile(path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data === \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n        FS.close(stream);\n      },\n      cwd: function cwd() {\n        return FS.currentPath;\n      },\n      chdir: function chdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function createDefaultDirectories() {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices: function createDefaultDevices() {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function read() {\n            return 0;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var random_device = getRandomDevice();\n        FS.createDevice(\"/dev\", \"random\", random_device);\n        FS.createDevice(\"/dev\", \"urandom\", random_device);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories: function createSpecialDirectories() {\n        FS.mkdir(\"/proc\");\n        var proc_self = FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount: function mount() {\n            var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup: function lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: \"fake\"\n                  },\n                  node_ops: {\n                    readlink: function readlink() {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams: function createStandardStreams() {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n        var stdin = FS.open(\"/dev/stdin\", 0);\n        var stdout = FS.open(\"/dev/stdout\", 1);\n        var stderr = FS.open(\"/dev/stderr\", 1);\n      },\n      ensureErrnoError: function ensureErrnoError() {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.node = node;\n          this.setErrno = function (errno) {\n            this.errno = errno;\n          };\n          this.setErrno(errno);\n          this.message = \"FS error\";\n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [44].forEach(function (code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit: function staticInit() {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          \"MEMFS\": MEMFS\n        };\n      },\n      init: function init(input, output, error) {\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit: function quit() {\n        FS.init.initialized = false;\n        var fflush = Module[\"_fflush\"];\n        if (fflush) fflush(0);\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      getMode: function getMode(canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },\n      findObject: function findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          return null;\n        }\n      },\n      analyzePath: function analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath: function createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n          parent = current;\n        }\n        return current;\n      },\n      createFile: function createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data === \"string\") {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) {\n              arr[i] = data.charCodeAt(i);\n            }\n            data = arr;\n          }\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },\n      createDevice: function createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open: function open(stream) {\n            stream.seekable = false;\n          },\n          close: function close(stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile: function forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (read_) {\n          try {\n            obj.contents = intArrayFromString(read_(obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n      },\n      createLazyFile: function createLazyFile(parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return undefined;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n          var doXHR = function doXHR(from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || \"\", true);\n            }\n          };\n          var lazyArray = this;\n          lazyArray.setDataGetter(function (chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function get() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function get() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function get() {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function (key) {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function forceLoadLazyFile() {\n            FS.forceLoadFile(node);\n            return fn.apply(null, arguments);\n          };\n        });\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          FS.forceLoadFile(node);\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      createPreloadedFile: function createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency(\"cp \" + fullname);\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n          var handled = false;\n          Module[\"preloadPlugins\"].forEach(function (plugin) {\n            if (handled) return;\n            if (plugin[\"canHandle\"](fullname)) {\n              plugin[\"handle\"](byteArray, fullname, finish, function () {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n        addRunDependency(dep);\n        if (typeof url == \"string\") {\n          asyncLoad(url, function (byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },\n      indexedDB: function indexedDB() {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },\n      DB_NAME: function DB_NAME() {\n        return \"EM_FS_\" + window.location.pathname;\n      },\n      DB_VERSION: 20,\n      DB_STORE_NAME: \"FILE_DATA\",\n      saveFilesToDB: function saveFilesToDB(paths, onload, onerror) {\n        onload = onload || function () {};\n        onerror = onerror || function () {};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          out(\"creating db\");\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n            fail = 0,\n            total = paths.length;\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n          paths.forEach(function (path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = function putRequest_onsuccess() {\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            putRequest.onerror = function putRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      },\n      loadFilesFromDB: function loadFilesFromDB(paths, onload, onerror) {\n        onload = onload || function () {};\n        onerror = onerror || function () {};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = onerror;\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\n          } catch (e) {\n            onerror(e);\n            return;\n          }\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n            fail = 0,\n            total = paths.length;\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n          paths.forEach(function (path) {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            getRequest.onerror = function getRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      }\n    };\n    var SYSCALLS = {\n      mappings: {},\n      DEFAULT_POLLMASK: 5,\n      calculateAt: function calculateAt(dirfd, path, allowEmpty) {\n        if (path[0] === \"/\") {\n          return path;\n        }\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = FS.getStream(dirfd);\n          if (!dirstream) throw new FS.ErrnoError(8);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat: function doStat(func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -54;\n          }\n          throw e;\n        }\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAP32[buf + 48 >> 2] = 4096;\n        HEAP32[buf + 52 >> 2] = stat.blocks;\n        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 76 >> 2] = 0;\n        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync: function doMsync(addr, stream, len, flags, offset) {\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      doMkdir: function doMkdir(path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },\n      doMknod: function doMknod(path, mode, dev) {\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n          default:\n            return -28;\n        }\n        FS.mknod(path, mode, dev);\n        return 0;\n      },\n      doReadlink: function doReadlink(path, buf, bufsize) {\n        if (bufsize <= 0) return -28;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len;\n      },\n      doAccess: function doAccess(path, amode) {\n        if (amode & ~7) {\n          return -28;\n        }\n        var node;\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        node = lookup.node;\n        if (!node) {\n          return -44;\n        }\n        var perms = \"\";\n        if (amode & 4) perms += \"r\";\n        if (amode & 2) perms += \"w\";\n        if (amode & 1) perms += \"x\";\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -2;\n        }\n        return 0;\n      },\n      doDup: function doDup(path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },\n      doReadv: function doReadv(stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.read(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break;\n        }\n        return ret;\n      },\n      doWritev: function doWritev(stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.write(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n        return ret;\n      },\n      varargs: undefined,\n      get: function get() {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      getStreamFromFD: function getStreamFromFD(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) throw new FS.ErrnoError(8);\n        return stream;\n      },\n      get64: function get64(low, high) {\n        return low;\n      }\n    };\n    function _environ_get(__environ, environ_buf) {\n      var bufSize = 0;\n      getEnvStrings().forEach(function (string, i) {\n        var ptr = environ_buf + bufSize;\n        HEAP32[__environ + i * 4 >> 2] = ptr;\n        writeAsciiToMemory(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    }\n    function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = getEnvStrings();\n      HEAP32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(function (string) {\n        bufSize += string.length + 1;\n      });\n      HEAP32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    }\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var HIGH_OFFSET = 4294967296;\n        var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\n        var DOUBLE_LIMIT = 9007199254740992;\n        if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\n          return -61;\n        }\n        FS.llseek(stream, offset, whence);\n        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n    function _setTempRet0(val) {\n      setTempRet0(val);\n    }\n    function __isLeapYear(year) {\n      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    }\n    function __arraySum(array, index) {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]) {}\n      return sum;\n    }\n    var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    function __addDays(date, days) {\n      var newDate = new Date(date.getTime());\n      while (days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n          days -= daysInCurrentMonth - newDate.getDate() + 1;\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth + 1);\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear() + 1);\n          }\n        } else {\n          newDate.setDate(newDate.getDate() + days);\n          return newDate;\n        }\n      }\n      return newDate;\n    }\n    function _strftime(s, maxsize, format, tm) {\n      var tm_zone = HEAP32[tm + 40 >> 2];\n      var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[tm + 4 >> 2],\n        tm_hour: HEAP32[tm + 8 >> 2],\n        tm_mday: HEAP32[tm + 12 >> 2],\n        tm_mon: HEAP32[tm + 16 >> 2],\n        tm_year: HEAP32[tm + 20 >> 2],\n        tm_wday: HEAP32[tm + 24 >> 2],\n        tm_yday: HEAP32[tm + 28 >> 2],\n        tm_isdst: HEAP32[tm + 32 >> 2],\n        tm_gmtoff: HEAP32[tm + 36 >> 2],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n      };\n      var pattern = UTF8ToString(format);\n      var EXPANSION_RULES_1 = {\n        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n        \"%D\": \"%m/%d/%y\",\n        \"%F\": \"%Y-%m-%d\",\n        \"%h\": \"%b\",\n        \"%r\": \"%I:%M:%S %p\",\n        \"%R\": \"%H:%M\",\n        \"%T\": \"%H:%M:%S\",\n        \"%x\": \"%m/%d/%y\",\n        \"%X\": \"%H:%M:%S\",\n        \"%Ec\": \"%c\",\n        \"%EC\": \"%C\",\n        \"%Ex\": \"%m/%d/%y\",\n        \"%EX\": \"%H:%M:%S\",\n        \"%Ey\": \"%y\",\n        \"%EY\": \"%Y\",\n        \"%Od\": \"%d\",\n        \"%Oe\": \"%e\",\n        \"%OH\": \"%H\",\n        \"%OI\": \"%I\",\n        \"%Om\": \"%m\",\n        \"%OM\": \"%M\",\n        \"%OS\": \"%S\",\n        \"%Ou\": \"%u\",\n        \"%OU\": \"%U\",\n        \"%OV\": \"%V\",\n        \"%Ow\": \"%w\",\n        \"%OW\": \"%W\",\n        \"%Oy\": \"%y\"\n      };\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n      }\n      var WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n      var MONTHS = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n      function leadingSomething(value, digits, character) {\n        var str = typeof value === \"number\" ? value.toString() : value || \"\";\n        while (str.length < digits) {\n          str = character[0] + str;\n        }\n        return str;\n      }\n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, \"0\");\n      }\n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : value > 0 ? 1 : 0;\n        }\n        var compare;\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate() - date2.getDate());\n          }\n        }\n        return compare;\n      }\n      function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n          case 0:\n            return new Date(janFourth.getFullYear() - 1, 11, 29);\n          case 1:\n            return janFourth;\n          case 2:\n            return new Date(janFourth.getFullYear(), 0, 3);\n          case 3:\n            return new Date(janFourth.getFullYear(), 0, 2);\n          case 4:\n            return new Date(janFourth.getFullYear(), 0, 1);\n          case 5:\n            return new Date(janFourth.getFullYear() - 1, 11, 31);\n          case 6:\n            return new Date(janFourth.getFullYear() - 1, 11, 30);\n        }\n      }\n      function getWeekBasedYear(date) {\n        var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n            return thisDate.getFullYear() + 1;\n          } else {\n            return thisDate.getFullYear();\n          }\n        } else {\n          return thisDate.getFullYear() - 1;\n        }\n      }\n      var EXPANSION_RULES_2 = {\n        \"%a\": function a(date) {\n          return WEEKDAYS[date.tm_wday].substring(0, 3);\n        },\n        \"%A\": function A(date) {\n          return WEEKDAYS[date.tm_wday];\n        },\n        \"%b\": function b(date) {\n          return MONTHS[date.tm_mon].substring(0, 3);\n        },\n        \"%B\": function B(date) {\n          return MONTHS[date.tm_mon];\n        },\n        \"%C\": function C(date) {\n          var year = date.tm_year + 1900;\n          return leadingNulls(year / 100 | 0, 2);\n        },\n        \"%d\": function d(date) {\n          return leadingNulls(date.tm_mday, 2);\n        },\n        \"%e\": function e(date) {\n          return leadingSomething(date.tm_mday, 2, \" \");\n        },\n        \"%g\": function g(date) {\n          return getWeekBasedYear(date).toString().substring(2);\n        },\n        \"%G\": function G(date) {\n          return getWeekBasedYear(date);\n        },\n        \"%H\": function H(date) {\n          return leadingNulls(date.tm_hour, 2);\n        },\n        \"%I\": function I(date) {\n          var twelveHour = date.tm_hour;\n          if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        \"%j\": function j(date) {\n          return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n        },\n        \"%m\": function m(date) {\n          return leadingNulls(date.tm_mon + 1, 2);\n        },\n        \"%M\": function M(date) {\n          return leadingNulls(date.tm_min, 2);\n        },\n        \"%n\": function n() {\n          return \"\\n\";\n        },\n        \"%p\": function p(date) {\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\n            return \"AM\";\n          } else {\n            return \"PM\";\n          }\n        },\n        \"%S\": function S(date) {\n          return leadingNulls(date.tm_sec, 2);\n        },\n        \"%t\": function t() {\n          return \"\\t\";\n        },\n        \"%u\": function u(date) {\n          return date.tm_wday || 7;\n        },\n        \"%U\": function U(date) {\n          var janFirst = new Date(date.tm_year + 1900, 0, 1);\n          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n          var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n          if (compareByDay(firstSunday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n            var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n          return compareByDay(firstSunday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%V\": function V(date) {\n          var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\n          var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n          var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n            return \"53\";\n          }\n          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n            return \"01\";\n          }\n          var daysDifference;\n          if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\n            daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\n          } else {\n            daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\n          }\n          return leadingNulls(Math.ceil(daysDifference / 7), 2);\n        },\n        \"%w\": function w(date) {\n          return date.tm_wday;\n        },\n        \"%W\": function W(date) {\n          var janFirst = new Date(date.tm_year, 0, 1);\n          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n          var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n          if (compareByDay(firstMonday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n            var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n          return compareByDay(firstMonday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%y\": function y(date) {\n          return (date.tm_year + 1900).toString().substring(2);\n        },\n        \"%Y\": function Y(date) {\n          return date.tm_year + 1900;\n        },\n        \"%z\": function z(date) {\n          var off = date.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          off = off / 60 * 100 + off % 60;\n          return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n        },\n        \"%Z\": function Z(date) {\n          return date.tm_zone;\n        },\n        \"%%\": function _() {\n          return \"%\";\n        }\n      };\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.includes(rule)) {\n          pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n        }\n      }\n      var bytes = intArrayFromString(pattern, false);\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n      writeArrayToMemory(bytes, s);\n      return bytes.length - 1;\n    }\n    function _strftime_l(s, maxsize, format, tm) {\n      return _strftime(s, maxsize, format, tm);\n    }\n    InternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n    init_ClassHandle();\n    init_RegisteredPointer();\n    init_embind();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n    init_emval();\n    var FSNode = function FSNode(parent, name, mode, rdev) {\n      if (!parent) {\n        parent = this;\n      }\n      this.parent = parent;\n      this.mount = parent.mount;\n      this.mounted = null;\n      this.id = FS.nextInode++;\n      this.name = name;\n      this.mode = mode;\n      this.node_ops = {};\n      this.stream_ops = {};\n      this.rdev = rdev;\n    };\n    var readMode = 292 | 73;\n    var writeMode = 146;\n    Object.defineProperties(FSNode.prototype, {\n      read: {\n        get: function get() {\n          return (this.mode & readMode) === readMode;\n        },\n        set: function set(val) {\n          val ? this.mode |= readMode : this.mode &= ~readMode;\n        }\n      },\n      write: {\n        get: function get() {\n          return (this.mode & writeMode) === writeMode;\n        },\n        set: function set(val) {\n          val ? this.mode |= writeMode : this.mode &= ~writeMode;\n        }\n      },\n      isFolder: {\n        get: function get() {\n          return FS.isDir(this.mode);\n        }\n      },\n      isDevice: {\n        get: function get() {\n          return FS.isChrdev(this.mode);\n        }\n      }\n    });\n    FS.FSNode = FSNode;\n    FS.staticInit();\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var asmLibraryArg = {\n      \"d\": ___cxa_allocate_exception,\n      \"e\": ___cxa_throw,\n      \"n\": __embind_finalize_value_array,\n      \"p\": __embind_finalize_value_object,\n      \"y\": __embind_register_bigint,\n      \"I\": __embind_register_bool,\n      \"h\": __embind_register_class,\n      \"g\": __embind_register_class_constructor,\n      \"c\": __embind_register_class_function,\n      \"r\": __embind_register_class_property,\n      \"H\": __embind_register_emval,\n      \"q\": __embind_register_enum,\n      \"i\": __embind_register_enum_value,\n      \"v\": __embind_register_float,\n      \"a\": __embind_register_function,\n      \"k\": __embind_register_integer,\n      \"j\": __embind_register_memory_view,\n      \"w\": __embind_register_std_string,\n      \"t\": __embind_register_std_wstring,\n      \"o\": __embind_register_value_array,\n      \"b\": __embind_register_value_array_element,\n      \"m\": __embind_register_value_object,\n      \"f\": __embind_register_value_object_field,\n      \"J\": __embind_register_void,\n      \"K\": __emval_decref,\n      \"L\": __emval_incref,\n      \"l\": __emval_take_value,\n      \"u\": _abort,\n      \"A\": _emscripten_memcpy_big,\n      \"s\": _emscripten_resize_heap,\n      \"C\": _environ_get,\n      \"D\": _environ_sizes_get,\n      \"G\": _fd_close,\n      \"E\": _fd_read,\n      \"x\": _fd_seek,\n      \"F\": _fd_write,\n      \"z\": _setTempRet0,\n      \"B\": _strftime_l\n    };\n    var asm = createWasm();\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"N\"]).apply(null, arguments);\n    };\n    var _malloc = Module[\"_malloc\"] = function () {\n      return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"P\"]).apply(null, arguments);\n    };\n    var _free = Module[\"_free\"] = function () {\n      return (_free = Module[\"_free\"] = Module[\"asm\"][\"Q\"]).apply(null, arguments);\n    };\n    var ___getTypeName = Module[\"___getTypeName\"] = function () {\n      return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"R\"]).apply(null, arguments);\n    };\n    var ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function () {\n      return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"S\"]).apply(null, arguments);\n    };\n    var stackSave = Module[\"stackSave\"] = function () {\n      return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"T\"]).apply(null, arguments);\n    };\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"U\"]).apply(null, arguments);\n    };\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      return (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"V\"]).apply(null, arguments);\n    };\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n      return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"W\"]).apply(null, arguments);\n    };\n    var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = function () {\n      return (dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = Module[\"asm\"][\"X\"]).apply(null, arguments);\n    };\n    var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = function () {\n      return (dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = Module[\"asm\"][\"Y\"]).apply(null, arguments);\n    };\n    var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = function () {\n      return (dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = Module[\"asm\"][\"Z\"]).apply(null, arguments);\n    };\n    var dynCall_viijii = Module[\"dynCall_viijii\"] = function () {\n      return (dynCall_viijii = Module[\"dynCall_viijii\"] = Module[\"asm\"][\"_\"]).apply(null, arguments);\n    };\n    Module[\"ccall\"] = ccall;\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run(args) {\n      args = args || arguments_;\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    Module[\"run\"] = run;\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n    return Module.ready;\n  };\n}();\nexport default Module;"]}}